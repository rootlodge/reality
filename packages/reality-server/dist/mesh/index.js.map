{"version":3,"sources":["../../src/types/index.ts","../../src/mesh/coordinator.ts"],"names":["z"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * @rootlodge/reality-server - Server Types\r\n * \r\n * Type definitions for the Reality server.\r\n * Shared types are duplicated here to avoid circular dependencies.\r\n */\r\n\r\nimport { z } from 'zod';\r\n\r\n// ============================================================================\r\n// Shared Types (duplicated from @rootlodge/reality for independence)\r\n// ============================================================================\r\n\r\nexport const RealityModeSchema = z.enum(['native', 'sse-compat', 'polling-compat']);\r\nexport type RealityMode = z.infer<typeof RealityModeSchema>;\r\n\r\nexport const SyncHintSchema = z.enum(['interaction', 'focus', 'idle', 'mutation', 'mount', 'reconnect']);\r\nexport type SyncHint = z.infer<typeof SyncHintSchema>;\r\n\r\nexport const RealityNodeMetaSchema = z.object({\r\n  key: z.string(),\r\n  version: z.number().int().nonnegative(),\r\n  hash: z.string(),\r\n  updatedAt: z.number().int(),\r\n});\r\n\r\nexport type RealityNodeMeta = z.infer<typeof RealityNodeMetaSchema>;\r\n\r\nexport const PeerHealthSchema = z.enum(['healthy', 'degraded', 'unhealthy', 'unknown']);\r\nexport type PeerHealth = z.infer<typeof PeerHealthSchema>;\r\n\r\nexport const PeerSummarySchema = z.object({\r\n  peer: z.string().url(),\r\n  maxVersionSeen: z.number().int().nonnegative(),\r\n  lastSeen: z.number().int(),\r\n  health: PeerHealthSchema.optional(),\r\n});\r\n\r\nexport type PeerSummary = z.infer<typeof PeerSummarySchema>;\r\n\r\nexport const SyncRequestSchema = z.object({\r\n  known: z.record(z.string(), z.number().int().nonnegative()),\r\n  clientId: z.string().uuid(),\r\n  mode: RealityModeSchema,\r\n  hint: SyncHintSchema,\r\n  timestamp: z.number().int().optional(),\r\n});\r\n\r\nexport type SyncRequest = z.infer<typeof SyncRequestSchema>;\r\n\r\nexport const ChangedNodeSchema = z.object({\r\n  version: z.number().int().nonnegative(),\r\n  hash: z.string(),\r\n  source: z.string().optional(),\r\n  payload: z.unknown().optional(),\r\n});\r\n\r\nexport type ChangedNode = z.infer<typeof ChangedNodeSchema>;\r\n\r\nexport const MeshInfoSchema = z.object({\r\n  peers: z.record(z.string(), PeerHealthSchema),\r\n  serverVersion: z.number().int().nonnegative().optional(),\r\n});\r\n\r\nexport type MeshInfo = z.infer<typeof MeshInfoSchema>;\r\n\r\nexport const SyncResponseSchema = z.object({\r\n  changed: z.record(z.string(), ChangedNodeSchema),\r\n  mesh: MeshInfoSchema,\r\n  serverTime: z.number().int(),\r\n});\r\n\r\nexport type SyncResponse = z.infer<typeof SyncResponseSchema>;\r\n\r\n// ============================================================================\r\n// Execution & Persistence Modes\r\n// ============================================================================\r\n\r\n/**\r\n * Persistence mode for Reality\r\n * - 'none': No database required, in-memory only\r\n * - 'advisory': Optional DB adapters for invalidation hints\r\n * - 'external': Application manages its own persistence\r\n */\r\nexport const RealityPersistenceModeSchema = z.enum(['none', 'advisory', 'external']);\r\nexport type RealityPersistenceMode = z.infer<typeof RealityPersistenceModeSchema>;\r\n\r\n/**\r\n * Execution mode for Reality\r\n * - 'client': Browser/client-side, HTTP to external servers\r\n * - 'ssr-embedded': SSR with in-process server (TanStack/Vite)\r\n * - 'server-external': Dedicated server mode\r\n * - 'auto': Automatically detect based on environment\r\n */\r\nexport const RealityExecutionModeSchema = z.enum(['client', 'ssr-embedded', 'server-external', 'auto']);\r\nexport type RealityExecutionMode = z.infer<typeof RealityExecutionModeSchema>;\r\n\r\n// ============================================================================\r\n// Invalidation Adapter Interface\r\n// ============================================================================\r\n\r\n/**\r\n * Invalidation adapter for advisory database integration\r\n * Reality does NOT own your data - this is optional!\r\n */\r\nexport interface RealityInvalidationAdapter {\r\n  /** Hook called when keys should be invalidated */\r\n  onInvalidate(keys: string[]): Promise<void>;\r\n  /** Hook called before a transaction (for auto-invalidation) */\r\n  beforeTransaction?<T>(fn: () => Promise<T>): Promise<T>;\r\n  /** Hook called after a transaction (for auto-invalidation) */\r\n  afterTransaction?(affectedKeys: string[]): Promise<void>;\r\n}\r\n\r\n/**\r\n * Configuration for invalidation behavior\r\n */\r\nexport interface InvalidationConfig {\r\n  /** Invalidation adapter instance */\r\n  adapter?: RealityInvalidationAdapter;\r\n  /** Persistence mode */\r\n  mode?: RealityPersistenceMode;\r\n}\r\n\r\n// ============================================================================\r\n// Storage Interface (optional - Reality works without it)\r\n// ============================================================================\r\n\r\nexport interface RealityStorage {\r\n  /** Get metadata for a node */\r\n  getNode(key: string): Promise<RealityNodeMeta | null>;\r\n  /** Set metadata for a node */\r\n  setNode(meta: RealityNodeMeta): Promise<void>;\r\n  /** Increment version and update hash */\r\n  incrementVersion(key: string, hash: string): Promise<RealityNodeMeta>;\r\n  /** List nodes changed since a given version */\r\n  listChangedSince(version: number): Promise<RealityNodeMeta[]>;\r\n  /** Get multiple nodes by keys */\r\n  getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>>;\r\n  /** Get current max version across all nodes */\r\n  getMaxVersion(): Promise<number>;\r\n  /** Delete a node */\r\n  deleteNode(key: string): Promise<void>;\r\n  /** Health check */\r\n  isHealthy(): Promise<boolean>;\r\n}\r\n\r\n// ============================================================================\r\n// Database Adapter Interface\r\n// ============================================================================\r\n\r\nexport interface DatabaseAdapter {\r\n  /** Fetch payload for a key */\r\n  fetchPayload<T = unknown>(key: string): Promise<T | null>;\r\n  /** Store payload for a key */\r\n  storePayload<T = unknown>(key: string, payload: T): Promise<void>;\r\n  /** Delete payload */\r\n  deletePayload(key: string): Promise<void>;\r\n  /** Batch fetch payloads */\r\n  fetchPayloads<T = unknown>(keys: string[]): Promise<Map<string, T>>;\r\n}\r\n\r\n// ============================================================================\r\n// Server Configuration\r\n// ============================================================================\r\n\r\nexport const ServerConfigSchema = z.object({\r\n  /** Server identifier (unique across mesh) */\r\n  serverId: z.string().min(1),\r\n  /** HTTP port to listen on */\r\n  port: z.number().int().positive().default(3000),\r\n  /** Host to bind to */\r\n  host: z.string().default('0.0.0.0'),\r\n  /** Peer server URLs for mesh */\r\n  peers: z.array(z.string().url()).default([]),\r\n  /** CORS configuration */\r\n  cors: z.object({\r\n    origins: z.array(z.string()).default(['*']),\r\n    credentials: z.boolean().default(true),\r\n  }).default({}),\r\n  /** Rate limiting */\r\n  rateLimit: z.object({\r\n    enabled: z.boolean().default(false),\r\n    maxRequests: z.number().int().positive().default(100),\r\n    windowMs: z.number().int().positive().default(60000),\r\n  }).default({}),\r\n  /** Enable debug logging */\r\n  debug: z.boolean().default(false),\r\n  /** Storage configuration */\r\n  storage: z.object({\r\n    type: z.enum(['memory', 'drizzle', 'prisma', 'sql', 'dynamodb', 'redis', 'custom']).default('memory'),\r\n    connectionString: z.string().optional(),\r\n    tableName: z.string().default('reality_nodes'),\r\n  }).default({}),\r\n  /** Redis configuration (optional acceleration) */\r\n  redis: z.object({\r\n    enabled: z.boolean().default(false),\r\n    url: z.string().optional(),\r\n    prefix: z.string().default('reality:'),\r\n  }).default({}),\r\n  /** Payload fetcher base URL */\r\n  payloadBaseUrl: z.string().url().optional(),\r\n  /** Execution mode */\r\n  executionMode: RealityExecutionModeSchema.default('server-external'),\r\n  /** Invalidation configuration (optional) */\r\n  invalidation: z.object({\r\n    mode: RealityPersistenceModeSchema.default('none'),\r\n  }).default({}),\r\n});\r\n\r\nexport type ServerConfig = z.input<typeof ServerConfigSchema>;\r\nexport type ResolvedServerConfig = z.output<typeof ServerConfigSchema>;\r\n\r\n// ============================================================================\r\n// Mesh Types\r\n// ============================================================================\r\n\r\nexport interface PeerInfo {\r\n  url: string;\r\n  serverId: string;\r\n  health: PeerHealth;\r\n  maxVersionSeen: number;\r\n  lastSeen: number;\r\n  lastLatency: number;\r\n}\r\n\r\nexport interface MeshState {\r\n  serverId: string;\r\n  maxVersionSeen: number;\r\n  peers: Map<string, PeerInfo>;\r\n  lastGossipTime: number;\r\n}\r\n\r\nexport interface GossipPayload {\r\n  serverId: string;\r\n  maxVersion: number;\r\n  peerSummaries: Array<{\r\n    url: string;\r\n    health: PeerHealth;\r\n    maxVersion: number;\r\n    lastSeen: number;\r\n  }>;\r\n  timestamp: number;\r\n}\r\n\r\nexport const GossipPayloadSchema = z.object({\r\n  serverId: z.string(),\r\n  maxVersion: z.number().int().nonnegative(),\r\n  peerSummaries: z.array(z.object({\r\n    url: z.string().url(),\r\n    health: z.enum(['healthy', 'degraded', 'unhealthy', 'unknown']),\r\n    maxVersion: z.number().int().nonnegative(),\r\n    lastSeen: z.number().int(),\r\n  })),\r\n  timestamp: z.number().int(),\r\n});\r\n\r\n// ============================================================================\r\n// Request/Response Types\r\n// ============================================================================\r\n\r\nexport interface InvalidationRequest {\r\n  keys: string[];\r\n  source?: string;\r\n  timestamp?: number;\r\n}\r\n\r\nexport const InvalidationRequestSchema = z.object({\r\n  keys: z.array(z.string()).min(1),\r\n  source: z.string().optional(),\r\n  timestamp: z.number().int().optional(),\r\n});\r\n\r\nexport interface InvalidationResponse {\r\n  invalidated: string[];\r\n  versions: Record<string, number>;\r\n}\r\n\r\nexport interface HealthResponse {\r\n  status: 'healthy' | 'degraded' | 'unhealthy';\r\n  serverId: string;\r\n  version: string;\r\n  uptime: number;\r\n  mesh: {\r\n    peerCount: number;\r\n    healthyPeers: number;\r\n  };\r\n  storage: {\r\n    healthy: boolean;\r\n    maxVersion: number;\r\n  };\r\n  redis?: {\r\n    connected: boolean;\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// HTTP Handler Types\r\n// ============================================================================\r\n\r\nexport interface RealityRequest {\r\n  method: string;\r\n  url: string;\r\n  headers: Headers;\r\n  body: unknown;\r\n  params: Record<string, string>;\r\n  query: Record<string, string>;\r\n}\r\n\r\nexport interface RealityResponse {\r\n  status: number;\r\n  headers: Record<string, string>;\r\n  body: unknown;\r\n}\r\n\r\nexport type RealityHandler = (req: RealityRequest) => Promise<RealityResponse>;\r\n\r\n// ============================================================================\r\n// Middleware Types\r\n// ============================================================================\r\n\r\nexport type Middleware = (\r\n  req: RealityRequest,\r\n  next: () => Promise<RealityResponse>\r\n) => Promise<RealityResponse>;\r\n\r\n// ============================================================================\r\n// Storage Factory Types\r\n// ============================================================================\r\n\r\nexport interface StorageFactory {\r\n  create(config: ResolvedServerConfig): Promise<RealityStorage>;\r\n}\r\n\r\n// ============================================================================\r\n// Database Adapter Factory Types\r\n// ============================================================================\r\n\r\nexport interface DatabaseAdapterFactory {\r\n  create(config: ResolvedServerConfig): Promise<DatabaseAdapter>;\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Mesh Coordinator\r\n * \r\n * Manages peer awareness and gossip protocol for server mesh.\r\n * Servers are stateless but mesh-aware.\r\n */\r\n\r\nimport type { PeerInfo, MeshState, GossipPayload, PeerHealth } from '../types';\r\nimport { GossipPayloadSchema } from '../types';\r\n\r\n/**\r\n * Mesh coordinator configuration\r\n */\r\nexport interface MeshConfig {\r\n  /** This server's ID */\r\n  serverId: string;\r\n  /** Peer server URLs */\r\n  peers: string[];\r\n  /** Request timeout for peer communication */\r\n  timeout?: number;\r\n  /** How long before a peer is considered stale */\r\n  staleThreshold?: number;\r\n  /** Enable debug logging */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Mesh Coordinator - manages peer awareness without leader election\r\n * \r\n * Key principles:\r\n * - No leader election\r\n * - No background polling loops\r\n * - Gossip piggybacks on normal requests\r\n * - Each server maintains its own view of the mesh\r\n */\r\nexport class MeshCoordinator {\r\n  private config: MeshConfig;\r\n  private state: MeshState;\r\n\r\n  constructor(config: MeshConfig) {\r\n    this.config = {\r\n      timeout: 5000,\r\n      staleThreshold: 60000,\r\n      debug: false,\r\n      ...config,\r\n    };\r\n\r\n    this.state = {\r\n      serverId: config.serverId,\r\n      maxVersionSeen: 0,\r\n      peers: new Map(),\r\n      lastGossipTime: 0,\r\n    };\r\n\r\n    // Initialize peer list\r\n    for (const url of config.peers) {\r\n      this.state.peers.set(url, {\r\n        url,\r\n        serverId: '', // Will be populated on first contact\r\n        health: 'unknown',\r\n        maxVersionSeen: 0,\r\n        lastSeen: 0,\r\n        lastLatency: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current server ID\r\n   */\r\n  getServerId(): string {\r\n    return this.state.serverId;\r\n  }\r\n\r\n  /**\r\n   * Get current max version seen by this server\r\n   */\r\n  getMaxVersionSeen(): number {\r\n    return this.state.maxVersionSeen;\r\n  }\r\n\r\n  /**\r\n   * Update max version seen\r\n   */\r\n  updateMaxVersion(version: number): void {\r\n    this.state.maxVersionSeen = Math.max(this.state.maxVersionSeen, version);\r\n  }\r\n\r\n  /**\r\n   * Get peer health map for sync responses\r\n   */\r\n  getPeerHealthMap(): Record<string, PeerHealth> {\r\n    const result: Record<string, PeerHealth> = {};\r\n    \r\n    for (const [url, peer] of this.state.peers) {\r\n      result[url] = peer.health;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get all peers\r\n   */\r\n  getPeers(): Map<string, PeerInfo> {\r\n    return new Map(this.state.peers);\r\n  }\r\n\r\n  /**\r\n   * Get healthy peers sorted by staleness (least stale first)\r\n   */\r\n  getHealthyPeers(): PeerInfo[] {\r\n    const now = Date.now();\r\n    const staleThreshold = this.config.staleThreshold!;\r\n\r\n    return Array.from(this.state.peers.values())\r\n      .filter((peer) => {\r\n        if (peer.health === 'unhealthy') return false;\r\n        if (now - peer.lastSeen > staleThreshold) return false;\r\n        return true;\r\n      })\r\n      .sort((a, b) => {\r\n        // Prefer highest maxVersionSeen (least stale)\r\n        const versionDiff = b.maxVersionSeen - a.maxVersionSeen;\r\n        if (versionDiff !== 0) return versionDiff;\r\n        // Then prefer lowest latency\r\n        return a.lastLatency - b.lastLatency;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Create gossip payload to piggyback on responses\r\n   */\r\n  createGossipPayload(): GossipPayload {\r\n    const peerSummaries = Array.from(this.state.peers.values()).map((peer) => ({\r\n      url: peer.url,\r\n      health: peer.health,\r\n      maxVersion: peer.maxVersionSeen,\r\n      lastSeen: peer.lastSeen,\r\n    }));\r\n\r\n    return {\r\n      serverId: this.state.serverId,\r\n      maxVersion: this.state.maxVersionSeen,\r\n      peerSummaries,\r\n      timestamp: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Process incoming gossip from a peer\r\n   */\r\n  processGossip(gossip: GossipPayload, sourceUrl: string, latency: number): void {\r\n    // Validate gossip payload\r\n    const parsed = GossipPayloadSchema.safeParse(gossip);\r\n    if (!parsed.success) {\r\n      if (this.config.debug) {\r\n        console.warn(`[Mesh] Invalid gossip from ${sourceUrl}:`, parsed.error);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    // Update source peer info\r\n    const sourcePeer = this.state.peers.get(sourceUrl);\r\n    if (sourcePeer) {\r\n      sourcePeer.serverId = gossip.serverId;\r\n      sourcePeer.health = 'healthy';\r\n      sourcePeer.maxVersionSeen = gossip.maxVersion;\r\n      sourcePeer.lastSeen = now;\r\n      sourcePeer.lastLatency = latency;\r\n    }\r\n\r\n    // Process peer summaries (transitive gossip)\r\n    for (const summary of gossip.peerSummaries) {\r\n      // Don't process ourselves\r\n      if (summary.url === this.getServerUrl()) continue;\r\n\r\n      let peer = this.state.peers.get(summary.url);\r\n      \r\n      if (!peer) {\r\n        // Discovered a new peer!\r\n        peer = {\r\n          url: summary.url,\r\n          serverId: '',\r\n          health: summary.health,\r\n          maxVersionSeen: summary.maxVersion,\r\n          lastSeen: summary.lastSeen,\r\n          lastLatency: 0,\r\n        };\r\n        this.state.peers.set(summary.url, peer);\r\n        \r\n        if (this.config.debug) {\r\n          console.log(`[Mesh] Discovered new peer: ${summary.url}`);\r\n        }\r\n      } else {\r\n        // Update with more recent info\r\n        if (summary.lastSeen > peer.lastSeen) {\r\n          peer.health = summary.health;\r\n          peer.maxVersionSeen = Math.max(peer.maxVersionSeen, summary.maxVersion);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.state.lastGossipTime = now;\r\n  }\r\n\r\n  /**\r\n   * Mark a peer as unhealthy after failed communication\r\n   */\r\n  markPeerUnhealthy(url: string): void {\r\n    const peer = this.state.peers.get(url);\r\n    if (peer) {\r\n      peer.health = 'unhealthy';\r\n      \r\n      if (this.config.debug) {\r\n        console.log(`[Mesh] Marked peer unhealthy: ${url}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Propagate invalidation to peers\r\n   * \r\n   * This is done opportunistically, piggybacking on the next request.\r\n   * It's NOT required for correctness - just acceleration.\r\n   */\r\n  async propagateInvalidation(keys: string[]): Promise<void> {\r\n    const healthyPeers = this.getHealthyPeers();\r\n    \r\n    // Propagate to a subset of healthy peers (gossip-style)\r\n    const targetPeers = healthyPeers.slice(0, Math.ceil(healthyPeers.length / 2));\r\n\r\n    const promises = targetPeers.map(async (peer) => {\r\n      try {\r\n        const startTime = Date.now();\r\n        \r\n        const response = await fetch(`${peer.url}/reality/invalidate`, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            'X-Reality-Server': this.state.serverId,\r\n          },\r\n          body: JSON.stringify({\r\n            keys,\r\n            source: this.state.serverId,\r\n            timestamp: Date.now(),\r\n          }),\r\n          signal: AbortSignal.timeout(this.config.timeout!),\r\n        });\r\n\r\n        const latency = Date.now() - startTime;\r\n\r\n        if (response.ok) {\r\n          // Process any gossip in response\r\n          const gossip = response.headers.get('X-Reality-Gossip');\r\n          if (gossip) {\r\n            try {\r\n              this.processGossip(JSON.parse(gossip), peer.url, latency);\r\n            } catch {\r\n              // Ignore invalid gossip\r\n            }\r\n          }\r\n        } else {\r\n          this.markPeerUnhealthy(peer.url);\r\n        }\r\n      } catch {\r\n        this.markPeerUnhealthy(peer.url);\r\n      }\r\n    });\r\n\r\n    // Fire and forget - don't wait for all peers\r\n    Promise.allSettled(promises);\r\n  }\r\n\r\n  /**\r\n   * Query a peer for missing versions\r\n   * \r\n   * Used when a client reports versions we haven't seen.\r\n   */\r\n  async queryPeerForVersions(sinceVersion: number): Promise<GossipPayload | null> {\r\n    const healthyPeers = this.getHealthyPeers();\r\n    \r\n    for (const peer of healthyPeers) {\r\n      // Skip peers that don't have newer versions\r\n      if (peer.maxVersionSeen <= sinceVersion) continue;\r\n\r\n      try {\r\n        const startTime = Date.now();\r\n        \r\n        const response = await fetch(\r\n          `${peer.url}/reality/versions?since=${sinceVersion}`,\r\n          {\r\n            headers: {\r\n              'X-Reality-Server': this.state.serverId,\r\n            },\r\n            signal: AbortSignal.timeout(this.config.timeout!),\r\n          }\r\n        );\r\n\r\n        const latency = Date.now() - startTime;\r\n\r\n        if (response.ok) {\r\n          const gossip = await response.json();\r\n          this.processGossip(gossip, peer.url, latency);\r\n          return gossip;\r\n        }\r\n      } catch {\r\n        this.markPeerUnhealthy(peer.url);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get server URL (for self-identification in gossip)\r\n   */\r\n  private getServerUrl(): string {\r\n    // This should be set from config in production\r\n    return `http://localhost:${process.env.PORT ?? 3000}`;\r\n  }\r\n\r\n  /**\r\n   * Get mesh statistics\r\n   */\r\n  getStats(): {\r\n    serverId: string;\r\n    maxVersionSeen: number;\r\n    peerCount: number;\r\n    healthyPeerCount: number;\r\n    lastGossipTime: number;\r\n  } {\r\n    const healthyCount = Array.from(this.state.peers.values())\r\n      .filter((p) => p.health === 'healthy').length;\r\n\r\n    return {\r\n      serverId: this.state.serverId,\r\n      maxVersionSeen: this.state.maxVersionSeen,\r\n      peerCount: this.state.peers.size,\r\n      healthyPeerCount: healthyCount,\r\n      lastGossipTime: this.state.lastGossipTime,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create mesh coordinator\r\n */\r\nexport function createMeshCoordinator(config: MeshConfig): MeshCoordinator {\r\n  return new MeshCoordinator(config);\r\n}\r\n"]}