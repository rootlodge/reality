{"version":3,"sources":["../../src/storage/memory.ts","../../src/storage/sql/sql-storage.ts","../../src/storage/drizzle/drizzle-storage.ts","../../src/storage/prisma/prisma-storage.ts","../../src/storage/nosql/dynamodb-storage.ts"],"names":["command","result"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * @rootlodge/reality-server - Memory Storage\r\n * \r\n * In-memory storage adapter for development and testing.\r\n * Not recommended for production use with multiple servers.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../types';\r\n\r\n/**\r\n * In-memory storage implementation\r\n */\r\nexport class MemoryStorage implements RealityStorage {\r\n  private nodes: Map<string, RealityNodeMeta> = new Map();\r\n  private maxVersion = 0;\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    return this.nodes.get(key) ?? null;\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    this.nodes.set(meta.key, meta);\r\n    this.maxVersion = Math.max(this.maxVersion, meta.version);\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    const version = this.maxVersion + 1;\r\n    \r\n    const meta: RealityNodeMeta = {\r\n      key,\r\n      version,\r\n      hash,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    this.nodes.set(key, meta);\r\n    this.maxVersion = version;\r\n    \r\n    return meta;\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    const result: RealityNodeMeta[] = [];\r\n    \r\n    for (const meta of this.nodes.values()) {\r\n      if (meta.version > version) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n\r\n    return result.sort((a, b) => a.version - b.version);\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    const result = new Map<string, RealityNodeMeta>();\r\n    \r\n    for (const key of keys) {\r\n      const meta = this.nodes.get(key);\r\n      if (meta) {\r\n        result.set(key, meta);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    return this.maxVersion;\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    this.nodes.delete(key);\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Clear all data (useful for testing)\r\n   */\r\n  clear(): void {\r\n    this.nodes.clear();\r\n    this.maxVersion = 0;\r\n  }\r\n\r\n  /**\r\n   * Get all nodes (for debugging)\r\n   */\r\n  getAllNodes(): Map<string, RealityNodeMeta> {\r\n    return new Map(this.nodes);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a memory storage instance\r\n */\r\nexport function createMemoryStorage(): MemoryStorage {\r\n  return new MemoryStorage();\r\n}\r\n","/**\r\n * @rootlodge/reality-server - SQL Storage Adapter\r\n * \r\n * Generic SQL storage adapter that works with any SQL database.\r\n * Provides a base implementation that can be extended for specific databases.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * SQL query executor interface\r\n */\r\nexport interface SQLExecutor {\r\n  execute<T = unknown>(sql: string, params?: unknown[]): Promise<T[]>;\r\n  executeOne<T = unknown>(sql: string, params?: unknown[]): Promise<T | null>;\r\n  transaction<T>(fn: (tx: SQLExecutor) => Promise<T>): Promise<T>;\r\n}\r\n\r\n/**\r\n * SQL dialect configuration\r\n */\r\nexport interface SQLDialect {\r\n  /** Placeholder style: '?' for MySQL/SQLite, '$1' for Postgres */\r\n  placeholder: (index: number) => string;\r\n  /** UPSERT syntax */\r\n  upsert: (table: string, columns: string[], conflictColumn: string) => string;\r\n  /** Current timestamp function */\r\n  now: () => string;\r\n}\r\n\r\n/**\r\n * Common SQL dialects\r\n */\r\nexport const SQLDialects = {\r\n  postgres: {\r\n    placeholder: (i: number) => `$${i}`,\r\n    upsert: (table: string, columns: string[], conflictColumn: string) =>\r\n      `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${columns.map((_, i) => `$${i + 1}`).join(', ')}) ` +\r\n      `ON CONFLICT (${conflictColumn}) DO UPDATE SET ${columns.filter(c => c !== conflictColumn).map((c, _i) => `${c} = EXCLUDED.${c}`).join(', ')}`,\r\n    now: () => 'NOW()',\r\n  },\r\n  mysql: {\r\n    placeholder: () => '?',\r\n    upsert: (table: string, columns: string[], conflictColumn: string) =>\r\n      `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${columns.map(() => '?').join(', ')}) ` +\r\n      `ON DUPLICATE KEY UPDATE ${columns.filter(c => c !== conflictColumn).map(c => `${c} = VALUES(${c})`).join(', ')}`,\r\n    now: () => 'NOW()',\r\n  },\r\n  sqlite: {\r\n    placeholder: () => '?',\r\n    upsert: (table: string, columns: string[], _conflictColumn: string) =>\r\n      `INSERT OR REPLACE INTO ${table} (${columns.join(', ')}) VALUES (${columns.map(() => '?').join(', ')})`,\r\n    now: () => \"datetime('now')\",\r\n  },\r\n} satisfies Record<string, SQLDialect>;\r\n\r\n/**\r\n * SQL Storage configuration\r\n */\r\nexport interface SQLStorageConfig {\r\n  executor: SQLExecutor;\r\n  dialect: SQLDialect;\r\n  tableName: string;\r\n  autoCreateTable?: boolean;\r\n}\r\n\r\n/**\r\n * SQL Storage implementation\r\n */\r\nexport class SQLStorage implements RealityStorage {\r\n  private executor: SQLExecutor;\r\n  private dialect: SQLDialect;\r\n  private tableName: string;\r\n  private initialized = false;\r\n\r\n  constructor(config: SQLStorageConfig) {\r\n    this.executor = config.executor;\r\n    this.dialect = config.dialect;\r\n    this.tableName = config.tableName;\r\n\r\n    if (config.autoCreateTable) {\r\n      this.ensureTable();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure the table exists\r\n   */\r\n  private async ensureTable(): Promise<void> {\r\n    if (this.initialized) return;\r\n\r\n    const sql = `\r\n      CREATE TABLE IF NOT EXISTS ${this.tableName} (\r\n        key VARCHAR(255) PRIMARY KEY,\r\n        version BIGINT NOT NULL,\r\n        hash VARCHAR(64) NOT NULL,\r\n        updated_at BIGINT NOT NULL\r\n      )\r\n    `;\r\n\r\n    await this.executor.execute(sql);\r\n    \r\n    // Create index on version for efficient listChangedSince queries\r\n    const indexSql = `\r\n      CREATE INDEX IF NOT EXISTS idx_${this.tableName}_version \r\n      ON ${this.tableName} (version)\r\n    `;\r\n    \r\n    try {\r\n      await this.executor.execute(indexSql);\r\n    } catch {\r\n      // Index creation may fail on some databases, that's okay\r\n    }\r\n\r\n    this.initialized = true;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `SELECT key, version, hash, updated_at FROM ${this.tableName} WHERE key = ${this.dialect.placeholder(1)}`;\r\n    const row = await this.executor.executeOne<{\r\n      key: string;\r\n      version: number;\r\n      hash: string;\r\n      updated_at: number;\r\n    }>(sql, [key]);\r\n\r\n    if (!row) return null;\r\n\r\n    return {\r\n      key: row.key,\r\n      version: Number(row.version),\r\n      hash: row.hash,\r\n      updatedAt: Number(row.updated_at),\r\n    };\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = this.dialect.upsert(\r\n      this.tableName,\r\n      ['key', 'version', 'hash', 'updated_at'],\r\n      'key'\r\n    );\r\n\r\n    await this.executor.execute(sql, [meta.key, meta.version, meta.hash, meta.updatedAt]);\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    await this.ensureTable();\r\n    \r\n    return this.executor.transaction(async (tx) => {\r\n      // Get current max version\r\n      const maxSql = `SELECT COALESCE(MAX(version), 0) as max_version FROM ${this.tableName}`;\r\n      const maxResult = await tx.executeOne<{ max_version: number }>(maxSql);\r\n      const newVersion = (maxResult?.max_version ?? 0) + 1;\r\n\r\n      const meta: RealityNodeMeta = {\r\n        key,\r\n        version: newVersion,\r\n        hash,\r\n        updatedAt: Date.now(),\r\n      };\r\n\r\n      const upsertSql = this.dialect.upsert(\r\n        this.tableName,\r\n        ['key', 'version', 'hash', 'updated_at'],\r\n        'key'\r\n      );\r\n\r\n      await tx.execute(upsertSql, [meta.key, meta.version, meta.hash, meta.updatedAt]);\r\n\r\n      return meta;\r\n    });\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `\r\n      SELECT key, version, hash, updated_at \r\n      FROM ${this.tableName} \r\n      WHERE version > ${this.dialect.placeholder(1)}\r\n      ORDER BY version ASC\r\n    `;\r\n\r\n    const rows = await this.executor.execute<{\r\n      key: string;\r\n      version: number;\r\n      hash: string;\r\n      updated_at: number;\r\n    }>(sql, [version]);\r\n\r\n    return rows.map((row) => ({\r\n      key: row.key,\r\n      version: Number(row.version),\r\n      hash: row.hash,\r\n      updatedAt: Number(row.updated_at),\r\n    }));\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    await this.ensureTable();\r\n    \r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    const placeholders = keys.map((_, i) => this.dialect.placeholder(i + 1)).join(', ');\r\n    const sql = `\r\n      SELECT key, version, hash, updated_at \r\n      FROM ${this.tableName} \r\n      WHERE key IN (${placeholders})\r\n    `;\r\n\r\n    const rows = await this.executor.execute<{\r\n      key: string;\r\n      version: number;\r\n      hash: string;\r\n      updated_at: number;\r\n    }>(sql, keys);\r\n\r\n    const result = new Map<string, RealityNodeMeta>();\r\n    for (const row of rows) {\r\n      result.set(row.key, {\r\n        key: row.key,\r\n        version: Number(row.version),\r\n        hash: row.hash,\r\n        updatedAt: Number(row.updated_at),\r\n      });\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `SELECT COALESCE(MAX(version), 0) as max_version FROM ${this.tableName}`;\r\n    const result = await this.executor.executeOne<{ max_version: number }>(sql);\r\n    return result?.max_version ?? 0;\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `DELETE FROM ${this.tableName} WHERE key = ${this.dialect.placeholder(1)}`;\r\n    await this.executor.execute(sql, [key]);\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      await this.executor.executeOne('SELECT 1');\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create SQL storage with a specific dialect\r\n */\r\nexport function createSQLStorage(config: SQLStorageConfig): SQLStorage {\r\n  return new SQLStorage(config);\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Drizzle Storage Adapter\r\n * \r\n * First-class Drizzle ORM integration for Reality storage.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * Drizzle table schema definition\r\n * \r\n * Users should define this in their Drizzle schema:\r\n * \r\n * ```typescript\r\n * import { pgTable, varchar, bigint, index } from 'drizzle-orm/pg-core';\r\n * \r\n * export const realityNodes = pgTable('reality_nodes', {\r\n *   key: varchar('key', { length: 255 }).primaryKey(),\r\n *   version: bigint('version', { mode: 'number' }).notNull(),\r\n *   hash: varchar('hash', { length: 64 }).notNull(),\r\n *   updatedAt: bigint('updated_at', { mode: 'number' }).notNull(),\r\n * }, (table) => ({\r\n *   versionIdx: index('version_idx').on(table.version),\r\n * }));\r\n * ```\r\n */\r\nexport interface DrizzleRealityTable {\r\n  key: unknown;\r\n  version: unknown;\r\n  hash: unknown;\r\n  updatedAt: unknown;\r\n}\r\n\r\n/**\r\n * Drizzle database interface\r\n */\r\nexport interface DrizzleDB {\r\n  select: <T>(fields?: T) => {\r\n    from: (table: unknown) => {\r\n      where: (condition: unknown) => Promise<T[]>;\r\n      orderBy: (column: unknown) => {\r\n        where: (condition: unknown) => Promise<T[]>;\r\n      };\r\n    };\r\n  };\r\n  insert: (table: unknown) => {\r\n    values: (values: unknown) => {\r\n      onConflictDoUpdate: (config: unknown) => Promise<void>;\r\n    };\r\n  };\r\n  delete: (table: unknown) => {\r\n    where: (condition: unknown) => Promise<void>;\r\n  };\r\n  transaction: <T>(fn: (tx: DrizzleDB) => Promise<T>) => Promise<T>;\r\n}\r\n\r\n/**\r\n * Drizzle Storage configuration\r\n */\r\nexport interface DrizzleStorageConfig {\r\n  /** Drizzle database instance */\r\n  db: DrizzleDB;\r\n  /** Drizzle table reference */\r\n  table: DrizzleRealityTable;\r\n  /** SQL operators from drizzle-orm */\r\n  operators: {\r\n    eq: (column: unknown, value: unknown) => unknown;\r\n    gt: (column: unknown, value: unknown) => unknown;\r\n    inArray: (column: unknown, values: unknown[]) => unknown;\r\n    max: (column: unknown) => unknown;\r\n    asc: (column: unknown) => unknown;\r\n  };\r\n}\r\n\r\n/**\r\n * Drizzle Storage implementation\r\n * \r\n * @example\r\n * ```typescript\r\n * import { drizzle } from 'drizzle-orm/node-postgres';\r\n * import { eq, gt, inArray, max, asc } from 'drizzle-orm';\r\n * import { realityNodes } from './schema';\r\n * \r\n * const db = drizzle(pool);\r\n * \r\n * const storage = createDrizzleStorage({\r\n *   db,\r\n *   table: realityNodes,\r\n *   operators: { eq, gt, inArray, max, asc },\r\n * });\r\n * ```\r\n */\r\nexport class DrizzleStorage implements RealityStorage {\r\n  private db: DrizzleDB;\r\n  private table: DrizzleRealityTable;\r\n  private ops: DrizzleStorageConfig['operators'];\r\n\r\n  constructor(config: DrizzleStorageConfig) {\r\n    this.db = config.db;\r\n    this.table = config.table;\r\n    this.ops = config.operators;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    const results = await this.db\r\n      .select()\r\n      .from(this.table)\r\n      .where(this.ops.eq(this.table.key, key)) as Array<{\r\n        key: string;\r\n        version: number;\r\n        hash: string;\r\n        updatedAt: number;\r\n      }>;\r\n\r\n    if (results.length === 0) return null;\r\n\r\n    const row = results[0]!;\r\n    return {\r\n      key: row.key,\r\n      version: row.version,\r\n      hash: row.hash,\r\n      updatedAt: row.updatedAt,\r\n    };\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    await this.db\r\n      .insert(this.table)\r\n      .values({\r\n        key: meta.key,\r\n        version: meta.version,\r\n        hash: meta.hash,\r\n        updatedAt: meta.updatedAt,\r\n      })\r\n      .onConflictDoUpdate({\r\n        target: this.table.key,\r\n        set: {\r\n          version: meta.version,\r\n          hash: meta.hash,\r\n          updatedAt: meta.updatedAt,\r\n        },\r\n      });\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    return this.db.transaction(async (tx) => {\r\n      // Get current max version\r\n      const maxResults = await tx\r\n        .select({ maxVersion: this.ops.max(this.table.version) })\r\n        .from(this.table) as unknown as Array<{ maxVersion: number | null }>;\r\n\r\n      const maxVersion = maxResults[0]?.maxVersion ?? 0;\r\n      const newVersion = maxVersion + 1;\r\n\r\n      const meta: RealityNodeMeta = {\r\n        key,\r\n        version: newVersion,\r\n        hash,\r\n        updatedAt: Date.now(),\r\n      };\r\n\r\n      await tx\r\n        .insert(this.table)\r\n        .values({\r\n          key: meta.key,\r\n          version: meta.version,\r\n          hash: meta.hash,\r\n          updatedAt: meta.updatedAt,\r\n        })\r\n        .onConflictDoUpdate({\r\n          target: this.table.key,\r\n          set: {\r\n            version: meta.version,\r\n            hash: meta.hash,\r\n            updatedAt: meta.updatedAt,\r\n          },\r\n        });\r\n\r\n      return meta;\r\n    });\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    const results = await this.db\r\n      .select()\r\n      .from(this.table)\r\n      .orderBy(this.ops.asc(this.table.version))\r\n      .where(this.ops.gt(this.table.version, version)) as Array<{\r\n        key: string;\r\n        version: number;\r\n        hash: string;\r\n        updatedAt: number;\r\n      }>;\r\n\r\n    return results.map((row) => ({\r\n      key: row.key,\r\n      version: row.version,\r\n      hash: row.hash,\r\n      updatedAt: row.updatedAt,\r\n    }));\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    const results = await this.db\r\n      .select()\r\n      .from(this.table)\r\n      .where(this.ops.inArray(this.table.key, keys)) as Array<{\r\n        key: string;\r\n        version: number;\r\n        hash: string;\r\n        updatedAt: number;\r\n      }>;\r\n\r\n    const map = new Map<string, RealityNodeMeta>();\r\n    for (const row of results) {\r\n      map.set(row.key, {\r\n        key: row.key,\r\n        version: row.version,\r\n        hash: row.hash,\r\n        updatedAt: row.updatedAt,\r\n      });\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    const results = await this.db\r\n      .select({ maxVersion: this.ops.max(this.table.version) })\r\n      .from(this.table) as unknown as Array<{ maxVersion: number | null }>;\r\n\r\n    return results[0]?.maxVersion ?? 0;\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    await this.db.delete(this.table).where(this.ops.eq(this.table.key, key));\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      await this.db.select().from(this.table).where(this.ops.eq(1, 0));\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create Drizzle storage adapter\r\n */\r\nexport function createDrizzleStorage(config: DrizzleStorageConfig): DrizzleStorage {\r\n  return new DrizzleStorage(config);\r\n}\r\n\r\n/**\r\n * Generate Drizzle schema for PostgreSQL\r\n * \r\n * Copy this to your schema file:\r\n */\r\nexport const DRIZZLE_POSTGRES_SCHEMA = `\r\nimport { pgTable, varchar, bigint, index } from 'drizzle-orm/pg-core';\r\n\r\nexport const realityNodes = pgTable('reality_nodes', {\r\n  key: varchar('key', { length: 255 }).primaryKey(),\r\n  version: bigint('version', { mode: 'number' }).notNull(),\r\n  hash: varchar('hash', { length: 64 }).notNull(),\r\n  updatedAt: bigint('updated_at', { mode: 'number' }).notNull(),\r\n}, (table) => ({\r\n  versionIdx: index('version_idx').on(table.version),\r\n}));\r\n`;\r\n\r\n/**\r\n * Generate Drizzle schema for MySQL\r\n */\r\nexport const DRIZZLE_MYSQL_SCHEMA = `\r\nimport { mysqlTable, varchar, bigint, index } from 'drizzle-orm/mysql-core';\r\n\r\nexport const realityNodes = mysqlTable('reality_nodes', {\r\n  key: varchar('key', { length: 255 }).primaryKey(),\r\n  version: bigint('version', { mode: 'number' }).notNull(),\r\n  hash: varchar('hash', { length: 64 }).notNull(),\r\n  updatedAt: bigint('updated_at', { mode: 'number' }).notNull(),\r\n}, (table) => ({\r\n  versionIdx: index('version_idx').on(table.version),\r\n}));\r\n`;\r\n\r\n/**\r\n * Generate Drizzle schema for SQLite\r\n */\r\nexport const DRIZZLE_SQLITE_SCHEMA = `\r\nimport { sqliteTable, text, integer, index } from 'drizzle-orm/sqlite-core';\r\n\r\nexport const realityNodes = sqliteTable('reality_nodes', {\r\n  key: text('key').primaryKey(),\r\n  version: integer('version').notNull(),\r\n  hash: text('hash').notNull(),\r\n  updatedAt: integer('updated_at').notNull(),\r\n}, (table) => ({\r\n  versionIdx: index('version_idx').on(table.version),\r\n}));\r\n`;\r\n","/**\r\n * @rootlodge/reality-server - Prisma Storage Adapter\r\n * \r\n * Prisma ORM integration for Reality storage.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * Prisma client interface (minimal subset)\r\n */\r\nexport interface PrismaClient {\r\n  realityNode: {\r\n    findUnique: (args: { where: { key: string } }) => Promise<PrismaRealityNode | null>;\r\n    findMany: (args: { where?: unknown; orderBy?: unknown }) => Promise<PrismaRealityNode[]>;\r\n    upsert: (args: {\r\n      where: { key: string };\r\n      create: PrismaRealityNodeInput;\r\n      update: PrismaRealityNodeInput;\r\n    }) => Promise<PrismaRealityNode>;\r\n    delete: (args: { where: { key: string } }) => Promise<void>;\r\n    aggregate: (args: { _max: { version: true } }) => Promise<{ _max: { version: number | null } }>;\r\n  };\r\n  $transaction: <T>(fn: (tx: PrismaClient) => Promise<T>) => Promise<T>;\r\n  $queryRaw: <T>(query: TemplateStringsArray, ...values: unknown[]) => Promise<T>;\r\n}\r\n\r\ninterface PrismaRealityNode {\r\n  key: string;\r\n  version: bigint | number;\r\n  hash: string;\r\n  updatedAt: bigint | number;\r\n}\r\n\r\ninterface PrismaRealityNodeInput {\r\n  key: string;\r\n  version: bigint | number;\r\n  hash: string;\r\n  updatedAt: bigint | number;\r\n}\r\n\r\n/**\r\n * Prisma Storage configuration\r\n */\r\nexport interface PrismaStorageConfig {\r\n  /** Prisma client instance */\r\n  prisma: PrismaClient;\r\n}\r\n\r\n/**\r\n * Prisma Storage implementation\r\n * \r\n * @example\r\n * ```typescript\r\n * import { PrismaClient } from '@prisma/client';\r\n * import { createPrismaStorage } from '@rootlodge/reality-server/storage';\r\n * \r\n * const prisma = new PrismaClient();\r\n * const storage = createPrismaStorage({ prisma });\r\n * ```\r\n * \r\n * Required Prisma schema:\r\n * ```prisma\r\n * model RealityNode {\r\n *   key       String   @id @db.VarChar(255)\r\n *   version   BigInt\r\n *   hash      String   @db.VarChar(64)\r\n *   updatedAt BigInt   @map(\"updated_at\")\r\n * \r\n *   @@index([version])\r\n *   @@map(\"reality_nodes\")\r\n * }\r\n * ```\r\n */\r\nexport class PrismaStorage implements RealityStorage {\r\n  private prisma: PrismaClient;\r\n\r\n  constructor(config: PrismaStorageConfig) {\r\n    this.prisma = config.prisma;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    const node = await this.prisma.realityNode.findUnique({\r\n      where: { key },\r\n    });\r\n\r\n    if (!node) return null;\r\n\r\n    return {\r\n      key: node.key,\r\n      version: Number(node.version),\r\n      hash: node.hash,\r\n      updatedAt: Number(node.updatedAt),\r\n    };\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    await this.prisma.realityNode.upsert({\r\n      where: { key: meta.key },\r\n      create: {\r\n        key: meta.key,\r\n        version: BigInt(meta.version),\r\n        hash: meta.hash,\r\n        updatedAt: BigInt(meta.updatedAt),\r\n      },\r\n      update: {\r\n        key: meta.key,\r\n        version: BigInt(meta.version),\r\n        hash: meta.hash,\r\n        updatedAt: BigInt(meta.updatedAt),\r\n      },\r\n    });\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    return this.prisma.$transaction(async (tx) => {\r\n      // Get current max version\r\n      const result = await tx.realityNode.aggregate({\r\n        _max: { version: true },\r\n      });\r\n\r\n      const maxVersion = result._max.version ?? BigInt(0);\r\n      const newVersion = Number(maxVersion) + 1;\r\n\r\n      const meta: RealityNodeMeta = {\r\n        key,\r\n        version: newVersion,\r\n        hash,\r\n        updatedAt: Date.now(),\r\n      };\r\n\r\n      await tx.realityNode.upsert({\r\n        where: { key },\r\n        create: {\r\n          key: meta.key,\r\n          version: BigInt(meta.version),\r\n          hash: meta.hash,\r\n          updatedAt: BigInt(meta.updatedAt),\r\n        },\r\n        update: {\r\n          key: meta.key,\r\n          version: BigInt(meta.version),\r\n          hash: meta.hash,\r\n          updatedAt: BigInt(meta.updatedAt),\r\n        },\r\n      });\r\n\r\n      return meta;\r\n    });\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    const nodes = await this.prisma.realityNode.findMany({\r\n      where: {\r\n        version: { gt: BigInt(version) },\r\n      },\r\n      orderBy: {\r\n        version: 'asc',\r\n      },\r\n    });\r\n\r\n    return nodes.map((node) => ({\r\n      key: node.key,\r\n      version: Number(node.version),\r\n      hash: node.hash,\r\n      updatedAt: Number(node.updatedAt),\r\n    }));\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    const nodes = await this.prisma.realityNode.findMany({\r\n      where: {\r\n        key: { in: keys },\r\n      },\r\n    });\r\n\r\n    const map = new Map<string, RealityNodeMeta>();\r\n    for (const node of nodes) {\r\n      map.set(node.key, {\r\n        key: node.key,\r\n        version: Number(node.version),\r\n        hash: node.hash,\r\n        updatedAt: Number(node.updatedAt),\r\n      });\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    const result = await this.prisma.realityNode.aggregate({\r\n      _max: { version: true },\r\n    });\r\n\r\n    return Number(result._max.version ?? 0);\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    try {\r\n      await this.prisma.realityNode.delete({\r\n        where: { key },\r\n      });\r\n    } catch {\r\n      // Ignore if not found\r\n    }\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      await this.prisma.$queryRaw`SELECT 1`;\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create Prisma storage adapter\r\n */\r\nexport function createPrismaStorage(config: PrismaStorageConfig): PrismaStorage {\r\n  return new PrismaStorage(config);\r\n}\r\n\r\n/**\r\n * Prisma schema for Reality nodes\r\n */\r\nexport const PRISMA_SCHEMA = `\r\nmodel RealityNode {\r\n  key       String   @id @db.VarChar(255)\r\n  version   BigInt\r\n  hash      String   @db.VarChar(64)\r\n  updatedAt BigInt   @map(\"updated_at\")\r\n\r\n  @@index([version])\r\n  @@map(\"reality_nodes\")\r\n}\r\n`;\r\n","/**\r\n * @rootlodge/reality-server - DynamoDB Storage Adapter\r\n * \r\n * AWS DynamoDB storage adapter for serverless deployments.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * DynamoDB client interface (minimal subset matching AWS SDK v3)\r\n */\r\nexport interface DynamoDBClient {\r\n  send: (command: unknown) => Promise<unknown>;\r\n}\r\n\r\n/**\r\n * DynamoDB document interface\r\n */\r\ninterface DynamoDBDocument {\r\n  key: { S: string };\r\n  version: { N: string };\r\n  hash: { S: string };\r\n  updatedAt: { N: string };\r\n}\r\n\r\n/**\r\n * DynamoDB Storage configuration\r\n */\r\nexport interface DynamoDBStorageConfig {\r\n  /** DynamoDB client instance */\r\n  client: DynamoDBClient;\r\n  /** Table name */\r\n  tableName: string;\r\n  /** Optional: GSI name for version queries */\r\n  versionIndexName?: string;\r\n}\r\n\r\n/**\r\n * DynamoDB Storage implementation\r\n * \r\n * Required table structure:\r\n * - Partition Key: key (String)\r\n * - GSI on version (Number) for efficient listChangedSince queries\r\n * \r\n * @example\r\n * ```typescript\r\n * import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\r\n * import { createDynamoDBStorage } from '@rootlodge/reality-server/storage';\r\n * \r\n * const client = new DynamoDBClient({ region: 'us-east-1' });\r\n * const storage = createDynamoDBStorage({\r\n *   client,\r\n *   tableName: 'reality-nodes',\r\n *   versionIndexName: 'version-index',\r\n * });\r\n * ```\r\n */\r\nexport class DynamoDBStorage implements RealityStorage {\r\n  private client: DynamoDBClient;\r\n  private tableName: string;\r\n  private versionIndexName?: string;\r\n\r\n  constructor(config: DynamoDBStorageConfig) {\r\n    this.client = config.client;\r\n    this.tableName = config.tableName;\r\n    this.versionIndexName = config.versionIndexName;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Key: {\r\n        key: { S: key },\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createGetItemCommand(command)) as {\r\n      Item?: DynamoDBDocument;\r\n    };\r\n\r\n    if (!result.Item) return null;\r\n\r\n    return this.documentToMeta(result.Item);\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Item: this.metaToDocument(meta),\r\n    };\r\n\r\n    await this.client.send(this.createPutItemCommand(command));\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    // Get current max version\r\n    const maxVersion = await this.getMaxVersion();\r\n    const newVersion = maxVersion + 1;\r\n\r\n    const meta: RealityNodeMeta = {\r\n      key,\r\n      version: newVersion,\r\n      hash,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    // Use conditional write to ensure atomicity\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Item: this.metaToDocument(meta),\r\n      ConditionExpression: 'attribute_not_exists(#key) OR #version < :newVersion',\r\n      ExpressionAttributeNames: {\r\n        '#key': 'key',\r\n        '#version': 'version',\r\n      },\r\n      ExpressionAttributeValues: {\r\n        ':newVersion': { N: String(newVersion) },\r\n      },\r\n    };\r\n\r\n    try {\r\n      await this.client.send(this.createPutItemCommand(command));\r\n      return meta;\r\n    } catch (error) {\r\n      // Retry with incremented version if conditional check failed\r\n      if ((error as { name?: string }).name === 'ConditionalCheckFailedException') {\r\n        return this.incrementVersion(key, hash);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    if (this.versionIndexName) {\r\n      // Use GSI for efficient query\r\n      const command = {\r\n        TableName: this.tableName,\r\n        IndexName: this.versionIndexName,\r\n        KeyConditionExpression: '#version > :version',\r\n        ExpressionAttributeNames: {\r\n          '#version': 'version',\r\n        },\r\n        ExpressionAttributeValues: {\r\n          ':version': { N: String(version) },\r\n        },\r\n      };\r\n\r\n      const result = await this.client.send(this.createQueryCommand(command)) as {\r\n        Items?: DynamoDBDocument[];\r\n      };\r\n\r\n      return (result.Items ?? [])\r\n        .map((item) => this.documentToMeta(item))\r\n        .sort((a, b) => a.version - b.version);\r\n    }\r\n\r\n    // Fallback: scan the entire table (not recommended for large tables)\r\n    const command = {\r\n      TableName: this.tableName,\r\n      FilterExpression: '#version > :version',\r\n      ExpressionAttributeNames: {\r\n        '#version': 'version',\r\n      },\r\n      ExpressionAttributeValues: {\r\n        ':version': { N: String(version) },\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createScanCommand(command)) as {\r\n      Items?: DynamoDBDocument[];\r\n    };\r\n\r\n    return (result.Items ?? [])\r\n      .map((item) => this.documentToMeta(item))\r\n      .sort((a, b) => a.version - b.version);\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    // BatchGetItem for efficiency\r\n    const command = {\r\n      RequestItems: {\r\n        [this.tableName]: {\r\n          Keys: keys.map((key) => ({ key: { S: key } })),\r\n        },\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createBatchGetItemCommand(command)) as {\r\n      Responses?: { [tableName: string]: DynamoDBDocument[] };\r\n    };\r\n\r\n    const items = result.Responses?.[this.tableName] ?? [];\r\n    const map = new Map<string, RealityNodeMeta>();\r\n\r\n    for (const item of items) {\r\n      const meta = this.documentToMeta(item);\r\n      map.set(meta.key, meta);\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    // Scan to find max version (consider using a separate counter item for production)\r\n    const command = {\r\n      TableName: this.tableName,\r\n      ProjectionExpression: '#version',\r\n      ExpressionAttributeNames: {\r\n        '#version': 'version',\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createScanCommand(command)) as {\r\n      Items?: Array<{ version: { N: string } }>;\r\n    };\r\n\r\n    const items = result.Items ?? [];\r\n    if (items.length === 0) return 0;\r\n\r\n    return Math.max(...items.map((item) => parseInt(item.version.N, 10)));\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Key: {\r\n        key: { S: key },\r\n      },\r\n    };\r\n\r\n    await this.client.send(this.createDeleteItemCommand(command));\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      const command = {\r\n        TableName: this.tableName,\r\n        Limit: 1,\r\n      };\r\n      await this.client.send(this.createScanCommand(command));\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private documentToMeta(doc: DynamoDBDocument): RealityNodeMeta {\r\n    return {\r\n      key: doc.key.S,\r\n      version: parseInt(doc.version.N, 10),\r\n      hash: doc.hash.S,\r\n      updatedAt: parseInt(doc.updatedAt.N, 10),\r\n    };\r\n  }\r\n\r\n  private metaToDocument(meta: RealityNodeMeta): DynamoDBDocument {\r\n    return {\r\n      key: { S: meta.key },\r\n      version: { N: String(meta.version) },\r\n      hash: { S: meta.hash },\r\n      updatedAt: { N: String(meta.updatedAt) },\r\n    };\r\n  }\r\n\r\n  // Command factory methods (to be replaced with actual AWS SDK commands)\r\n  private createGetItemCommand(input: unknown): { __type: 'GetItem'; input: unknown } {\r\n    return { __type: 'GetItem', input };\r\n  }\r\n\r\n  private createPutItemCommand(input: unknown): { __type: 'PutItem'; input: unknown } {\r\n    return { __type: 'PutItem', input };\r\n  }\r\n\r\n  private createDeleteItemCommand(input: unknown): { __type: 'DeleteItem'; input: unknown } {\r\n    return { __type: 'DeleteItem', input };\r\n  }\r\n\r\n  private createQueryCommand(input: unknown): { __type: 'Query'; input: unknown } {\r\n    return { __type: 'Query', input };\r\n  }\r\n\r\n  private createScanCommand(input: unknown): { __type: 'Scan'; input: unknown } {\r\n    return { __type: 'Scan', input };\r\n  }\r\n\r\n  private createBatchGetItemCommand(input: unknown): { __type: 'BatchGetItem'; input: unknown } {\r\n    return { __type: 'BatchGetItem', input };\r\n  }\r\n}\r\n\r\n/**\r\n * Create DynamoDB storage adapter\r\n */\r\nexport function createDynamoDBStorage(config: DynamoDBStorageConfig): DynamoDBStorage {\r\n  return new DynamoDBStorage(config);\r\n}\r\n\r\n/**\r\n * CloudFormation template for DynamoDB table\r\n */\r\nexport const DYNAMODB_CLOUDFORMATION = `\r\nAWSTemplateFormatVersion: '2010-09-09'\r\nDescription: Reality DynamoDB Table\r\n\r\nResources:\r\n  RealityNodesTable:\r\n    Type: AWS::DynamoDB::Table\r\n    Properties:\r\n      TableName: reality-nodes\r\n      BillingMode: PAY_PER_REQUEST\r\n      AttributeDefinitions:\r\n        - AttributeName: key\r\n          AttributeType: S\r\n        - AttributeName: version\r\n          AttributeType: N\r\n      KeySchema:\r\n        - AttributeName: key\r\n          KeyType: HASH\r\n      GlobalSecondaryIndexes:\r\n        - IndexName: version-index\r\n          KeySchema:\r\n            - AttributeName: version\r\n              KeyType: HASH\r\n          Projection:\r\n            ProjectionType: ALL\r\n`;\r\n"]}