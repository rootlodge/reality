{"version":3,"sources":["../../src/compat/sse.ts","../../src/compat/polling.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\r\n * @rootlodge/reality-server - Server SSE Compatibility\r\n * \r\n * Server-side compatibility for SSE migration.\r\n * Translates Reality updates into SSE-formatted responses.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../types';\r\nimport { MeshCoordinator } from '../mesh/coordinator';\r\n\r\n/**\r\n * SSE Compatibility adapter configuration\r\n */\r\nexport interface SSECompatConfig {\r\n  /** Storage adapter */\r\n  storage: RealityStorage;\r\n  /** Mesh coordinator */\r\n  mesh: MeshCoordinator;\r\n  /** Transform node data for SSE event */\r\n  transform?: (key: string, data: unknown) => string;\r\n  /** Optional: Fetch payload for a key */\r\n  payloadFetcher?: (key: string) => Promise<unknown>;\r\n}\r\n\r\n/**\r\n * SSE message format\r\n */\r\ninterface SSEMessage {\r\n  id: string;\r\n  event?: string;\r\n  data: string;\r\n  retry?: number;\r\n}\r\n\r\n/**\r\n * Format SSE message\r\n */\r\nfunction formatSSEMessage(message: SSEMessage): string {\r\n  let result = '';\r\n  \r\n  if (message.id) {\r\n    result += `id: ${message.id}\\n`;\r\n  }\r\n  if (message.event) {\r\n    result += `event: ${message.event}\\n`;\r\n  }\r\n  if (message.retry !== undefined) {\r\n    result += `retry: ${message.retry}\\n`;\r\n  }\r\n  \r\n  // Data can be multiline\r\n  const dataLines = message.data.split('\\n');\r\n  for (const line of dataLines) {\r\n    result += `data: ${line}\\n`;\r\n  }\r\n  \r\n  result += '\\n';\r\n  return result;\r\n}\r\n\r\n/**\r\n * SSE Compatibility Adapter\r\n * \r\n * This adapter helps migrate SSE endpoints to Reality by:\r\n * 1. Accepting SSE-style requests\r\n * 2. Converting Reality node updates to SSE event format\r\n * 3. Returning short-lived HTTP responses (NOT streaming)\r\n * \r\n * IMPORTANT: This does NOT create long-lived SSE connections.\r\n * It returns data in SSE format for clients to process identically.\r\n */\r\nexport class SSECompatAdapter {\r\n  private config: SSECompatConfig;\r\n\r\n  constructor(config: SSECompatConfig) {\r\n    this.config = {\r\n      transform: (_key, data) => JSON.stringify(data),\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle an SSE-style request\r\n   * \r\n   * Returns data in SSE format but via a normal HTTP response.\r\n   * Client's EventSource polyfill will need to poll this endpoint.\r\n   * \r\n   * @param lastEventId - The Last-Event-ID from the client\r\n   * @param keys - Keys to check for updates (derived from URL path)\r\n   * @returns SSE-formatted response body\r\n   */\r\n  async handleRequest(\r\n    lastEventId: string | null,\r\n    keys: string[]\r\n  ): Promise<{\r\n    body: string;\r\n    headers: Record<string, string>;\r\n    hasChanges: boolean;\r\n  }> {\r\n    // Parse last event ID to get version\r\n    const lastVersion = this.parseEventId(lastEventId);\r\n\r\n    // Get nodes that have changed\r\n    const changedNodes = await this.config.storage.listChangedSince(lastVersion);\r\n\r\n    // Filter to only requested keys\r\n    const relevantChanges = changedNodes.filter((node) =>\r\n      keys.length === 0 || keys.includes(node.key)\r\n    );\r\n\r\n    // Build SSE response\r\n    let body = '';\r\n    let maxVersion = lastVersion;\r\n\r\n    for (const node of relevantChanges) {\r\n      // Fetch payload if available\r\n      let payload: unknown = null;\r\n      if (this.config.payloadFetcher) {\r\n        try {\r\n          payload = await this.config.payloadFetcher(node.key);\r\n        } catch {\r\n          // Skip if payload fetch fails\r\n          continue;\r\n        }\r\n      }\r\n\r\n      const message: SSEMessage = {\r\n        id: this.createEventId(node),\r\n        event: 'update',\r\n        data: this.config.transform!(node.key, payload ?? { key: node.key, version: node.version }),\r\n      };\r\n\r\n      body += formatSSEMessage(message);\r\n      maxVersion = Math.max(maxVersion, node.version);\r\n    }\r\n\r\n    // Add a heartbeat message if no changes\r\n    if (body === '') {\r\n      const heartbeat: SSEMessage = {\r\n        id: `heartbeat:${Date.now()}`,\r\n        event: 'heartbeat',\r\n        data: JSON.stringify({ timestamp: Date.now() }),\r\n      };\r\n      body = formatSSEMessage(heartbeat);\r\n    }\r\n\r\n    return {\r\n      body,\r\n      headers: {\r\n        'Content-Type': 'text/event-stream',\r\n        'Cache-Control': 'no-cache',\r\n        'X-Accel-Buffering': 'no',\r\n        'X-Reality-Version': String(maxVersion),\r\n      },\r\n      hasChanges: relevantChanges.length > 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a Fetch API handler for SSE-compatible endpoint\r\n   */\r\n  createFetchHandler(\r\n    getKeysFromRequest: (request: Request) => string[]\r\n  ): (request: Request) => Promise<Response> {\r\n    return async (request: Request): Promise<Response> => {\r\n      const lastEventId = request.headers.get('Last-Event-ID');\r\n      const keys = getKeysFromRequest(request);\r\n\r\n      const result = await this.handleRequest(lastEventId, keys);\r\n\r\n      return new Response(result.body, {\r\n        status: 200,\r\n        headers: result.headers,\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse event ID to extract version\r\n   */\r\n  private parseEventId(eventId: string | null): number {\r\n    if (!eventId) return 0;\r\n    \r\n    // Format: \"version:hash\" or just version number\r\n    const parts = eventId.split(':');\r\n    const version = parseInt(parts[0] ?? '0', 10);\r\n    return isNaN(version) ? 0 : version;\r\n  }\r\n\r\n  /**\r\n   * Create event ID from node metadata\r\n   */\r\n  private createEventId(node: RealityNodeMeta): string {\r\n    return `${node.version}:${node.hash}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Create SSE compatibility adapter\r\n */\r\nexport function createSSECompatAdapter(config: SSECompatConfig): SSECompatAdapter {\r\n  return new SSECompatAdapter(config);\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Server Polling Compatibility\r\n * \r\n * Server-side compatibility for polling migration.\r\n * Returns data in the same format as traditional polling endpoints.\r\n */\r\n\r\nimport type { RealityStorage } from '../types';\r\nimport { MeshCoordinator } from '../mesh/coordinator';\r\n\r\n/**\r\n * Polling compatibility adapter configuration\r\n */\r\nexport interface PollingCompatConfig {\r\n  /** Storage adapter */\r\n  storage: RealityStorage;\r\n  /** Mesh coordinator */\r\n  mesh: MeshCoordinator;\r\n  /** Optional: Fetch payload for a key */\r\n  payloadFetcher?: (key: string) => Promise<unknown>;\r\n  /** Optional: Transform response format */\r\n  transform?: (data: Map<string, unknown>) => unknown;\r\n}\r\n\r\n/**\r\n * Polling Compatibility Adapter\r\n * \r\n * This adapter helps migrate polling endpoints to Reality by:\r\n * 1. Accepting requests in the same format as existing polling endpoints\r\n * 2. Returning data in the same format\r\n * 3. Adding Reality versioning for efficient future syncs\r\n */\r\nexport class PollingCompatAdapter {\r\n  private config: PollingCompatConfig;\r\n\r\n  constructor(config: PollingCompatConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Handle a polling-style request\r\n   * \r\n   * @param keys - Keys to fetch\r\n   * @param ifModifiedSince - Optional version for conditional request\r\n   * @returns Response data and metadata\r\n   */\r\n  async handleRequest(\r\n    keys: string[],\r\n    ifModifiedSince?: number\r\n  ): Promise<{\r\n    data: unknown;\r\n    headers: Record<string, string>;\r\n    status: number;\r\n    modified: boolean;\r\n  }> {\r\n    // Get current metadata for all keys\r\n    const metas = await this.config.storage.getNodes(keys);\r\n\r\n    // Check if any have changed since ifModifiedSince\r\n    let maxVersion = 0;\r\n    let hasChanges = false;\r\n\r\n    for (const meta of metas.values()) {\r\n      maxVersion = Math.max(maxVersion, meta.version);\r\n      if (ifModifiedSince === undefined || meta.version > ifModifiedSince) {\r\n        hasChanges = true;\r\n      }\r\n    }\r\n\r\n    // If nothing changed, return 304\r\n    if (ifModifiedSince !== undefined && !hasChanges) {\r\n      return {\r\n        data: null,\r\n        headers: {\r\n          'X-Reality-Version': String(maxVersion),\r\n        },\r\n        status: 304,\r\n        modified: false,\r\n      };\r\n    }\r\n\r\n    // Fetch payloads\r\n    const payloads = new Map<string, unknown>();\r\n\r\n    for (const key of keys) {\r\n      if (this.config.payloadFetcher) {\r\n        try {\r\n          const payload = await this.config.payloadFetcher(key);\r\n          payloads.set(key, payload);\r\n        } catch {\r\n          // Skip failed fetches\r\n        }\r\n      }\r\n    }\r\n\r\n    // Transform response\r\n    const data = this.config.transform\r\n      ? this.config.transform(payloads)\r\n      : Object.fromEntries(payloads);\r\n\r\n    return {\r\n      data,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Reality-Version': String(maxVersion),\r\n        'Cache-Control': 'no-cache',\r\n      },\r\n      status: 200,\r\n      modified: true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a Fetch API handler for polling-compatible endpoint\r\n   */\r\n  createFetchHandler(\r\n    getKeysFromRequest: (request: Request) => string[]\r\n  ): (request: Request) => Promise<Response> {\r\n    return async (request: Request): Promise<Response> => {\r\n      const ifModifiedSince = request.headers.get('X-Reality-Version');\r\n      const version = ifModifiedSince ? parseInt(ifModifiedSince, 10) : undefined;\r\n      const keys = getKeysFromRequest(request);\r\n\r\n      const result = await this.handleRequest(keys, version);\r\n\r\n      if (result.status === 304) {\r\n        return new Response(null, {\r\n          status: 304,\r\n          headers: result.headers,\r\n        });\r\n      }\r\n\r\n      return new Response(JSON.stringify(result.data), {\r\n        status: result.status,\r\n        headers: result.headers,\r\n      });\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create polling compatibility adapter\r\n */\r\nexport function createPollingCompatAdapter(config: PollingCompatConfig): PollingCompatAdapter {\r\n  return new PollingCompatAdapter(config);\r\n}\r\n"]}