{"version":3,"sources":["../src/types/index.ts","../src/storage/memory.ts","../src/mesh/coordinator.ts","../src/http/handlers.ts","../src/http/fetch.ts","../src/server.ts","../src/embedded.ts","../src/storage/sql/sql-storage.ts","../src/storage/drizzle/drizzle-storage.ts","../src/storage/prisma/prisma-storage.ts","../src/storage/nosql/dynamodb-storage.ts","../src/invalidation/adapters.ts","../src/redis/accelerator.ts","../src/http/express.ts","../src/compat/sse.ts","../src/compat/polling.ts"],"names":["z","command","result","toRealityRequest"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * @rootlodge/reality-server - Server Types\r\n * \r\n * Type definitions for the Reality server.\r\n * Shared types are duplicated here to avoid circular dependencies.\r\n */\r\n\r\nimport { z } from 'zod';\r\n\r\n// ============================================================================\r\n// Shared Types (duplicated from @rootlodge/reality for independence)\r\n// ============================================================================\r\n\r\nexport const RealityModeSchema = z.enum(['native', 'sse-compat', 'polling-compat']);\r\nexport type RealityMode = z.infer<typeof RealityModeSchema>;\r\n\r\nexport const SyncHintSchema = z.enum(['interaction', 'focus', 'idle', 'mutation', 'mount', 'reconnect']);\r\nexport type SyncHint = z.infer<typeof SyncHintSchema>;\r\n\r\nexport const RealityNodeMetaSchema = z.object({\r\n  key: z.string(),\r\n  version: z.number().int().nonnegative(),\r\n  hash: z.string(),\r\n  updatedAt: z.number().int(),\r\n});\r\n\r\nexport type RealityNodeMeta = z.infer<typeof RealityNodeMetaSchema>;\r\n\r\nexport const PeerHealthSchema = z.enum(['healthy', 'degraded', 'unhealthy', 'unknown']);\r\nexport type PeerHealth = z.infer<typeof PeerHealthSchema>;\r\n\r\nexport const PeerSummarySchema = z.object({\r\n  peer: z.string().url(),\r\n  maxVersionSeen: z.number().int().nonnegative(),\r\n  lastSeen: z.number().int(),\r\n  health: PeerHealthSchema.optional(),\r\n});\r\n\r\nexport type PeerSummary = z.infer<typeof PeerSummarySchema>;\r\n\r\nexport const SyncRequestSchema = z.object({\r\n  known: z.record(z.string(), z.number().int().nonnegative()),\r\n  clientId: z.string().uuid(),\r\n  mode: RealityModeSchema,\r\n  hint: SyncHintSchema,\r\n  timestamp: z.number().int().optional(),\r\n});\r\n\r\nexport type SyncRequest = z.infer<typeof SyncRequestSchema>;\r\n\r\nexport const ChangedNodeSchema = z.object({\r\n  version: z.number().int().nonnegative(),\r\n  hash: z.string(),\r\n  source: z.string().optional(),\r\n  payload: z.unknown().optional(),\r\n});\r\n\r\nexport type ChangedNode = z.infer<typeof ChangedNodeSchema>;\r\n\r\nexport const MeshInfoSchema = z.object({\r\n  peers: z.record(z.string(), PeerHealthSchema),\r\n  serverVersion: z.number().int().nonnegative().optional(),\r\n});\r\n\r\nexport type MeshInfo = z.infer<typeof MeshInfoSchema>;\r\n\r\nexport const SyncResponseSchema = z.object({\r\n  changed: z.record(z.string(), ChangedNodeSchema),\r\n  mesh: MeshInfoSchema,\r\n  serverTime: z.number().int(),\r\n});\r\n\r\nexport type SyncResponse = z.infer<typeof SyncResponseSchema>;\r\n\r\n// ============================================================================\r\n// Execution & Persistence Modes\r\n// ============================================================================\r\n\r\n/**\r\n * Persistence mode for Reality\r\n * - 'none': No database required, in-memory only\r\n * - 'advisory': Optional DB adapters for invalidation hints\r\n * - 'external': Application manages its own persistence\r\n */\r\nexport const RealityPersistenceModeSchema = z.enum(['none', 'advisory', 'external']);\r\nexport type RealityPersistenceMode = z.infer<typeof RealityPersistenceModeSchema>;\r\n\r\n/**\r\n * Execution mode for Reality\r\n * - 'client': Browser/client-side, HTTP to external servers\r\n * - 'ssr-embedded': SSR with in-process server (TanStack/Vite)\r\n * - 'server-external': Dedicated server mode\r\n * - 'auto': Automatically detect based on environment\r\n */\r\nexport const RealityExecutionModeSchema = z.enum(['client', 'ssr-embedded', 'server-external', 'auto']);\r\nexport type RealityExecutionMode = z.infer<typeof RealityExecutionModeSchema>;\r\n\r\n// ============================================================================\r\n// Invalidation Adapter Interface\r\n// ============================================================================\r\n\r\n/**\r\n * Invalidation adapter for advisory database integration\r\n * Reality does NOT own your data - this is optional!\r\n */\r\nexport interface RealityInvalidationAdapter {\r\n  /** Hook called when keys should be invalidated */\r\n  onInvalidate(keys: string[]): Promise<void>;\r\n  /** Hook called before a transaction (for auto-invalidation) */\r\n  beforeTransaction?<T>(fn: () => Promise<T>): Promise<T>;\r\n  /** Hook called after a transaction (for auto-invalidation) */\r\n  afterTransaction?(affectedKeys: string[]): Promise<void>;\r\n}\r\n\r\n/**\r\n * Configuration for invalidation behavior\r\n */\r\nexport interface InvalidationConfig {\r\n  /** Invalidation adapter instance */\r\n  adapter?: RealityInvalidationAdapter;\r\n  /** Persistence mode */\r\n  mode?: RealityPersistenceMode;\r\n}\r\n\r\n// ============================================================================\r\n// Storage Interface (optional - Reality works without it)\r\n// ============================================================================\r\n\r\nexport interface RealityStorage {\r\n  /** Get metadata for a node */\r\n  getNode(key: string): Promise<RealityNodeMeta | null>;\r\n  /** Set metadata for a node */\r\n  setNode(meta: RealityNodeMeta): Promise<void>;\r\n  /** Increment version and update hash */\r\n  incrementVersion(key: string, hash: string): Promise<RealityNodeMeta>;\r\n  /** List nodes changed since a given version */\r\n  listChangedSince(version: number): Promise<RealityNodeMeta[]>;\r\n  /** Get multiple nodes by keys */\r\n  getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>>;\r\n  /** Get current max version across all nodes */\r\n  getMaxVersion(): Promise<number>;\r\n  /** Delete a node */\r\n  deleteNode(key: string): Promise<void>;\r\n  /** Health check */\r\n  isHealthy(): Promise<boolean>;\r\n}\r\n\r\n// ============================================================================\r\n// Database Adapter Interface\r\n// ============================================================================\r\n\r\nexport interface DatabaseAdapter {\r\n  /** Fetch payload for a key */\r\n  fetchPayload<T = unknown>(key: string): Promise<T | null>;\r\n  /** Store payload for a key */\r\n  storePayload<T = unknown>(key: string, payload: T): Promise<void>;\r\n  /** Delete payload */\r\n  deletePayload(key: string): Promise<void>;\r\n  /** Batch fetch payloads */\r\n  fetchPayloads<T = unknown>(keys: string[]): Promise<Map<string, T>>;\r\n}\r\n\r\n// ============================================================================\r\n// Server Configuration\r\n// ============================================================================\r\n\r\nexport const ServerConfigSchema = z.object({\r\n  /** Server identifier (unique across mesh) */\r\n  serverId: z.string().min(1),\r\n  /** HTTP port to listen on */\r\n  port: z.number().int().positive().default(3000),\r\n  /** Host to bind to */\r\n  host: z.string().default('0.0.0.0'),\r\n  /** Peer server URLs for mesh */\r\n  peers: z.array(z.string().url()).default([]),\r\n  /** CORS configuration */\r\n  cors: z.object({\r\n    origins: z.array(z.string()).default(['*']),\r\n    credentials: z.boolean().default(true),\r\n  }).default({}),\r\n  /** Rate limiting */\r\n  rateLimit: z.object({\r\n    enabled: z.boolean().default(false),\r\n    maxRequests: z.number().int().positive().default(100),\r\n    windowMs: z.number().int().positive().default(60000),\r\n  }).default({}),\r\n  /** Enable debug logging */\r\n  debug: z.boolean().default(false),\r\n  /** Storage configuration */\r\n  storage: z.object({\r\n    type: z.enum(['memory', 'drizzle', 'prisma', 'sql', 'dynamodb', 'redis', 'custom']).default('memory'),\r\n    connectionString: z.string().optional(),\r\n    tableName: z.string().default('reality_nodes'),\r\n  }).default({}),\r\n  /** Redis configuration (optional acceleration) */\r\n  redis: z.object({\r\n    enabled: z.boolean().default(false),\r\n    url: z.string().optional(),\r\n    prefix: z.string().default('reality:'),\r\n  }).default({}),\r\n  /** Payload fetcher base URL */\r\n  payloadBaseUrl: z.string().url().optional(),\r\n  /** Execution mode */\r\n  executionMode: RealityExecutionModeSchema.default('server-external'),\r\n  /** Invalidation configuration (optional) */\r\n  invalidation: z.object({\r\n    mode: RealityPersistenceModeSchema.default('none'),\r\n  }).default({}),\r\n});\r\n\r\nexport type ServerConfig = z.input<typeof ServerConfigSchema>;\r\nexport type ResolvedServerConfig = z.output<typeof ServerConfigSchema>;\r\n\r\n// ============================================================================\r\n// Mesh Types\r\n// ============================================================================\r\n\r\nexport interface PeerInfo {\r\n  url: string;\r\n  serverId: string;\r\n  health: PeerHealth;\r\n  maxVersionSeen: number;\r\n  lastSeen: number;\r\n  lastLatency: number;\r\n}\r\n\r\nexport interface MeshState {\r\n  serverId: string;\r\n  maxVersionSeen: number;\r\n  peers: Map<string, PeerInfo>;\r\n  lastGossipTime: number;\r\n}\r\n\r\nexport interface GossipPayload {\r\n  serverId: string;\r\n  maxVersion: number;\r\n  peerSummaries: Array<{\r\n    url: string;\r\n    health: PeerHealth;\r\n    maxVersion: number;\r\n    lastSeen: number;\r\n  }>;\r\n  timestamp: number;\r\n}\r\n\r\nexport const GossipPayloadSchema = z.object({\r\n  serverId: z.string(),\r\n  maxVersion: z.number().int().nonnegative(),\r\n  peerSummaries: z.array(z.object({\r\n    url: z.string().url(),\r\n    health: z.enum(['healthy', 'degraded', 'unhealthy', 'unknown']),\r\n    maxVersion: z.number().int().nonnegative(),\r\n    lastSeen: z.number().int(),\r\n  })),\r\n  timestamp: z.number().int(),\r\n});\r\n\r\n// ============================================================================\r\n// Request/Response Types\r\n// ============================================================================\r\n\r\nexport interface InvalidationRequest {\r\n  keys: string[];\r\n  source?: string;\r\n  timestamp?: number;\r\n}\r\n\r\nexport const InvalidationRequestSchema = z.object({\r\n  keys: z.array(z.string()).min(1),\r\n  source: z.string().optional(),\r\n  timestamp: z.number().int().optional(),\r\n});\r\n\r\nexport interface InvalidationResponse {\r\n  invalidated: string[];\r\n  versions: Record<string, number>;\r\n}\r\n\r\nexport interface HealthResponse {\r\n  status: 'healthy' | 'degraded' | 'unhealthy';\r\n  serverId: string;\r\n  version: string;\r\n  uptime: number;\r\n  mesh: {\r\n    peerCount: number;\r\n    healthyPeers: number;\r\n  };\r\n  storage: {\r\n    healthy: boolean;\r\n    maxVersion: number;\r\n  };\r\n  redis?: {\r\n    connected: boolean;\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// HTTP Handler Types\r\n// ============================================================================\r\n\r\nexport interface RealityRequest {\r\n  method: string;\r\n  url: string;\r\n  headers: Headers;\r\n  body: unknown;\r\n  params: Record<string, string>;\r\n  query: Record<string, string>;\r\n}\r\n\r\nexport interface RealityResponse {\r\n  status: number;\r\n  headers: Record<string, string>;\r\n  body: unknown;\r\n}\r\n\r\nexport type RealityHandler = (req: RealityRequest) => Promise<RealityResponse>;\r\n\r\n// ============================================================================\r\n// Middleware Types\r\n// ============================================================================\r\n\r\nexport type Middleware = (\r\n  req: RealityRequest,\r\n  next: () => Promise<RealityResponse>\r\n) => Promise<RealityResponse>;\r\n\r\n// ============================================================================\r\n// Storage Factory Types\r\n// ============================================================================\r\n\r\nexport interface StorageFactory {\r\n  create(config: ResolvedServerConfig): Promise<RealityStorage>;\r\n}\r\n\r\n// ============================================================================\r\n// Database Adapter Factory Types\r\n// ============================================================================\r\n\r\nexport interface DatabaseAdapterFactory {\r\n  create(config: ResolvedServerConfig): Promise<DatabaseAdapter>;\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Memory Storage\r\n * \r\n * In-memory storage adapter for development and testing.\r\n * Not recommended for production use with multiple servers.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../types';\r\n\r\n/**\r\n * In-memory storage implementation\r\n */\r\nexport class MemoryStorage implements RealityStorage {\r\n  private nodes: Map<string, RealityNodeMeta> = new Map();\r\n  private maxVersion = 0;\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    return this.nodes.get(key) ?? null;\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    this.nodes.set(meta.key, meta);\r\n    this.maxVersion = Math.max(this.maxVersion, meta.version);\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    const version = this.maxVersion + 1;\r\n    \r\n    const meta: RealityNodeMeta = {\r\n      key,\r\n      version,\r\n      hash,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    this.nodes.set(key, meta);\r\n    this.maxVersion = version;\r\n    \r\n    return meta;\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    const result: RealityNodeMeta[] = [];\r\n    \r\n    for (const meta of this.nodes.values()) {\r\n      if (meta.version > version) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n\r\n    return result.sort((a, b) => a.version - b.version);\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    const result = new Map<string, RealityNodeMeta>();\r\n    \r\n    for (const key of keys) {\r\n      const meta = this.nodes.get(key);\r\n      if (meta) {\r\n        result.set(key, meta);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    return this.maxVersion;\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    this.nodes.delete(key);\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Clear all data (useful for testing)\r\n   */\r\n  clear(): void {\r\n    this.nodes.clear();\r\n    this.maxVersion = 0;\r\n  }\r\n\r\n  /**\r\n   * Get all nodes (for debugging)\r\n   */\r\n  getAllNodes(): Map<string, RealityNodeMeta> {\r\n    return new Map(this.nodes);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a memory storage instance\r\n */\r\nexport function createMemoryStorage(): MemoryStorage {\r\n  return new MemoryStorage();\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Mesh Coordinator\r\n * \r\n * Manages peer awareness and gossip protocol for server mesh.\r\n * Servers are stateless but mesh-aware.\r\n */\r\n\r\nimport type { PeerInfo, MeshState, GossipPayload, PeerHealth } from '../types';\r\nimport { GossipPayloadSchema } from '../types';\r\n\r\n/**\r\n * Mesh coordinator configuration\r\n */\r\nexport interface MeshConfig {\r\n  /** This server's ID */\r\n  serverId: string;\r\n  /** Peer server URLs */\r\n  peers: string[];\r\n  /** Request timeout for peer communication */\r\n  timeout?: number;\r\n  /** How long before a peer is considered stale */\r\n  staleThreshold?: number;\r\n  /** Enable debug logging */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Mesh Coordinator - manages peer awareness without leader election\r\n * \r\n * Key principles:\r\n * - No leader election\r\n * - No background polling loops\r\n * - Gossip piggybacks on normal requests\r\n * - Each server maintains its own view of the mesh\r\n */\r\nexport class MeshCoordinator {\r\n  private config: MeshConfig;\r\n  private state: MeshState;\r\n\r\n  constructor(config: MeshConfig) {\r\n    this.config = {\r\n      timeout: 5000,\r\n      staleThreshold: 60000,\r\n      debug: false,\r\n      ...config,\r\n    };\r\n\r\n    this.state = {\r\n      serverId: config.serverId,\r\n      maxVersionSeen: 0,\r\n      peers: new Map(),\r\n      lastGossipTime: 0,\r\n    };\r\n\r\n    // Initialize peer list\r\n    for (const url of config.peers) {\r\n      this.state.peers.set(url, {\r\n        url,\r\n        serverId: '', // Will be populated on first contact\r\n        health: 'unknown',\r\n        maxVersionSeen: 0,\r\n        lastSeen: 0,\r\n        lastLatency: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current server ID\r\n   */\r\n  getServerId(): string {\r\n    return this.state.serverId;\r\n  }\r\n\r\n  /**\r\n   * Get current max version seen by this server\r\n   */\r\n  getMaxVersionSeen(): number {\r\n    return this.state.maxVersionSeen;\r\n  }\r\n\r\n  /**\r\n   * Update max version seen\r\n   */\r\n  updateMaxVersion(version: number): void {\r\n    this.state.maxVersionSeen = Math.max(this.state.maxVersionSeen, version);\r\n  }\r\n\r\n  /**\r\n   * Get peer health map for sync responses\r\n   */\r\n  getPeerHealthMap(): Record<string, PeerHealth> {\r\n    const result: Record<string, PeerHealth> = {};\r\n    \r\n    for (const [url, peer] of this.state.peers) {\r\n      result[url] = peer.health;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get all peers\r\n   */\r\n  getPeers(): Map<string, PeerInfo> {\r\n    return new Map(this.state.peers);\r\n  }\r\n\r\n  /**\r\n   * Get healthy peers sorted by staleness (least stale first)\r\n   */\r\n  getHealthyPeers(): PeerInfo[] {\r\n    const now = Date.now();\r\n    const staleThreshold = this.config.staleThreshold!;\r\n\r\n    return Array.from(this.state.peers.values())\r\n      .filter((peer) => {\r\n        if (peer.health === 'unhealthy') return false;\r\n        if (now - peer.lastSeen > staleThreshold) return false;\r\n        return true;\r\n      })\r\n      .sort((a, b) => {\r\n        // Prefer highest maxVersionSeen (least stale)\r\n        const versionDiff = b.maxVersionSeen - a.maxVersionSeen;\r\n        if (versionDiff !== 0) return versionDiff;\r\n        // Then prefer lowest latency\r\n        return a.lastLatency - b.lastLatency;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Create gossip payload to piggyback on responses\r\n   */\r\n  createGossipPayload(): GossipPayload {\r\n    const peerSummaries = Array.from(this.state.peers.values()).map((peer) => ({\r\n      url: peer.url,\r\n      health: peer.health,\r\n      maxVersion: peer.maxVersionSeen,\r\n      lastSeen: peer.lastSeen,\r\n    }));\r\n\r\n    return {\r\n      serverId: this.state.serverId,\r\n      maxVersion: this.state.maxVersionSeen,\r\n      peerSummaries,\r\n      timestamp: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Process incoming gossip from a peer\r\n   */\r\n  processGossip(gossip: GossipPayload, sourceUrl: string, latency: number): void {\r\n    // Validate gossip payload\r\n    const parsed = GossipPayloadSchema.safeParse(gossip);\r\n    if (!parsed.success) {\r\n      if (this.config.debug) {\r\n        console.warn(`[Mesh] Invalid gossip from ${sourceUrl}:`, parsed.error);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    // Update source peer info\r\n    const sourcePeer = this.state.peers.get(sourceUrl);\r\n    if (sourcePeer) {\r\n      sourcePeer.serverId = gossip.serverId;\r\n      sourcePeer.health = 'healthy';\r\n      sourcePeer.maxVersionSeen = gossip.maxVersion;\r\n      sourcePeer.lastSeen = now;\r\n      sourcePeer.lastLatency = latency;\r\n    }\r\n\r\n    // Process peer summaries (transitive gossip)\r\n    for (const summary of gossip.peerSummaries) {\r\n      // Don't process ourselves\r\n      if (summary.url === this.getServerUrl()) continue;\r\n\r\n      let peer = this.state.peers.get(summary.url);\r\n      \r\n      if (!peer) {\r\n        // Discovered a new peer!\r\n        peer = {\r\n          url: summary.url,\r\n          serverId: '',\r\n          health: summary.health,\r\n          maxVersionSeen: summary.maxVersion,\r\n          lastSeen: summary.lastSeen,\r\n          lastLatency: 0,\r\n        };\r\n        this.state.peers.set(summary.url, peer);\r\n        \r\n        if (this.config.debug) {\r\n          console.log(`[Mesh] Discovered new peer: ${summary.url}`);\r\n        }\r\n      } else {\r\n        // Update with more recent info\r\n        if (summary.lastSeen > peer.lastSeen) {\r\n          peer.health = summary.health;\r\n          peer.maxVersionSeen = Math.max(peer.maxVersionSeen, summary.maxVersion);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.state.lastGossipTime = now;\r\n  }\r\n\r\n  /**\r\n   * Mark a peer as unhealthy after failed communication\r\n   */\r\n  markPeerUnhealthy(url: string): void {\r\n    const peer = this.state.peers.get(url);\r\n    if (peer) {\r\n      peer.health = 'unhealthy';\r\n      \r\n      if (this.config.debug) {\r\n        console.log(`[Mesh] Marked peer unhealthy: ${url}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Propagate invalidation to peers\r\n   * \r\n   * This is done opportunistically, piggybacking on the next request.\r\n   * It's NOT required for correctness - just acceleration.\r\n   */\r\n  async propagateInvalidation(keys: string[]): Promise<void> {\r\n    const healthyPeers = this.getHealthyPeers();\r\n    \r\n    // Propagate to a subset of healthy peers (gossip-style)\r\n    const targetPeers = healthyPeers.slice(0, Math.ceil(healthyPeers.length / 2));\r\n\r\n    const promises = targetPeers.map(async (peer) => {\r\n      try {\r\n        const startTime = Date.now();\r\n        \r\n        const response = await fetch(`${peer.url}/reality/invalidate`, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            'X-Reality-Server': this.state.serverId,\r\n          },\r\n          body: JSON.stringify({\r\n            keys,\r\n            source: this.state.serverId,\r\n            timestamp: Date.now(),\r\n          }),\r\n          signal: AbortSignal.timeout(this.config.timeout!),\r\n        });\r\n\r\n        const latency = Date.now() - startTime;\r\n\r\n        if (response.ok) {\r\n          // Process any gossip in response\r\n          const gossip = response.headers.get('X-Reality-Gossip');\r\n          if (gossip) {\r\n            try {\r\n              this.processGossip(JSON.parse(gossip), peer.url, latency);\r\n            } catch {\r\n              // Ignore invalid gossip\r\n            }\r\n          }\r\n        } else {\r\n          this.markPeerUnhealthy(peer.url);\r\n        }\r\n      } catch {\r\n        this.markPeerUnhealthy(peer.url);\r\n      }\r\n    });\r\n\r\n    // Fire and forget - don't wait for all peers\r\n    Promise.allSettled(promises);\r\n  }\r\n\r\n  /**\r\n   * Query a peer for missing versions\r\n   * \r\n   * Used when a client reports versions we haven't seen.\r\n   */\r\n  async queryPeerForVersions(sinceVersion: number): Promise<GossipPayload | null> {\r\n    const healthyPeers = this.getHealthyPeers();\r\n    \r\n    for (const peer of healthyPeers) {\r\n      // Skip peers that don't have newer versions\r\n      if (peer.maxVersionSeen <= sinceVersion) continue;\r\n\r\n      try {\r\n        const startTime = Date.now();\r\n        \r\n        const response = await fetch(\r\n          `${peer.url}/reality/versions?since=${sinceVersion}`,\r\n          {\r\n            headers: {\r\n              'X-Reality-Server': this.state.serverId,\r\n            },\r\n            signal: AbortSignal.timeout(this.config.timeout!),\r\n          }\r\n        );\r\n\r\n        const latency = Date.now() - startTime;\r\n\r\n        if (response.ok) {\r\n          const gossip = await response.json();\r\n          this.processGossip(gossip, peer.url, latency);\r\n          return gossip;\r\n        }\r\n      } catch {\r\n        this.markPeerUnhealthy(peer.url);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get server URL (for self-identification in gossip)\r\n   */\r\n  private getServerUrl(): string {\r\n    // This should be set from config in production\r\n    return `http://localhost:${process.env.PORT ?? 3000}`;\r\n  }\r\n\r\n  /**\r\n   * Get mesh statistics\r\n   */\r\n  getStats(): {\r\n    serverId: string;\r\n    maxVersionSeen: number;\r\n    peerCount: number;\r\n    healthyPeerCount: number;\r\n    lastGossipTime: number;\r\n  } {\r\n    const healthyCount = Array.from(this.state.peers.values())\r\n      .filter((p) => p.health === 'healthy').length;\r\n\r\n    return {\r\n      serverId: this.state.serverId,\r\n      maxVersionSeen: this.state.maxVersionSeen,\r\n      peerCount: this.state.peers.size,\r\n      healthyPeerCount: healthyCount,\r\n      lastGossipTime: this.state.lastGossipTime,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create mesh coordinator\r\n */\r\nexport function createMeshCoordinator(config: MeshConfig): MeshCoordinator {\r\n  return new MeshCoordinator(config);\r\n}\r\n","/**\r\n * @rootlodge/reality-server - HTTP Handlers\r\n * \r\n * HTTP endpoint handlers for Reality server.\r\n * Framework-agnostic implementation.\r\n */\r\n\r\nimport { z } from 'zod';\r\nimport type {\r\n  RealityStorage,\r\n  RealityRequest,\r\n  RealityResponse,\r\n  SyncRequest,\r\n  SyncResponse,\r\n  ChangedNode,\r\n  InvalidationResponse,\r\n  HealthResponse,\r\n} from '../types';\r\nimport { SyncRequestSchema, InvalidationRequestSchema } from '../types';\r\nimport { MeshCoordinator } from '../mesh/coordinator';\r\nimport { RedisAccelerator } from '../redis/accelerator';\r\n\r\n/**\r\n * Handler dependencies\r\n */\r\nexport interface HandlerDeps {\r\n  storage: RealityStorage;\r\n  mesh: MeshCoordinator;\r\n  redis?: RedisAccelerator;\r\n  serverId: string;\r\n  version: string;\r\n  startTime: number;\r\n  debug?: boolean;\r\n  /** Optional: Fetch payload for a key */\r\n  payloadFetcher?: (key: string) => Promise<unknown>;\r\n}\r\n\r\n/**\r\n * Create JSON response\r\n */\r\nfunction jsonResponse(data: unknown, status = 200, headers: Record<string, string> = {}): RealityResponse {\r\n  return {\r\n    status,\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n    },\r\n    body: data,\r\n  };\r\n}\r\n\r\n/**\r\n * Create error response\r\n */\r\nfunction errorResponse(message: string, status = 400): RealityResponse {\r\n  return jsonResponse({ error: message }, status);\r\n}\r\n\r\n/**\r\n * Handle sync request\r\n * \r\n * This is the core endpoint that clients call to synchronize state.\r\n */\r\nexport async function handleSync(\r\n  req: RealityRequest,\r\n  deps: HandlerDeps\r\n): Promise<RealityResponse> {\r\n  // Parse and validate request\r\n  const parsed = SyncRequestSchema.safeParse(req.body);\r\n  if (!parsed.success) {\r\n    return errorResponse(`Invalid request: ${parsed.error.message}`);\r\n  }\r\n\r\n  const syncRequest: SyncRequest = parsed.data;\r\n  const { storage, mesh, redis: _redis, payloadFetcher } = deps;\r\n\r\n  try {\r\n    // Get all keys client is interested in\r\n    const keys = Object.keys(syncRequest.known);\r\n    \r\n    // Fetch current metadata for all keys\r\n    const nodeMetas = await storage.getNodes(keys);\r\n    \r\n    // Build changed map\r\n    const changed: Record<string, ChangedNode> = {};\r\n    \r\n    for (const [key, clientVersion] of Object.entries(syncRequest.known)) {\r\n      const meta = nodeMetas.get(key);\r\n      \r\n      if (!meta) {\r\n        // Key doesn't exist on server - could be deleted or never existed\r\n        // We report it as version 0 so client knows it's gone\r\n        changed[key] = {\r\n          version: 0,\r\n          hash: '',\r\n          source: deps.serverId,\r\n        };\r\n        continue;\r\n      }\r\n\r\n      // Check if client has stale version\r\n      if (meta.version > clientVersion) {\r\n        const changedNode: ChangedNode = {\r\n          version: meta.version,\r\n          hash: meta.hash,\r\n          source: deps.serverId,\r\n        };\r\n\r\n        // Include payload for small updates if fetcher is available\r\n        if (payloadFetcher) {\r\n          try {\r\n            const payload = await payloadFetcher(key);\r\n            // Only include if payload is small enough\r\n            const payloadStr = JSON.stringify(payload);\r\n            if (payloadStr.length < 1024) {\r\n              changedNode.payload = payload;\r\n            }\r\n          } catch {\r\n            // Payload fetch failed - client will need to fetch separately\r\n          }\r\n        }\r\n\r\n        changed[key] = changedNode;\r\n      }\r\n    }\r\n\r\n    // Update mesh max version\r\n    const maxVersion = await storage.getMaxVersion();\r\n    mesh.updateMaxVersion(maxVersion);\r\n\r\n    // Build response\r\n    const response: SyncResponse = {\r\n      changed,\r\n      mesh: {\r\n        peers: mesh.getPeerHealthMap(),\r\n        serverVersion: maxVersion,\r\n      },\r\n      serverTime: Date.now(),\r\n    };\r\n\r\n    // Create response with gossip header\r\n    const gossipHeader = JSON.stringify(mesh.createGossipPayload());\r\n\r\n    return jsonResponse(response, 200, {\r\n      'X-Reality-Gossip': gossipHeader,\r\n      'X-Reality-Server': deps.serverId,\r\n    });\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Internal server error';\r\n    return errorResponse(message, 500);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invalidation request\r\n * \r\n * Called when data is updated to propagate invalidation to the mesh.\r\n */\r\nexport async function handleInvalidation(\r\n  req: RealityRequest,\r\n  deps: HandlerDeps\r\n): Promise<RealityResponse> {\r\n  const parsed = InvalidationRequestSchema.safeParse(req.body);\r\n  if (!parsed.success) {\r\n    return errorResponse(`Invalid request: ${parsed.error.message}`);\r\n  }\r\n\r\n  const { keys, source } = parsed.data;\r\n  const { storage, mesh, redis } = deps;\r\n\r\n  try {\r\n    const versions: Record<string, number> = {};\r\n    const invalidated: string[] = [];\r\n\r\n    // For each key, check if we need to sync from source\r\n    for (const key of keys) {\r\n      const meta = await storage.getNode(key);\r\n      if (meta) {\r\n        versions[key] = meta.version;\r\n        invalidated.push(key);\r\n      }\r\n    }\r\n\r\n    // Invalidate Redis cache if available\r\n    if (redis?.isConnected()) {\r\n      for (const key of keys) {\r\n        await redis.invalidateCache(key);\r\n      }\r\n      \r\n      // Publish to other servers\r\n      await redis.publishInvalidation(keys);\r\n    }\r\n\r\n    // Propagate to mesh peers (fire and forget)\r\n    if (source !== deps.serverId) {\r\n      mesh.propagateInvalidation(keys);\r\n    }\r\n\r\n    const response: InvalidationResponse = {\r\n      invalidated,\r\n      versions,\r\n    };\r\n\r\n    return jsonResponse(response, 200, {\r\n      'X-Reality-Gossip': JSON.stringify(mesh.createGossipPayload()),\r\n      'X-Reality-Server': deps.serverId,\r\n    });\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Internal server error';\r\n    return errorResponse(message, 500);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle version query\r\n * \r\n * Returns all versions changed since a given version.\r\n * Used for peer-to-peer sync.\r\n */\r\nexport async function handleVersionQuery(\r\n  req: RealityRequest,\r\n  deps: HandlerDeps\r\n): Promise<RealityResponse> {\r\n  const since = parseInt(req.query.since ?? '0', 10);\r\n  \r\n  if (isNaN(since) || since < 0) {\r\n    return errorResponse('Invalid since parameter');\r\n  }\r\n\r\n  try {\r\n    const changed = await deps.storage.listChangedSince(since);\r\n    \r\n    return jsonResponse({\r\n      ...deps.mesh.createGossipPayload(),\r\n      changed: changed.map((meta) => ({\r\n        key: meta.key,\r\n        version: meta.version,\r\n        hash: meta.hash,\r\n      })),\r\n    }, 200, {\r\n      'X-Reality-Server': deps.serverId,\r\n    });\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Internal server error';\r\n    return errorResponse(message, 500);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle health check\r\n */\r\nexport async function handleHealth(\r\n  _req: RealityRequest,\r\n  deps: HandlerDeps\r\n): Promise<RealityResponse> {\r\n  const { storage, mesh, redis, serverId, version, startTime } = deps;\r\n\r\n  try {\r\n    const storageHealthy = await storage.isHealthy();\r\n    const maxVersion = await storage.getMaxVersion();\r\n    const meshStats = mesh.getStats();\r\n    \r\n    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\r\n    \r\n    if (!storageHealthy) {\r\n      status = 'unhealthy';\r\n    } else if (meshStats.healthyPeerCount === 0 && meshStats.peerCount > 0) {\r\n      status = 'degraded';\r\n    }\r\n\r\n    const response: HealthResponse = {\r\n      status,\r\n      serverId,\r\n      version,\r\n      uptime: Date.now() - startTime,\r\n      mesh: {\r\n        peerCount: meshStats.peerCount,\r\n        healthyPeers: meshStats.healthyPeerCount,\r\n      },\r\n      storage: {\r\n        healthy: storageHealthy,\r\n        maxVersion,\r\n      },\r\n    };\r\n\r\n    if (redis) {\r\n      response.redis = {\r\n        connected: redis.isConnected(),\r\n      };\r\n    }\r\n\r\n    return jsonResponse(response, status === 'unhealthy' ? 503 : 200);\r\n  } catch (error) {\r\n    return jsonResponse({\r\n      status: 'unhealthy',\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    }, 503);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle node update (write)\r\n * \r\n * Called when data is written to update the invalidation graph.\r\n */\r\nexport async function handleNodeUpdate(\r\n  req: RealityRequest,\r\n  deps: HandlerDeps\r\n): Promise<RealityResponse> {\r\n  const schema = z.object({\r\n    key: z.string().min(1),\r\n    hash: z.string().min(1),\r\n  });\r\n\r\n  const parsed = schema.safeParse(req.body);\r\n  if (!parsed.success) {\r\n    return errorResponse(`Invalid request: ${parsed.error.message}`);\r\n  }\r\n\r\n  const { key, hash } = parsed.data;\r\n  const { storage, mesh, redis } = deps;\r\n\r\n  try {\r\n    // Increment version in storage\r\n    const meta = await storage.incrementVersion(key, hash);\r\n\r\n    // Update mesh max version\r\n    mesh.updateMaxVersion(meta.version);\r\n\r\n    // Invalidate and propagate\r\n    if (redis?.isConnected()) {\r\n      await redis.invalidateCache(key);\r\n      await redis.publishInvalidation([key]);\r\n    }\r\n\r\n    // Propagate to peers\r\n    mesh.propagateInvalidation([key]);\r\n\r\n    return jsonResponse({\r\n      key: meta.key,\r\n      version: meta.version,\r\n      hash: meta.hash,\r\n      updatedAt: meta.updatedAt,\r\n    }, 200, {\r\n      'X-Reality-Gossip': JSON.stringify(mesh.createGossipPayload()),\r\n      'X-Reality-Server': deps.serverId,\r\n    });\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Internal server error';\r\n    return errorResponse(message, 500);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle CORS preflight\r\n */\r\nexport function handleCors(\r\n  _req: RealityRequest,\r\n  origins: string[]\r\n): RealityResponse {\r\n  const allowOrigin = origins.includes('*') ? '*' : origins[0] ?? '*';\r\n  \r\n  return {\r\n    status: 204,\r\n    headers: {\r\n      'Access-Control-Allow-Origin': allowOrigin,\r\n      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, X-Reality-Server, X-Reality-Gossip',\r\n      'Access-Control-Max-Age': '86400',\r\n    },\r\n    body: null,\r\n  };\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Fetch API Handler\r\n * \r\n * Universal handler using the Fetch API standard.\r\n * Works with Cloudflare Workers, Deno, Bun, Node.js 18+, and any edge runtime.\r\n */\r\n\r\nimport type { RealityRequest } from '../types';\r\nimport type { HandlerDeps } from './handlers';\r\nimport {\r\n  handleSync,\r\n  handleInvalidation,\r\n  handleVersionQuery,\r\n  handleHealth,\r\n  handleNodeUpdate,\r\n  handleCors,\r\n} from './handlers';\r\n\r\n/**\r\n * Route configuration\r\n */\r\ninterface RouteConfig {\r\n  /** Base path for Reality routes (e.g., '/reality') */\r\n  basePath?: string;\r\n  /** CORS origins */\r\n  corsOrigins?: string[];\r\n}\r\n\r\n/**\r\n * Convert Fetch Request to Reality request\r\n */\r\nasync function toRealityRequest(request: Request): Promise<RealityRequest> {\r\n  const url = new URL(request.url);\r\n  \r\n  let body: unknown = null;\r\n  if (request.method !== 'GET' && request.method !== 'HEAD') {\r\n    try {\r\n      body = await request.json();\r\n    } catch {\r\n      body = null;\r\n    }\r\n  }\r\n\r\n  const query: Record<string, string> = {};\r\n  for (const [key, value] of url.searchParams) {\r\n    query[key] = value;\r\n  }\r\n\r\n  return {\r\n    method: request.method,\r\n    url: request.url,\r\n    headers: request.headers,\r\n    body,\r\n    params: {},\r\n    query,\r\n  };\r\n}\r\n\r\n/**\r\n * Convert Reality response to Fetch Response\r\n */\r\nfunction toFetchResponse(realityResponse: { status: number; headers: Record<string, string>; body: unknown }): Response {\r\n  const body = realityResponse.body !== null\r\n    ? JSON.stringify(realityResponse.body)\r\n    : null;\r\n\r\n  return new Response(body, {\r\n    status: realityResponse.status,\r\n    headers: realityResponse.headers,\r\n  });\r\n}\r\n\r\n/**\r\n * Create a Fetch API handler for Reality server\r\n * \r\n * This is the universal handler that works with any runtime supporting Fetch API.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Cloudflare Workers\r\n * import { createFetchHandler } from '@rootlodge/reality-server/http';\r\n * \r\n * const handler = createFetchHandler(deps, { basePath: '/reality' });\r\n * \r\n * export default {\r\n *   fetch: handler,\r\n * };\r\n * ```\r\n * \r\n * @example\r\n * ```typescript\r\n * // Deno\r\n * import { createFetchHandler } from '@rootlodge/reality-server/http';\r\n * \r\n * const handler = createFetchHandler(deps, { basePath: '/reality' });\r\n * \r\n * Deno.serve({ port: 3000 }, handler);\r\n * ```\r\n * \r\n * @example\r\n * ```typescript\r\n * // Bun\r\n * import { createFetchHandler } from '@rootlodge/reality-server/http';\r\n * \r\n * const handler = createFetchHandler(deps, { basePath: '/reality' });\r\n * \r\n * Bun.serve({ port: 3000, fetch: handler });\r\n * ```\r\n * \r\n * @example\r\n * ```typescript\r\n * // Node.js 18+ with native fetch\r\n * import { createServer } from 'http';\r\n * import { createFetchHandler } from '@rootlodge/reality-server/http';\r\n * \r\n * const handler = createFetchHandler(deps, { basePath: '/reality' });\r\n * \r\n * createServer(async (req, res) => {\r\n *   const url = `http://${req.headers.host}${req.url}`;\r\n *   const request = new Request(url, {\r\n *     method: req.method,\r\n *     headers: req.headers as HeadersInit,\r\n *     body: req.method !== 'GET' && req.method !== 'HEAD' ? req : undefined,\r\n *   });\r\n *   const response = await handler(request);\r\n *   res.writeHead(response.status, Object.fromEntries(response.headers));\r\n *   res.end(await response.text());\r\n * }).listen(3000);\r\n * ```\r\n */\r\nexport function createFetchHandler(\r\n  deps: HandlerDeps,\r\n  config: RouteConfig = {}\r\n): (request: Request) => Promise<Response> {\r\n  const basePath = config.basePath ?? '/reality';\r\n  const corsOrigins = config.corsOrigins ?? ['*'];\r\n\r\n  return async (request: Request): Promise<Response> => {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n\r\n    // Check if this is a Reality route\r\n    if (!path.startsWith(basePath)) {\r\n      return new Response('Not Found', { status: 404 });\r\n    }\r\n\r\n    // Get the route path (without base path)\r\n    const routePath = path.slice(basePath.length) || '/';\r\n\r\n    // Handle CORS preflight\r\n    if (request.method === 'OPTIONS') {\r\n      const realityReq = await toRealityRequest(request);\r\n      const response = handleCors(realityReq, corsOrigins);\r\n      return toFetchResponse(response);\r\n    }\r\n\r\n    // Add CORS headers to all responses\r\n    const corsHeaders: Record<string, string> = {\r\n      'Access-Control-Allow-Origin': corsOrigins.includes('*') ? '*' : corsOrigins[0] ?? '*',\r\n      'Access-Control-Allow-Credentials': 'true',\r\n    };\r\n\r\n    try {\r\n      const realityReq = await toRealityRequest(request);\r\n      let response;\r\n\r\n      switch (routePath) {\r\n        case '/sync':\r\n          if (request.method !== 'POST') {\r\n            return new Response(JSON.stringify({ error: 'Method not allowed' }), {\r\n              status: 405,\r\n              headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n            });\r\n          }\r\n          response = await handleSync(realityReq, deps);\r\n          break;\r\n\r\n        case '/invalidate':\r\n          if (request.method !== 'POST') {\r\n            return new Response(JSON.stringify({ error: 'Method not allowed' }), {\r\n              status: 405,\r\n              headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n            });\r\n          }\r\n          response = await handleInvalidation(realityReq, deps);\r\n          break;\r\n\r\n        case '/versions':\r\n          if (request.method !== 'GET') {\r\n            return new Response(JSON.stringify({ error: 'Method not allowed' }), {\r\n              status: 405,\r\n              headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n            });\r\n          }\r\n          response = await handleVersionQuery(realityReq, deps);\r\n          break;\r\n\r\n        case '/health':\r\n        case '/':\r\n          response = await handleHealth(realityReq, deps);\r\n          break;\r\n\r\n        case '/update':\r\n          if (request.method !== 'POST') {\r\n            return new Response(JSON.stringify({ error: 'Method not allowed' }), {\r\n              status: 405,\r\n              headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n            });\r\n          }\r\n          response = await handleNodeUpdate(realityReq, deps);\r\n          break;\r\n\r\n        default:\r\n          return new Response(JSON.stringify({ error: 'Not found' }), {\r\n            status: 404,\r\n            headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n          });\r\n      }\r\n\r\n      // Merge CORS headers\r\n      response.headers = { ...response.headers, ...corsHeaders };\r\n      return toFetchResponse(response);\r\n    } catch (error) {\r\n      return new Response(\r\n        JSON.stringify({\r\n          error: error instanceof Error ? error.message : 'Internal server error',\r\n        }),\r\n        {\r\n          status: 500,\r\n          headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n        }\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Create a Cloudflare Workers compatible handler\r\n */\r\nexport function createWorkersHandler(\r\n  deps: HandlerDeps,\r\n  config: RouteConfig = {}\r\n): { fetch: (request: Request) => Promise<Response> } {\r\n  const handler = createFetchHandler(deps, config);\r\n  return { fetch: handler };\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Reality Server\r\n * \r\n * Main server class that brings together all components.\r\n * \r\n * IMPORTANT: Reality does NOT own your data!\r\n * - Storage is optional (defaults to in-memory)\r\n * - Reality only tracks change metadata (version/hash)\r\n * - Your application stores the actual payloads\r\n * - DB adapters are optional helpers for invalidation\r\n */\r\n\r\nimport type {\r\n  ServerConfig,\r\n  ResolvedServerConfig,\r\n  RealityStorage,\r\n  RealityNodeMeta,\r\n  RealityInvalidationAdapter,\r\n} from './types';\r\nimport { ServerConfigSchema } from './types';\r\nimport { MemoryStorage } from './storage/memory';\r\nimport { MeshCoordinator, createMeshCoordinator } from './mesh/coordinator';\r\nimport { RedisAccelerator } from './redis/accelerator';\r\nimport { createFetchHandler } from './http/fetch';\r\nimport type { HandlerDeps } from './http/handlers';\r\n\r\n/**\r\n * Reality Server options after resolution\r\n */\r\ninterface RealityServerComponents {\r\n  config: ResolvedServerConfig;\r\n  storage: RealityStorage;\r\n  mesh: MeshCoordinator;\r\n  redis?: RedisAccelerator;\r\n  invalidationAdapter?: RealityInvalidationAdapter;\r\n  startTime: number;\r\n}\r\n\r\n/**\r\n * Reality Server\r\n * \r\n * The main server class that coordinates storage, mesh, and HTTP handling.\r\n * \r\n * IMPORTANT: Reality does NOT own your data. It only tracks change metadata.\r\n * Storage is optional - use in-memory for simple cases, or skip entirely\r\n * and use external storage with advisory invalidation.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Minimal setup - no database required!\r\n * const server = new RealityServer({\r\n *   serverId: 'server-1',\r\n * });\r\n * \r\n * // With mesh peers\r\n * const server = new RealityServer({\r\n *   serverId: 'server-1',\r\n *   peers: ['https://server-2.example.com'],\r\n * });\r\n * \r\n * // Invalidate when your data changes\r\n * await server.invalidate('chat:room:123');\r\n * await server.invalidateMany(['user:42', 'feed:global']);\r\n * ```\r\n */\r\nexport class RealityServer {\r\n  private components: RealityServerComponents;\r\n  private handlerDeps: HandlerDeps;\r\n\r\n  constructor(config: ServerConfig, customStorage?: RealityStorage) {\r\n    // Validate and resolve config\r\n    const parsed = ServerConfigSchema.safeParse(config);\r\n    if (!parsed.success) {\r\n      throw new Error(`Invalid server config: ${parsed.error.message}`);\r\n    }\r\n\r\n    const resolvedConfig = parsed.data;\r\n\r\n    // Initialize storage (optional - defaults to memory)\r\n    const storage = customStorage ?? new MemoryStorage();\r\n\r\n    // Initialize mesh coordinator\r\n    const mesh = createMeshCoordinator({\r\n      serverId: resolvedConfig.serverId,\r\n      peers: resolvedConfig.peers,\r\n      debug: resolvedConfig.debug,\r\n    });\r\n\r\n    this.components = {\r\n      config: resolvedConfig,\r\n      storage,\r\n      mesh,\r\n      startTime: Date.now(),\r\n    };\r\n\r\n    // Build handler dependencies\r\n    this.handlerDeps = {\r\n      storage: this.components.storage,\r\n      mesh: this.components.mesh,\r\n      redis: this.components.redis,\r\n      serverId: resolvedConfig.serverId,\r\n      version: '1.0.0',\r\n      startTime: this.components.startTime,\r\n      debug: resolvedConfig.debug,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Invalidate a single key\r\n   * Call this when your data changes - Reality will propagate the invalidation.\r\n   * \r\n   * @param key - The key to invalidate (e.g., 'chat:room:123')\r\n   */\r\n  async invalidate(key: string): Promise<void> {\r\n    return this.invalidateMany([key]);\r\n  }\r\n\r\n  /**\r\n   * Invalidate multiple keys at once\r\n   * More efficient than calling invalidate() multiple times.\r\n   * \r\n   * @param keys - Array of keys to invalidate\r\n   */\r\n  async invalidateMany(keys: string[]): Promise<void> {\r\n    for (const key of keys) {\r\n      await this.components.storage.incrementVersion(key, '');\r\n    }\r\n    \r\n    // Update mesh\r\n    const maxVersion = await this.components.storage.getMaxVersion();\r\n    this.components.mesh.updateMaxVersion(maxVersion);\r\n\r\n    // Propagate via Redis if available\r\n    if (this.components.redis?.isConnected()) {\r\n      for (const key of keys) {\r\n        await this.components.redis.invalidateCache(key);\r\n      }\r\n      await this.components.redis.publishInvalidation(keys);\r\n    }\r\n\r\n    // Propagate to mesh peers\r\n    this.components.mesh.propagateInvalidation(keys);\r\n    \r\n    // Notify invalidation adapter if configured\r\n    if (this.components.invalidationAdapter) {\r\n      await this.components.invalidationAdapter.onInvalidate(keys);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set invalidation adapter for database integration\r\n   */\r\n  setInvalidationAdapter(adapter: RealityInvalidationAdapter): void {\r\n    this.components.invalidationAdapter = adapter;\r\n  }\r\n\r\n  /**\r\n   * Set custom storage adapter\r\n   */\r\n  setStorage(storage: RealityStorage): void {\r\n    this.components.storage = storage;\r\n    this.handlerDeps.storage = storage;\r\n  }\r\n\r\n  /**\r\n   * Set Redis accelerator\r\n   */\r\n  setRedis(redis: RedisAccelerator): void {\r\n    this.components.redis = redis;\r\n    this.handlerDeps.redis = redis;\r\n  }\r\n\r\n  /**\r\n   * Set payload fetcher for inline payloads\r\n   */\r\n  setPayloadFetcher(fetcher: (key: string) => Promise<unknown>): void {\r\n    this.handlerDeps.payloadFetcher = fetcher;\r\n  }\r\n\r\n  /**\r\n   * Get the Fetch API handler\r\n   */\r\n  getFetchHandler(basePath = '/reality'): (request: Request) => Promise<Response> {\r\n    return createFetchHandler(this.handlerDeps, {\r\n      basePath,\r\n      corsOrigins: this.components.config.cors.origins,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get handler dependencies for custom integrations\r\n   */\r\n  getHandlerDeps(): HandlerDeps {\r\n    return { ...this.handlerDeps };\r\n  }\r\n\r\n  /**\r\n   * Get storage instance\r\n   */\r\n  getStorage(): RealityStorage {\r\n    return this.components.storage;\r\n  }\r\n\r\n  /**\r\n   * Get mesh coordinator\r\n   */\r\n  getMesh(): MeshCoordinator {\r\n    return this.components.mesh;\r\n  }\r\n\r\n  /**\r\n   * Get Redis accelerator if configured\r\n   */\r\n  getRedis(): RedisAccelerator | undefined {\r\n    return this.components.redis;\r\n  }\r\n\r\n  /**\r\n   * Update a node's version (call this when your data changes)\r\n   * \r\n   * @param key - The node key\r\n   * @param hash - Hash of the new data\r\n   * @returns Updated node metadata\r\n   */\r\n  async updateNode(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    const meta = await this.components.storage.incrementVersion(key, hash);\r\n    \r\n    // Update mesh\r\n    this.components.mesh.updateMaxVersion(meta.version);\r\n\r\n    // Propagate via Redis if available\r\n    if (this.components.redis?.isConnected()) {\r\n      await this.components.redis.invalidateCache(key);\r\n      await this.components.redis.publishInvalidation([key]);\r\n    }\r\n\r\n    // Propagate to mesh peers\r\n    this.components.mesh.propagateInvalidation([key]);\r\n\r\n    return meta;\r\n  }\r\n\r\n  /**\r\n   * Get node metadata\r\n   */\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    return this.components.storage.getNode(key);\r\n  }\r\n\r\n  /**\r\n   * Delete a node\r\n   */\r\n  async deleteNode(key: string): Promise<void> {\r\n    await this.components.storage.deleteNode(key);\r\n\r\n    // Propagate invalidation\r\n    if (this.components.redis?.isConnected()) {\r\n      await this.components.redis.invalidateCache(key);\r\n      await this.components.redis.publishInvalidation([key]);\r\n    }\r\n\r\n    this.components.mesh.propagateInvalidation([key]);\r\n  }\r\n\r\n  /**\r\n   * Get server statistics\r\n   */\r\n  getStats() {\r\n    return {\r\n      serverId: this.components.config.serverId,\r\n      uptime: Date.now() - this.components.startTime,\r\n      mesh: this.components.mesh.getStats(),\r\n      redis: this.components.redis?.getStats(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a Reality server instance\r\n */\r\nexport function createRealityServer(config: ServerConfig, storage?: RealityStorage): RealityServer {\r\n  return new RealityServer(config, storage);\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Embedded Server\r\n * \r\n * In-process Reality server for SSR environments.\r\n * Works with TanStack Start, Vite SSR, Next.js, and other SSR frameworks.\r\n * \r\n * Features:\r\n * - No HTTP overhead - direct function calls\r\n * - Stateless per-request or shared state\r\n * - Same invalidation graph as external servers\r\n * - Auto-detection of SSR context\r\n */\r\n\r\nimport type {\r\n  SyncRequest,\r\n  SyncResponse,\r\n  RealityNodeMeta,\r\n  RealityStorage,\r\n  ChangedNode,\r\n  PeerHealth,\r\n  RealityInvalidationAdapter,\r\n  InvalidationConfig,\r\n} from './types';\r\nimport { MemoryStorage } from './storage/memory';\r\nimport { MeshCoordinator, createMeshCoordinator } from './mesh/coordinator';\r\nimport type { HandlerDeps } from './http/handlers';\r\n\r\n/**\r\n * Embedded server configuration\r\n */\r\nexport interface EmbeddedServerConfig {\r\n  /** Server identifier (unique per instance) */\r\n  serverId?: string;\r\n  /** Optional storage adapter (defaults to memory) */\r\n  storage?: RealityStorage;\r\n  /** Invalidation configuration */\r\n  invalidation?: InvalidationConfig;\r\n  /** Peer server URLs (for mesh awareness in hybrid mode) */\r\n  peers?: string[];\r\n  /** Enable debug logging */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Embedded Reality Server\r\n * \r\n * Provides in-process Reality server functionality for SSR.\r\n * Can be used standalone or alongside external servers.\r\n * \r\n * @example\r\n * ```typescript\r\n * // TanStack Start / Vite SSR\r\n * import { createEmbeddedRealityServer } from '@rootlodge/reality-server';\r\n * \r\n * const server = createEmbeddedRealityServer({\r\n *   serverId: 'ssr-embedded',\r\n * });\r\n * \r\n * // Use in your SSR code\r\n * const response = await server.handleSync(request);\r\n * ```\r\n */\r\nexport class EmbeddedRealityServer {\r\n  private config: Required<Omit<EmbeddedServerConfig, 'invalidation'>> & { invalidation?: InvalidationConfig };\r\n  private storage: RealityStorage;\r\n  private mesh: MeshCoordinator;\r\n  private invalidationAdapter?: RealityInvalidationAdapter;\r\n  private startTime: number;\r\n\r\n  constructor(config: EmbeddedServerConfig = {}) {\r\n    this.config = {\r\n      serverId: config.serverId ?? `embedded-${Date.now().toString(36)}`,\r\n      storage: config.storage ?? new MemoryStorage(),\r\n      invalidation: config.invalidation,\r\n      peers: config.peers ?? [],\r\n      debug: config.debug ?? false,\r\n    };\r\n    \r\n    this.storage = this.config.storage;\r\n    this.invalidationAdapter = config.invalidation?.adapter;\r\n    this.startTime = Date.now();\r\n\r\n    // Initialize mesh coordinator\r\n    this.mesh = createMeshCoordinator({\r\n      serverId: this.config.serverId,\r\n      peers: this.config.peers,\r\n      debug: this.config.debug,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get server ID\r\n   */\r\n  getServerId(): string {\r\n    return this.config.serverId;\r\n  }\r\n\r\n  /**\r\n   * Handle a sync request directly (no HTTP)\r\n   */\r\n  async handleSync(request: SyncRequest): Promise<SyncResponse> {\r\n    const keys = Object.keys(request.known);\r\n    const nodeMetas = await this.storage.getNodes(keys);\r\n    \r\n    const changed: Record<string, ChangedNode> = {};\r\n    \r\n    for (const [key, clientVersion] of Object.entries(request.known)) {\r\n      const meta = nodeMetas.get(key);\r\n      \r\n      if (!meta) {\r\n        // Key doesn't exist on server\r\n        changed[key] = {\r\n          version: 0,\r\n          hash: '',\r\n          source: this.config.serverId,\r\n        };\r\n        continue;\r\n      }\r\n      \r\n      if (meta.version > clientVersion) {\r\n        changed[key] = {\r\n          version: meta.version,\r\n          hash: meta.hash,\r\n          source: this.config.serverId,\r\n        };\r\n      }\r\n    }\r\n    \r\n    const maxVersion = await this.storage.getMaxVersion();\r\n    \r\n    return {\r\n      changed,\r\n      mesh: {\r\n        peers: this.mesh.getPeerHealthMap() as Record<string, PeerHealth>,\r\n        serverVersion: maxVersion,\r\n      },\r\n      serverTime: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Invalidate keys\r\n   */\r\n  async invalidate(keys: string[]): Promise<void> {\r\n    for (const key of keys) {\r\n      await this.storage.incrementVersion(key, '');\r\n    }\r\n    \r\n    // Notify invalidation adapter if configured\r\n    if (this.invalidationAdapter) {\r\n      await this.invalidationAdapter.onInvalidate(keys);\r\n    }\r\n    \r\n    // Update mesh\r\n    const maxVersion = await this.storage.getMaxVersion();\r\n    this.mesh.updateMaxVersion(maxVersion);\r\n  }\r\n\r\n  /**\r\n   * Invalidate many keys at once\r\n   */\r\n  async invalidateMany(keys: string[]): Promise<void> {\r\n    return this.invalidate(keys);\r\n  }\r\n\r\n  /**\r\n   * Get node metadata\r\n   */\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    return this.storage.getNode(key);\r\n  }\r\n\r\n  /**\r\n   * Update a node's version\r\n   */\r\n  async updateNode(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    const meta = await this.storage.incrementVersion(key, hash);\r\n    this.mesh.updateMaxVersion(meta.version);\r\n    \r\n    // Notify invalidation adapter\r\n    if (this.invalidationAdapter) {\r\n      await this.invalidationAdapter.onInvalidate([key]);\r\n    }\r\n    \r\n    return meta;\r\n  }\r\n\r\n  /**\r\n   * Get storage instance\r\n   */\r\n  getStorage(): RealityStorage {\r\n    return this.storage;\r\n  }\r\n\r\n  /**\r\n   * Set storage adapter\r\n   */\r\n  setStorage(storage: RealityStorage): void {\r\n    this.storage = storage;\r\n    this.config.storage = storage;\r\n  }\r\n\r\n  /**\r\n   * Set invalidation adapter\r\n   */\r\n  setInvalidationAdapter(adapter: RealityInvalidationAdapter): void {\r\n    this.invalidationAdapter = adapter;\r\n  }\r\n\r\n  /**\r\n   * Get handler dependencies for custom integrations\r\n   */\r\n  getHandlerDeps(): HandlerDeps {\r\n    return {\r\n      storage: this.storage,\r\n      mesh: this.mesh,\r\n      serverId: this.config.serverId,\r\n      version: '1.0.0',\r\n      startTime: this.startTime,\r\n      debug: this.config.debug,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get mesh coordinator\r\n   */\r\n  getMesh(): MeshCoordinator {\r\n    return this.mesh;\r\n  }\r\n\r\n  /**\r\n   * Get server stats\r\n   */\r\n  getStats() {\r\n    return {\r\n      serverId: this.config.serverId,\r\n      uptime: Date.now() - this.startTime,\r\n      mode: 'embedded',\r\n      mesh: this.mesh.getStats(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create an embedded Reality server\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const server = createEmbeddedRealityServer();\r\n * \r\n * // With custom storage\r\n * const server = createEmbeddedRealityServer({\r\n *   storage: myStorage,\r\n *   serverId: 'my-ssr-server',\r\n * });\r\n * \r\n * // In SSR handler\r\n * export async function loader() {\r\n *   const server = createEmbeddedRealityServer();\r\n *   const response = await server.handleSync(request);\r\n *   return { realityState: response };\r\n * }\r\n * ```\r\n */\r\nexport function createEmbeddedRealityServer(config: EmbeddedServerConfig = {}): EmbeddedRealityServer {\r\n  return new EmbeddedRealityServer(config);\r\n}\r\n\r\n/**\r\n * Shared embedded server instance for SSR\r\n * Use this when you want to share state across requests\r\n */\r\nlet sharedEmbeddedServer: EmbeddedRealityServer | null = null;\r\n\r\n/**\r\n * Get or create a shared embedded server instance\r\n */\r\nexport function getSharedEmbeddedServer(config?: EmbeddedServerConfig): EmbeddedRealityServer {\r\n  if (!sharedEmbeddedServer) {\r\n    sharedEmbeddedServer = createEmbeddedRealityServer(config);\r\n  }\r\n  return sharedEmbeddedServer;\r\n}\r\n\r\n/**\r\n * Reset the shared embedded server (useful for testing)\r\n */\r\nexport function resetSharedEmbeddedServer(): void {\r\n  sharedEmbeddedServer = null;\r\n}\r\n","/**\r\n * @rootlodge/reality-server - SQL Storage Adapter\r\n * \r\n * Generic SQL storage adapter that works with any SQL database.\r\n * Provides a base implementation that can be extended for specific databases.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * SQL query executor interface\r\n */\r\nexport interface SQLExecutor {\r\n  execute<T = unknown>(sql: string, params?: unknown[]): Promise<T[]>;\r\n  executeOne<T = unknown>(sql: string, params?: unknown[]): Promise<T | null>;\r\n  transaction<T>(fn: (tx: SQLExecutor) => Promise<T>): Promise<T>;\r\n}\r\n\r\n/**\r\n * SQL dialect configuration\r\n */\r\nexport interface SQLDialect {\r\n  /** Placeholder style: '?' for MySQL/SQLite, '$1' for Postgres */\r\n  placeholder: (index: number) => string;\r\n  /** UPSERT syntax */\r\n  upsert: (table: string, columns: string[], conflictColumn: string) => string;\r\n  /** Current timestamp function */\r\n  now: () => string;\r\n}\r\n\r\n/**\r\n * Common SQL dialects\r\n */\r\nexport const SQLDialects = {\r\n  postgres: {\r\n    placeholder: (i: number) => `$${i}`,\r\n    upsert: (table: string, columns: string[], conflictColumn: string) =>\r\n      `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${columns.map((_, i) => `$${i + 1}`).join(', ')}) ` +\r\n      `ON CONFLICT (${conflictColumn}) DO UPDATE SET ${columns.filter(c => c !== conflictColumn).map((c, _i) => `${c} = EXCLUDED.${c}`).join(', ')}`,\r\n    now: () => 'NOW()',\r\n  },\r\n  mysql: {\r\n    placeholder: () => '?',\r\n    upsert: (table: string, columns: string[], conflictColumn: string) =>\r\n      `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${columns.map(() => '?').join(', ')}) ` +\r\n      `ON DUPLICATE KEY UPDATE ${columns.filter(c => c !== conflictColumn).map(c => `${c} = VALUES(${c})`).join(', ')}`,\r\n    now: () => 'NOW()',\r\n  },\r\n  sqlite: {\r\n    placeholder: () => '?',\r\n    upsert: (table: string, columns: string[], _conflictColumn: string) =>\r\n      `INSERT OR REPLACE INTO ${table} (${columns.join(', ')}) VALUES (${columns.map(() => '?').join(', ')})`,\r\n    now: () => \"datetime('now')\",\r\n  },\r\n} satisfies Record<string, SQLDialect>;\r\n\r\n/**\r\n * SQL Storage configuration\r\n */\r\nexport interface SQLStorageConfig {\r\n  executor: SQLExecutor;\r\n  dialect: SQLDialect;\r\n  tableName: string;\r\n  autoCreateTable?: boolean;\r\n}\r\n\r\n/**\r\n * SQL Storage implementation\r\n */\r\nexport class SQLStorage implements RealityStorage {\r\n  private executor: SQLExecutor;\r\n  private dialect: SQLDialect;\r\n  private tableName: string;\r\n  private initialized = false;\r\n\r\n  constructor(config: SQLStorageConfig) {\r\n    this.executor = config.executor;\r\n    this.dialect = config.dialect;\r\n    this.tableName = config.tableName;\r\n\r\n    if (config.autoCreateTable) {\r\n      this.ensureTable();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure the table exists\r\n   */\r\n  private async ensureTable(): Promise<void> {\r\n    if (this.initialized) return;\r\n\r\n    const sql = `\r\n      CREATE TABLE IF NOT EXISTS ${this.tableName} (\r\n        key VARCHAR(255) PRIMARY KEY,\r\n        version BIGINT NOT NULL,\r\n        hash VARCHAR(64) NOT NULL,\r\n        updated_at BIGINT NOT NULL\r\n      )\r\n    `;\r\n\r\n    await this.executor.execute(sql);\r\n    \r\n    // Create index on version for efficient listChangedSince queries\r\n    const indexSql = `\r\n      CREATE INDEX IF NOT EXISTS idx_${this.tableName}_version \r\n      ON ${this.tableName} (version)\r\n    `;\r\n    \r\n    try {\r\n      await this.executor.execute(indexSql);\r\n    } catch {\r\n      // Index creation may fail on some databases, that's okay\r\n    }\r\n\r\n    this.initialized = true;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `SELECT key, version, hash, updated_at FROM ${this.tableName} WHERE key = ${this.dialect.placeholder(1)}`;\r\n    const row = await this.executor.executeOne<{\r\n      key: string;\r\n      version: number;\r\n      hash: string;\r\n      updated_at: number;\r\n    }>(sql, [key]);\r\n\r\n    if (!row) return null;\r\n\r\n    return {\r\n      key: row.key,\r\n      version: Number(row.version),\r\n      hash: row.hash,\r\n      updatedAt: Number(row.updated_at),\r\n    };\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = this.dialect.upsert(\r\n      this.tableName,\r\n      ['key', 'version', 'hash', 'updated_at'],\r\n      'key'\r\n    );\r\n\r\n    await this.executor.execute(sql, [meta.key, meta.version, meta.hash, meta.updatedAt]);\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    await this.ensureTable();\r\n    \r\n    return this.executor.transaction(async (tx) => {\r\n      // Get current max version\r\n      const maxSql = `SELECT COALESCE(MAX(version), 0) as max_version FROM ${this.tableName}`;\r\n      const maxResult = await tx.executeOne<{ max_version: number }>(maxSql);\r\n      const newVersion = (maxResult?.max_version ?? 0) + 1;\r\n\r\n      const meta: RealityNodeMeta = {\r\n        key,\r\n        version: newVersion,\r\n        hash,\r\n        updatedAt: Date.now(),\r\n      };\r\n\r\n      const upsertSql = this.dialect.upsert(\r\n        this.tableName,\r\n        ['key', 'version', 'hash', 'updated_at'],\r\n        'key'\r\n      );\r\n\r\n      await tx.execute(upsertSql, [meta.key, meta.version, meta.hash, meta.updatedAt]);\r\n\r\n      return meta;\r\n    });\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `\r\n      SELECT key, version, hash, updated_at \r\n      FROM ${this.tableName} \r\n      WHERE version > ${this.dialect.placeholder(1)}\r\n      ORDER BY version ASC\r\n    `;\r\n\r\n    const rows = await this.executor.execute<{\r\n      key: string;\r\n      version: number;\r\n      hash: string;\r\n      updated_at: number;\r\n    }>(sql, [version]);\r\n\r\n    return rows.map((row) => ({\r\n      key: row.key,\r\n      version: Number(row.version),\r\n      hash: row.hash,\r\n      updatedAt: Number(row.updated_at),\r\n    }));\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    await this.ensureTable();\r\n    \r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    const placeholders = keys.map((_, i) => this.dialect.placeholder(i + 1)).join(', ');\r\n    const sql = `\r\n      SELECT key, version, hash, updated_at \r\n      FROM ${this.tableName} \r\n      WHERE key IN (${placeholders})\r\n    `;\r\n\r\n    const rows = await this.executor.execute<{\r\n      key: string;\r\n      version: number;\r\n      hash: string;\r\n      updated_at: number;\r\n    }>(sql, keys);\r\n\r\n    const result = new Map<string, RealityNodeMeta>();\r\n    for (const row of rows) {\r\n      result.set(row.key, {\r\n        key: row.key,\r\n        version: Number(row.version),\r\n        hash: row.hash,\r\n        updatedAt: Number(row.updated_at),\r\n      });\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `SELECT COALESCE(MAX(version), 0) as max_version FROM ${this.tableName}`;\r\n    const result = await this.executor.executeOne<{ max_version: number }>(sql);\r\n    return result?.max_version ?? 0;\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    await this.ensureTable();\r\n    \r\n    const sql = `DELETE FROM ${this.tableName} WHERE key = ${this.dialect.placeholder(1)}`;\r\n    await this.executor.execute(sql, [key]);\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      await this.executor.executeOne('SELECT 1');\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create SQL storage with a specific dialect\r\n */\r\nexport function createSQLStorage(config: SQLStorageConfig): SQLStorage {\r\n  return new SQLStorage(config);\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Drizzle Storage Adapter\r\n * \r\n * First-class Drizzle ORM integration for Reality storage.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * Drizzle table schema definition\r\n * \r\n * Users should define this in their Drizzle schema:\r\n * \r\n * ```typescript\r\n * import { pgTable, varchar, bigint, index } from 'drizzle-orm/pg-core';\r\n * \r\n * export const realityNodes = pgTable('reality_nodes', {\r\n *   key: varchar('key', { length: 255 }).primaryKey(),\r\n *   version: bigint('version', { mode: 'number' }).notNull(),\r\n *   hash: varchar('hash', { length: 64 }).notNull(),\r\n *   updatedAt: bigint('updated_at', { mode: 'number' }).notNull(),\r\n * }, (table) => ({\r\n *   versionIdx: index('version_idx').on(table.version),\r\n * }));\r\n * ```\r\n */\r\nexport interface DrizzleRealityTable {\r\n  key: unknown;\r\n  version: unknown;\r\n  hash: unknown;\r\n  updatedAt: unknown;\r\n}\r\n\r\n/**\r\n * Drizzle database interface\r\n */\r\nexport interface DrizzleDB {\r\n  select: <T>(fields?: T) => {\r\n    from: (table: unknown) => {\r\n      where: (condition: unknown) => Promise<T[]>;\r\n      orderBy: (column: unknown) => {\r\n        where: (condition: unknown) => Promise<T[]>;\r\n      };\r\n    };\r\n  };\r\n  insert: (table: unknown) => {\r\n    values: (values: unknown) => {\r\n      onConflictDoUpdate: (config: unknown) => Promise<void>;\r\n    };\r\n  };\r\n  delete: (table: unknown) => {\r\n    where: (condition: unknown) => Promise<void>;\r\n  };\r\n  transaction: <T>(fn: (tx: DrizzleDB) => Promise<T>) => Promise<T>;\r\n}\r\n\r\n/**\r\n * Drizzle Storage configuration\r\n */\r\nexport interface DrizzleStorageConfig {\r\n  /** Drizzle database instance */\r\n  db: DrizzleDB;\r\n  /** Drizzle table reference */\r\n  table: DrizzleRealityTable;\r\n  /** SQL operators from drizzle-orm */\r\n  operators: {\r\n    eq: (column: unknown, value: unknown) => unknown;\r\n    gt: (column: unknown, value: unknown) => unknown;\r\n    inArray: (column: unknown, values: unknown[]) => unknown;\r\n    max: (column: unknown) => unknown;\r\n    asc: (column: unknown) => unknown;\r\n  };\r\n}\r\n\r\n/**\r\n * Drizzle Storage implementation\r\n * \r\n * @example\r\n * ```typescript\r\n * import { drizzle } from 'drizzle-orm/node-postgres';\r\n * import { eq, gt, inArray, max, asc } from 'drizzle-orm';\r\n * import { realityNodes } from './schema';\r\n * \r\n * const db = drizzle(pool);\r\n * \r\n * const storage = createDrizzleStorage({\r\n *   db,\r\n *   table: realityNodes,\r\n *   operators: { eq, gt, inArray, max, asc },\r\n * });\r\n * ```\r\n */\r\nexport class DrizzleStorage implements RealityStorage {\r\n  private db: DrizzleDB;\r\n  private table: DrizzleRealityTable;\r\n  private ops: DrizzleStorageConfig['operators'];\r\n\r\n  constructor(config: DrizzleStorageConfig) {\r\n    this.db = config.db;\r\n    this.table = config.table;\r\n    this.ops = config.operators;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    const results = await this.db\r\n      .select()\r\n      .from(this.table)\r\n      .where(this.ops.eq(this.table.key, key)) as Array<{\r\n        key: string;\r\n        version: number;\r\n        hash: string;\r\n        updatedAt: number;\r\n      }>;\r\n\r\n    if (results.length === 0) return null;\r\n\r\n    const row = results[0]!;\r\n    return {\r\n      key: row.key,\r\n      version: row.version,\r\n      hash: row.hash,\r\n      updatedAt: row.updatedAt,\r\n    };\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    await this.db\r\n      .insert(this.table)\r\n      .values({\r\n        key: meta.key,\r\n        version: meta.version,\r\n        hash: meta.hash,\r\n        updatedAt: meta.updatedAt,\r\n      })\r\n      .onConflictDoUpdate({\r\n        target: this.table.key,\r\n        set: {\r\n          version: meta.version,\r\n          hash: meta.hash,\r\n          updatedAt: meta.updatedAt,\r\n        },\r\n      });\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    return this.db.transaction(async (tx) => {\r\n      // Get current max version\r\n      const maxResults = await tx\r\n        .select({ maxVersion: this.ops.max(this.table.version) })\r\n        .from(this.table) as unknown as Array<{ maxVersion: number | null }>;\r\n\r\n      const maxVersion = maxResults[0]?.maxVersion ?? 0;\r\n      const newVersion = maxVersion + 1;\r\n\r\n      const meta: RealityNodeMeta = {\r\n        key,\r\n        version: newVersion,\r\n        hash,\r\n        updatedAt: Date.now(),\r\n      };\r\n\r\n      await tx\r\n        .insert(this.table)\r\n        .values({\r\n          key: meta.key,\r\n          version: meta.version,\r\n          hash: meta.hash,\r\n          updatedAt: meta.updatedAt,\r\n        })\r\n        .onConflictDoUpdate({\r\n          target: this.table.key,\r\n          set: {\r\n            version: meta.version,\r\n            hash: meta.hash,\r\n            updatedAt: meta.updatedAt,\r\n          },\r\n        });\r\n\r\n      return meta;\r\n    });\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    const results = await this.db\r\n      .select()\r\n      .from(this.table)\r\n      .orderBy(this.ops.asc(this.table.version))\r\n      .where(this.ops.gt(this.table.version, version)) as Array<{\r\n        key: string;\r\n        version: number;\r\n        hash: string;\r\n        updatedAt: number;\r\n      }>;\r\n\r\n    return results.map((row) => ({\r\n      key: row.key,\r\n      version: row.version,\r\n      hash: row.hash,\r\n      updatedAt: row.updatedAt,\r\n    }));\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    const results = await this.db\r\n      .select()\r\n      .from(this.table)\r\n      .where(this.ops.inArray(this.table.key, keys)) as Array<{\r\n        key: string;\r\n        version: number;\r\n        hash: string;\r\n        updatedAt: number;\r\n      }>;\r\n\r\n    const map = new Map<string, RealityNodeMeta>();\r\n    for (const row of results) {\r\n      map.set(row.key, {\r\n        key: row.key,\r\n        version: row.version,\r\n        hash: row.hash,\r\n        updatedAt: row.updatedAt,\r\n      });\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    const results = await this.db\r\n      .select({ maxVersion: this.ops.max(this.table.version) })\r\n      .from(this.table) as unknown as Array<{ maxVersion: number | null }>;\r\n\r\n    return results[0]?.maxVersion ?? 0;\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    await this.db.delete(this.table).where(this.ops.eq(this.table.key, key));\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      await this.db.select().from(this.table).where(this.ops.eq(1, 0));\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create Drizzle storage adapter\r\n */\r\nexport function createDrizzleStorage(config: DrizzleStorageConfig): DrizzleStorage {\r\n  return new DrizzleStorage(config);\r\n}\r\n\r\n/**\r\n * Generate Drizzle schema for PostgreSQL\r\n * \r\n * Copy this to your schema file:\r\n */\r\nexport const DRIZZLE_POSTGRES_SCHEMA = `\r\nimport { pgTable, varchar, bigint, index } from 'drizzle-orm/pg-core';\r\n\r\nexport const realityNodes = pgTable('reality_nodes', {\r\n  key: varchar('key', { length: 255 }).primaryKey(),\r\n  version: bigint('version', { mode: 'number' }).notNull(),\r\n  hash: varchar('hash', { length: 64 }).notNull(),\r\n  updatedAt: bigint('updated_at', { mode: 'number' }).notNull(),\r\n}, (table) => ({\r\n  versionIdx: index('version_idx').on(table.version),\r\n}));\r\n`;\r\n\r\n/**\r\n * Generate Drizzle schema for MySQL\r\n */\r\nexport const DRIZZLE_MYSQL_SCHEMA = `\r\nimport { mysqlTable, varchar, bigint, index } from 'drizzle-orm/mysql-core';\r\n\r\nexport const realityNodes = mysqlTable('reality_nodes', {\r\n  key: varchar('key', { length: 255 }).primaryKey(),\r\n  version: bigint('version', { mode: 'number' }).notNull(),\r\n  hash: varchar('hash', { length: 64 }).notNull(),\r\n  updatedAt: bigint('updated_at', { mode: 'number' }).notNull(),\r\n}, (table) => ({\r\n  versionIdx: index('version_idx').on(table.version),\r\n}));\r\n`;\r\n\r\n/**\r\n * Generate Drizzle schema for SQLite\r\n */\r\nexport const DRIZZLE_SQLITE_SCHEMA = `\r\nimport { sqliteTable, text, integer, index } from 'drizzle-orm/sqlite-core';\r\n\r\nexport const realityNodes = sqliteTable('reality_nodes', {\r\n  key: text('key').primaryKey(),\r\n  version: integer('version').notNull(),\r\n  hash: text('hash').notNull(),\r\n  updatedAt: integer('updated_at').notNull(),\r\n}, (table) => ({\r\n  versionIdx: index('version_idx').on(table.version),\r\n}));\r\n`;\r\n","/**\r\n * @rootlodge/reality-server - Prisma Storage Adapter\r\n * \r\n * Prisma ORM integration for Reality storage.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * Prisma client interface (minimal subset)\r\n */\r\nexport interface PrismaClient {\r\n  realityNode: {\r\n    findUnique: (args: { where: { key: string } }) => Promise<PrismaRealityNode | null>;\r\n    findMany: (args: { where?: unknown; orderBy?: unknown }) => Promise<PrismaRealityNode[]>;\r\n    upsert: (args: {\r\n      where: { key: string };\r\n      create: PrismaRealityNodeInput;\r\n      update: PrismaRealityNodeInput;\r\n    }) => Promise<PrismaRealityNode>;\r\n    delete: (args: { where: { key: string } }) => Promise<void>;\r\n    aggregate: (args: { _max: { version: true } }) => Promise<{ _max: { version: number | null } }>;\r\n  };\r\n  $transaction: <T>(fn: (tx: PrismaClient) => Promise<T>) => Promise<T>;\r\n  $queryRaw: <T>(query: TemplateStringsArray, ...values: unknown[]) => Promise<T>;\r\n}\r\n\r\ninterface PrismaRealityNode {\r\n  key: string;\r\n  version: bigint | number;\r\n  hash: string;\r\n  updatedAt: bigint | number;\r\n}\r\n\r\ninterface PrismaRealityNodeInput {\r\n  key: string;\r\n  version: bigint | number;\r\n  hash: string;\r\n  updatedAt: bigint | number;\r\n}\r\n\r\n/**\r\n * Prisma Storage configuration\r\n */\r\nexport interface PrismaStorageConfig {\r\n  /** Prisma client instance */\r\n  prisma: PrismaClient;\r\n}\r\n\r\n/**\r\n * Prisma Storage implementation\r\n * \r\n * @example\r\n * ```typescript\r\n * import { PrismaClient } from '@prisma/client';\r\n * import { createPrismaStorage } from '@rootlodge/reality-server/storage';\r\n * \r\n * const prisma = new PrismaClient();\r\n * const storage = createPrismaStorage({ prisma });\r\n * ```\r\n * \r\n * Required Prisma schema:\r\n * ```prisma\r\n * model RealityNode {\r\n *   key       String   @id @db.VarChar(255)\r\n *   version   BigInt\r\n *   hash      String   @db.VarChar(64)\r\n *   updatedAt BigInt   @map(\"updated_at\")\r\n * \r\n *   @@index([version])\r\n *   @@map(\"reality_nodes\")\r\n * }\r\n * ```\r\n */\r\nexport class PrismaStorage implements RealityStorage {\r\n  private prisma: PrismaClient;\r\n\r\n  constructor(config: PrismaStorageConfig) {\r\n    this.prisma = config.prisma;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    const node = await this.prisma.realityNode.findUnique({\r\n      where: { key },\r\n    });\r\n\r\n    if (!node) return null;\r\n\r\n    return {\r\n      key: node.key,\r\n      version: Number(node.version),\r\n      hash: node.hash,\r\n      updatedAt: Number(node.updatedAt),\r\n    };\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    await this.prisma.realityNode.upsert({\r\n      where: { key: meta.key },\r\n      create: {\r\n        key: meta.key,\r\n        version: BigInt(meta.version),\r\n        hash: meta.hash,\r\n        updatedAt: BigInt(meta.updatedAt),\r\n      },\r\n      update: {\r\n        key: meta.key,\r\n        version: BigInt(meta.version),\r\n        hash: meta.hash,\r\n        updatedAt: BigInt(meta.updatedAt),\r\n      },\r\n    });\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    return this.prisma.$transaction(async (tx) => {\r\n      // Get current max version\r\n      const result = await tx.realityNode.aggregate({\r\n        _max: { version: true },\r\n      });\r\n\r\n      const maxVersion = result._max.version ?? BigInt(0);\r\n      const newVersion = Number(maxVersion) + 1;\r\n\r\n      const meta: RealityNodeMeta = {\r\n        key,\r\n        version: newVersion,\r\n        hash,\r\n        updatedAt: Date.now(),\r\n      };\r\n\r\n      await tx.realityNode.upsert({\r\n        where: { key },\r\n        create: {\r\n          key: meta.key,\r\n          version: BigInt(meta.version),\r\n          hash: meta.hash,\r\n          updatedAt: BigInt(meta.updatedAt),\r\n        },\r\n        update: {\r\n          key: meta.key,\r\n          version: BigInt(meta.version),\r\n          hash: meta.hash,\r\n          updatedAt: BigInt(meta.updatedAt),\r\n        },\r\n      });\r\n\r\n      return meta;\r\n    });\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    const nodes = await this.prisma.realityNode.findMany({\r\n      where: {\r\n        version: { gt: BigInt(version) },\r\n      },\r\n      orderBy: {\r\n        version: 'asc',\r\n      },\r\n    });\r\n\r\n    return nodes.map((node) => ({\r\n      key: node.key,\r\n      version: Number(node.version),\r\n      hash: node.hash,\r\n      updatedAt: Number(node.updatedAt),\r\n    }));\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    const nodes = await this.prisma.realityNode.findMany({\r\n      where: {\r\n        key: { in: keys },\r\n      },\r\n    });\r\n\r\n    const map = new Map<string, RealityNodeMeta>();\r\n    for (const node of nodes) {\r\n      map.set(node.key, {\r\n        key: node.key,\r\n        version: Number(node.version),\r\n        hash: node.hash,\r\n        updatedAt: Number(node.updatedAt),\r\n      });\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    const result = await this.prisma.realityNode.aggregate({\r\n      _max: { version: true },\r\n    });\r\n\r\n    return Number(result._max.version ?? 0);\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    try {\r\n      await this.prisma.realityNode.delete({\r\n        where: { key },\r\n      });\r\n    } catch {\r\n      // Ignore if not found\r\n    }\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      await this.prisma.$queryRaw`SELECT 1`;\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create Prisma storage adapter\r\n */\r\nexport function createPrismaStorage(config: PrismaStorageConfig): PrismaStorage {\r\n  return new PrismaStorage(config);\r\n}\r\n\r\n/**\r\n * Prisma schema for Reality nodes\r\n */\r\nexport const PRISMA_SCHEMA = `\r\nmodel RealityNode {\r\n  key       String   @id @db.VarChar(255)\r\n  version   BigInt\r\n  hash      String   @db.VarChar(64)\r\n  updatedAt BigInt   @map(\"updated_at\")\r\n\r\n  @@index([version])\r\n  @@map(\"reality_nodes\")\r\n}\r\n`;\r\n","/**\r\n * @rootlodge/reality-server - DynamoDB Storage Adapter\r\n * \r\n * AWS DynamoDB storage adapter for serverless deployments.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../../types';\r\n\r\n/**\r\n * DynamoDB client interface (minimal subset matching AWS SDK v3)\r\n */\r\nexport interface DynamoDBClient {\r\n  send: (command: unknown) => Promise<unknown>;\r\n}\r\n\r\n/**\r\n * DynamoDB document interface\r\n */\r\ninterface DynamoDBDocument {\r\n  key: { S: string };\r\n  version: { N: string };\r\n  hash: { S: string };\r\n  updatedAt: { N: string };\r\n}\r\n\r\n/**\r\n * DynamoDB Storage configuration\r\n */\r\nexport interface DynamoDBStorageConfig {\r\n  /** DynamoDB client instance */\r\n  client: DynamoDBClient;\r\n  /** Table name */\r\n  tableName: string;\r\n  /** Optional: GSI name for version queries */\r\n  versionIndexName?: string;\r\n}\r\n\r\n/**\r\n * DynamoDB Storage implementation\r\n * \r\n * Required table structure:\r\n * - Partition Key: key (String)\r\n * - GSI on version (Number) for efficient listChangedSince queries\r\n * \r\n * @example\r\n * ```typescript\r\n * import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\r\n * import { createDynamoDBStorage } from '@rootlodge/reality-server/storage';\r\n * \r\n * const client = new DynamoDBClient({ region: 'us-east-1' });\r\n * const storage = createDynamoDBStorage({\r\n *   client,\r\n *   tableName: 'reality-nodes',\r\n *   versionIndexName: 'version-index',\r\n * });\r\n * ```\r\n */\r\nexport class DynamoDBStorage implements RealityStorage {\r\n  private client: DynamoDBClient;\r\n  private tableName: string;\r\n  private versionIndexName?: string;\r\n\r\n  constructor(config: DynamoDBStorageConfig) {\r\n    this.client = config.client;\r\n    this.tableName = config.tableName;\r\n    this.versionIndexName = config.versionIndexName;\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Key: {\r\n        key: { S: key },\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createGetItemCommand(command)) as {\r\n      Item?: DynamoDBDocument;\r\n    };\r\n\r\n    if (!result.Item) return null;\r\n\r\n    return this.documentToMeta(result.Item);\r\n  }\r\n\r\n  async setNode(meta: RealityNodeMeta): Promise<void> {\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Item: this.metaToDocument(meta),\r\n    };\r\n\r\n    await this.client.send(this.createPutItemCommand(command));\r\n  }\r\n\r\n  async incrementVersion(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    // Get current max version\r\n    const maxVersion = await this.getMaxVersion();\r\n    const newVersion = maxVersion + 1;\r\n\r\n    const meta: RealityNodeMeta = {\r\n      key,\r\n      version: newVersion,\r\n      hash,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    // Use conditional write to ensure atomicity\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Item: this.metaToDocument(meta),\r\n      ConditionExpression: 'attribute_not_exists(#key) OR #version < :newVersion',\r\n      ExpressionAttributeNames: {\r\n        '#key': 'key',\r\n        '#version': 'version',\r\n      },\r\n      ExpressionAttributeValues: {\r\n        ':newVersion': { N: String(newVersion) },\r\n      },\r\n    };\r\n\r\n    try {\r\n      await this.client.send(this.createPutItemCommand(command));\r\n      return meta;\r\n    } catch (error) {\r\n      // Retry with incremented version if conditional check failed\r\n      if ((error as { name?: string }).name === 'ConditionalCheckFailedException') {\r\n        return this.incrementVersion(key, hash);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async listChangedSince(version: number): Promise<RealityNodeMeta[]> {\r\n    if (this.versionIndexName) {\r\n      // Use GSI for efficient query\r\n      const command = {\r\n        TableName: this.tableName,\r\n        IndexName: this.versionIndexName,\r\n        KeyConditionExpression: '#version > :version',\r\n        ExpressionAttributeNames: {\r\n          '#version': 'version',\r\n        },\r\n        ExpressionAttributeValues: {\r\n          ':version': { N: String(version) },\r\n        },\r\n      };\r\n\r\n      const result = await this.client.send(this.createQueryCommand(command)) as {\r\n        Items?: DynamoDBDocument[];\r\n      };\r\n\r\n      return (result.Items ?? [])\r\n        .map((item) => this.documentToMeta(item))\r\n        .sort((a, b) => a.version - b.version);\r\n    }\r\n\r\n    // Fallback: scan the entire table (not recommended for large tables)\r\n    const command = {\r\n      TableName: this.tableName,\r\n      FilterExpression: '#version > :version',\r\n      ExpressionAttributeNames: {\r\n        '#version': 'version',\r\n      },\r\n      ExpressionAttributeValues: {\r\n        ':version': { N: String(version) },\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createScanCommand(command)) as {\r\n      Items?: DynamoDBDocument[];\r\n    };\r\n\r\n    return (result.Items ?? [])\r\n      .map((item) => this.documentToMeta(item))\r\n      .sort((a, b) => a.version - b.version);\r\n  }\r\n\r\n  async getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>> {\r\n    if (keys.length === 0) {\r\n      return new Map();\r\n    }\r\n\r\n    // BatchGetItem for efficiency\r\n    const command = {\r\n      RequestItems: {\r\n        [this.tableName]: {\r\n          Keys: keys.map((key) => ({ key: { S: key } })),\r\n        },\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createBatchGetItemCommand(command)) as {\r\n      Responses?: { [tableName: string]: DynamoDBDocument[] };\r\n    };\r\n\r\n    const items = result.Responses?.[this.tableName] ?? [];\r\n    const map = new Map<string, RealityNodeMeta>();\r\n\r\n    for (const item of items) {\r\n      const meta = this.documentToMeta(item);\r\n      map.set(meta.key, meta);\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  async getMaxVersion(): Promise<number> {\r\n    // Scan to find max version (consider using a separate counter item for production)\r\n    const command = {\r\n      TableName: this.tableName,\r\n      ProjectionExpression: '#version',\r\n      ExpressionAttributeNames: {\r\n        '#version': 'version',\r\n      },\r\n    };\r\n\r\n    const result = await this.client.send(this.createScanCommand(command)) as {\r\n      Items?: Array<{ version: { N: string } }>;\r\n    };\r\n\r\n    const items = result.Items ?? [];\r\n    if (items.length === 0) return 0;\r\n\r\n    return Math.max(...items.map((item) => parseInt(item.version.N, 10)));\r\n  }\r\n\r\n  async deleteNode(key: string): Promise<void> {\r\n    const command = {\r\n      TableName: this.tableName,\r\n      Key: {\r\n        key: { S: key },\r\n      },\r\n    };\r\n\r\n    await this.client.send(this.createDeleteItemCommand(command));\r\n  }\r\n\r\n  async isHealthy(): Promise<boolean> {\r\n    try {\r\n      const command = {\r\n        TableName: this.tableName,\r\n        Limit: 1,\r\n      };\r\n      await this.client.send(this.createScanCommand(command));\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private documentToMeta(doc: DynamoDBDocument): RealityNodeMeta {\r\n    return {\r\n      key: doc.key.S,\r\n      version: parseInt(doc.version.N, 10),\r\n      hash: doc.hash.S,\r\n      updatedAt: parseInt(doc.updatedAt.N, 10),\r\n    };\r\n  }\r\n\r\n  private metaToDocument(meta: RealityNodeMeta): DynamoDBDocument {\r\n    return {\r\n      key: { S: meta.key },\r\n      version: { N: String(meta.version) },\r\n      hash: { S: meta.hash },\r\n      updatedAt: { N: String(meta.updatedAt) },\r\n    };\r\n  }\r\n\r\n  // Command factory methods (to be replaced with actual AWS SDK commands)\r\n  private createGetItemCommand(input: unknown): { __type: 'GetItem'; input: unknown } {\r\n    return { __type: 'GetItem', input };\r\n  }\r\n\r\n  private createPutItemCommand(input: unknown): { __type: 'PutItem'; input: unknown } {\r\n    return { __type: 'PutItem', input };\r\n  }\r\n\r\n  private createDeleteItemCommand(input: unknown): { __type: 'DeleteItem'; input: unknown } {\r\n    return { __type: 'DeleteItem', input };\r\n  }\r\n\r\n  private createQueryCommand(input: unknown): { __type: 'Query'; input: unknown } {\r\n    return { __type: 'Query', input };\r\n  }\r\n\r\n  private createScanCommand(input: unknown): { __type: 'Scan'; input: unknown } {\r\n    return { __type: 'Scan', input };\r\n  }\r\n\r\n  private createBatchGetItemCommand(input: unknown): { __type: 'BatchGetItem'; input: unknown } {\r\n    return { __type: 'BatchGetItem', input };\r\n  }\r\n}\r\n\r\n/**\r\n * Create DynamoDB storage adapter\r\n */\r\nexport function createDynamoDBStorage(config: DynamoDBStorageConfig): DynamoDBStorage {\r\n  return new DynamoDBStorage(config);\r\n}\r\n\r\n/**\r\n * CloudFormation template for DynamoDB table\r\n */\r\nexport const DYNAMODB_CLOUDFORMATION = `\r\nAWSTemplateFormatVersion: '2010-09-09'\r\nDescription: Reality DynamoDB Table\r\n\r\nResources:\r\n  RealityNodesTable:\r\n    Type: AWS::DynamoDB::Table\r\n    Properties:\r\n      TableName: reality-nodes\r\n      BillingMode: PAY_PER_REQUEST\r\n      AttributeDefinitions:\r\n        - AttributeName: key\r\n          AttributeType: S\r\n        - AttributeName: version\r\n          AttributeType: N\r\n      KeySchema:\r\n        - AttributeName: key\r\n          KeyType: HASH\r\n      GlobalSecondaryIndexes:\r\n        - IndexName: version-index\r\n          KeySchema:\r\n            - AttributeName: version\r\n              KeyType: HASH\r\n          Projection:\r\n            ProjectionType: ALL\r\n`;\r\n","/**\r\n * @rootlodge/reality-server - Invalidation Adapters\r\n * \r\n * Optional adapters for database integration.\r\n * Reality does NOT own your data - these are just helpers!\r\n * \r\n * Use these to:\r\n * - Auto-invalidate when your DB changes\r\n * - Hook into transactions\r\n * - Get advisory notifications\r\n * \r\n * You DON'T need these to use Reality!\r\n */\r\n\r\nimport type { RealityInvalidationAdapter } from '../types';\r\n\r\n/**\r\n * Create a simple callback-based invalidation adapter\r\n * \r\n * @example\r\n * ```typescript\r\n * const adapter = createCallbackInvalidationAdapter({\r\n *   onInvalidate: async (keys) => {\r\n *     console.log('Keys invalidated:', keys);\r\n *     // Notify your cache, broadcast to clients, etc.\r\n *   },\r\n * });\r\n * \r\n * server.setInvalidationAdapter(adapter);\r\n * ```\r\n */\r\nexport function createCallbackInvalidationAdapter(options: {\r\n  onInvalidate: (keys: string[]) => Promise<void>;\r\n  beforeTransaction?: <T>(fn: () => Promise<T>) => Promise<T>;\r\n  afterTransaction?: (affectedKeys: string[]) => Promise<void>;\r\n}): RealityInvalidationAdapter {\r\n  return {\r\n    onInvalidate: options.onInvalidate,\r\n    beforeTransaction: options.beforeTransaction,\r\n    afterTransaction: options.afterTransaction,\r\n  };\r\n}\r\n\r\n/**\r\n * Drizzle ORM invalidation adapter\r\n * \r\n * Auto-invalidates Reality keys when Drizzle transactions complete.\r\n * \r\n * @example\r\n * ```typescript\r\n * import { drizzle } from 'drizzle-orm/postgres-js';\r\n * import { createDrizzleInvalidationAdapter } from '@rootlodge/reality-server';\r\n * \r\n * const db = drizzle(client);\r\n * const reality = new RealityServer({ serverId: 'server-1' });\r\n * \r\n * const adapter = createDrizzleInvalidationAdapter({\r\n *   db,\r\n *   keyExtractor: (tableName, operation, data) => {\r\n *     if (tableName === 'messages') {\r\n *       return [`chat:room:${data.roomId}`];\r\n *     }\r\n *     return [];\r\n *   },\r\n * });\r\n * \r\n * reality.setInvalidationAdapter(adapter);\r\n * ```\r\n */\r\nexport interface DrizzleInvalidationConfig {\r\n  /** Drizzle database instance */\r\n  db: unknown;\r\n  /** Extract Reality keys from table/operation/data */\r\n  keyExtractor: (\r\n    tableName: string,\r\n    operation: 'insert' | 'update' | 'delete',\r\n    data: unknown\r\n  ) => string[];\r\n  /** Custom invalidation handler */\r\n  onInvalidate?: (keys: string[]) => Promise<void>;\r\n}\r\n\r\nexport function createDrizzleInvalidationAdapter(\r\n  config: DrizzleInvalidationConfig\r\n): RealityInvalidationAdapter {\r\n  const pendingKeys = new Set<string>();\r\n  \r\n  return {\r\n    onInvalidate: async (keys: string[]) => {\r\n      if (config.onInvalidate) {\r\n        await config.onInvalidate(keys);\r\n      }\r\n    },\r\n    \r\n    beforeTransaction: async <T>(fn: () => Promise<T>): Promise<T> => {\r\n      pendingKeys.clear();\r\n      return fn();\r\n    },\r\n    \r\n    afterTransaction: async (affectedKeys: string[]) => {\r\n      for (const key of affectedKeys) {\r\n        pendingKeys.add(key);\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Prisma ORM invalidation adapter\r\n * \r\n * Auto-invalidates Reality keys when Prisma transactions complete.\r\n * \r\n * @example\r\n * ```typescript\r\n * import { PrismaClient } from '@prisma/client';\r\n * import { createPrismaInvalidationAdapter } from '@rootlodge/reality-server';\r\n * \r\n * const prisma = new PrismaClient();\r\n * const reality = new RealityServer({ serverId: 'server-1' });\r\n * \r\n * const adapter = createPrismaInvalidationAdapter({\r\n *   prisma,\r\n *   keyExtractor: (model, operation, data) => {\r\n *     if (model === 'Message') {\r\n *       return [`chat:room:${data.roomId}`];\r\n *     }\r\n *     return [];\r\n *   },\r\n * });\r\n * \r\n * reality.setInvalidationAdapter(adapter);\r\n * ```\r\n */\r\nexport interface PrismaInvalidationConfig {\r\n  /** Prisma client instance */\r\n  prisma: unknown;\r\n  /** Extract Reality keys from model/operation/data */\r\n  keyExtractor: (\r\n    model: string,\r\n    operation: 'create' | 'update' | 'delete' | 'upsert',\r\n    data: unknown\r\n  ) => string[];\r\n  /** Custom invalidation handler */\r\n  onInvalidate?: (keys: string[]) => Promise<void>;\r\n}\r\n\r\nexport function createPrismaInvalidationAdapter(\r\n  config: PrismaInvalidationConfig\r\n): RealityInvalidationAdapter {\r\n  return {\r\n    onInvalidate: async (keys: string[]) => {\r\n      if (config.onInvalidate) {\r\n        await config.onInvalidate(keys);\r\n      }\r\n    },\r\n    \r\n    beforeTransaction: async <T>(fn: () => Promise<T>): Promise<T> => {\r\n      return fn();\r\n    },\r\n    \r\n    afterTransaction: async (_affectedKeys: string[]) => {\r\n      // Keys are typically extracted at the point of operation\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Generic SQL invalidation adapter\r\n * \r\n * For use with raw SQL or other ORMs.\r\n * \r\n * @example\r\n * ```typescript\r\n * const adapter = createSQLInvalidationAdapter({\r\n *   keyExtractor: (sql, params) => {\r\n *     // Parse SQL to extract affected tables/keys\r\n *     if (sql.includes('INSERT INTO messages')) {\r\n *       return [`chat:room:${params.roomId}`];\r\n *     }\r\n *     return [];\r\n *   },\r\n * });\r\n * ```\r\n */\r\nexport interface SQLInvalidationConfig {\r\n  /** Extract Reality keys from SQL query and params */\r\n  keyExtractor: (sql: string, params: unknown[]) => string[];\r\n  /** Custom invalidation handler */\r\n  onInvalidate?: (keys: string[]) => Promise<void>;\r\n}\r\n\r\nexport function createSQLInvalidationAdapter(\r\n  config: SQLInvalidationConfig\r\n): RealityInvalidationAdapter {\r\n  return {\r\n    onInvalidate: async (keys: string[]) => {\r\n      if (config.onInvalidate) {\r\n        await config.onInvalidate(keys);\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Composite adapter that combines multiple adapters\r\n * \r\n * @example\r\n * ```typescript\r\n * const adapter = createCompositeInvalidationAdapter([\r\n *   drizzleAdapter,\r\n *   loggingAdapter,\r\n *   cacheAdapter,\r\n * ]);\r\n * ```\r\n */\r\nexport function createCompositeInvalidationAdapter(\r\n  adapters: RealityInvalidationAdapter[]\r\n): RealityInvalidationAdapter {\r\n  return {\r\n    onInvalidate: async (keys: string[]) => {\r\n      await Promise.all(adapters.map(a => a.onInvalidate(keys)));\r\n    },\r\n    \r\n    beforeTransaction: async <T>(fn: () => Promise<T>): Promise<T> => {\r\n      // Chain beforeTransaction calls\r\n      let result: T;\r\n      const chain = adapters.reduceRight(\r\n        (next, adapter) => async () => {\r\n          if (adapter.beforeTransaction) {\r\n            return adapter.beforeTransaction(next);\r\n          }\r\n          return next();\r\n        },\r\n        fn\r\n      );\r\n      result = await chain();\r\n      return result;\r\n    },\r\n    \r\n    afterTransaction: async (affectedKeys: string[]) => {\r\n      await Promise.all(\r\n        adapters\r\n          .filter(a => a.afterTransaction)\r\n          .map(a => a.afterTransaction!(affectedKeys))\r\n      );\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Logging adapter for debugging\r\n */\r\nexport function createLoggingInvalidationAdapter(options: {\r\n  prefix?: string;\r\n  logger?: (message: string) => void;\r\n} = {}): RealityInvalidationAdapter {\r\n  const prefix = options.prefix ?? '[Reality]';\r\n  const log = options.logger ?? console.log;\r\n  \r\n  return {\r\n    onInvalidate: async (keys: string[]) => {\r\n      log(`${prefix} Invalidated: ${keys.join(', ')}`);\r\n    },\r\n    \r\n    beforeTransaction: async <T>(fn: () => Promise<T>): Promise<T> => {\r\n      log(`${prefix} Transaction starting`);\r\n      const result = await fn();\r\n      log(`${prefix} Transaction completed`);\r\n      return result;\r\n    },\r\n    \r\n    afterTransaction: async (affectedKeys: string[]) => {\r\n      log(`${prefix} Transaction affected: ${affectedKeys.join(', ')}`);\r\n    },\r\n  };\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Redis Accelerator\r\n * \r\n * Optional Redis layer for invalidation hints and mesh acceleration.\r\n * IMPORTANT: This is acceleration only - correctness MUST NOT depend on Redis.\r\n */\r\n\r\nimport type { RealityNodeMeta, GossipPayload } from '../types';\r\n\r\n/**\r\n * Redis client interface (minimal subset)\r\n */\r\nexport interface RedisClient {\r\n  get(key: string): Promise<string | null>;\r\n  set(key: string, value: string, options?: { EX?: number }): Promise<void>;\r\n  del(key: string): Promise<void>;\r\n  publish(channel: string, message: string): Promise<void>;\r\n  subscribe(channel: string, callback: (message: string) => void): Promise<void>;\r\n  unsubscribe(channel: string): Promise<void>;\r\n  ping(): Promise<string>;\r\n  quit(): Promise<void>;\r\n}\r\n\r\n/**\r\n * Redis accelerator configuration\r\n */\r\nexport interface RedisAcceleratorConfig {\r\n  /** Redis client instance */\r\n  client: RedisClient;\r\n  /** Key prefix for Reality data */\r\n  prefix?: string;\r\n  /** TTL for cached data in seconds */\r\n  ttl?: number;\r\n  /** Enable pub/sub for invalidation hints */\r\n  pubSubEnabled?: boolean;\r\n  /** Server ID for pub/sub filtering */\r\n  serverId?: string;\r\n  /** Debug logging */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Redis Accelerator\r\n * \r\n * Provides optional acceleration for:\r\n * - Invalidation hint propagation (pub/sub)\r\n * - Mesh gossip caching\r\n * - Hot node metadata caching\r\n * \r\n * CRITICAL: All operations are best-effort.\r\n * The system MUST work correctly without Redis.\r\n */\r\nexport class RedisAccelerator {\r\n  private client: RedisClient;\r\n  private prefix: string;\r\n  private ttl: number;\r\n  private pubSubEnabled: boolean;\r\n  private serverId: string;\r\n  private debug: boolean;\r\n  private invalidationHandlers: Set<(keys: string[], source: string) => void> = new Set();\r\n  private connected = false;\r\n\r\n  constructor(config: RedisAcceleratorConfig) {\r\n    this.client = config.client;\r\n    this.prefix = config.prefix ?? 'reality:';\r\n    this.ttl = config.ttl ?? 60;\r\n    this.pubSubEnabled = config.pubSubEnabled ?? true;\r\n    this.serverId = config.serverId ?? 'unknown';\r\n    this.debug = config.debug ?? false;\r\n  }\r\n\r\n  /**\r\n   * Initialize Redis connection and pub/sub\r\n   */\r\n  async connect(): Promise<boolean> {\r\n    try {\r\n      await this.client.ping();\r\n      this.connected = true;\r\n\r\n      if (this.pubSubEnabled) {\r\n        await this.setupPubSub();\r\n      }\r\n\r\n      if (this.debug) {\r\n        console.log('[Redis] Connected successfully');\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      if (this.debug) {\r\n        console.warn('[Redis] Connection failed:', error);\r\n      }\r\n      this.connected = false;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect from Redis\r\n   */\r\n  async disconnect(): Promise<void> {\r\n    try {\r\n      if (this.pubSubEnabled) {\r\n        await this.client.unsubscribe(`${this.prefix}invalidations`);\r\n      }\r\n      await this.client.quit();\r\n      this.connected = false;\r\n    } catch {\r\n      // Ignore disconnect errors\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if Redis is connected\r\n   */\r\n  isConnected(): boolean {\r\n    return this.connected;\r\n  }\r\n\r\n  /**\r\n   * Cache node metadata\r\n   */\r\n  async cacheNode(meta: RealityNodeMeta): Promise<void> {\r\n    if (!this.connected) return;\r\n\r\n    try {\r\n      const key = `${this.prefix}node:${meta.key}`;\r\n      await this.client.set(key, JSON.stringify(meta), { EX: this.ttl });\r\n    } catch (error) {\r\n      if (this.debug) {\r\n        console.warn('[Redis] Cache node failed:', error);\r\n      }\r\n      // Non-fatal - continue without cache\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached node metadata\r\n   */\r\n  async getCachedNode(key: string): Promise<RealityNodeMeta | null> {\r\n    if (!this.connected) return null;\r\n\r\n    try {\r\n      const data = await this.client.get(`${this.prefix}node:${key}`);\r\n      if (!data) return null;\r\n      return JSON.parse(data) as RealityNodeMeta;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate cached node\r\n   */\r\n  async invalidateCache(key: string): Promise<void> {\r\n    if (!this.connected) return;\r\n\r\n    try {\r\n      await this.client.del(`${this.prefix}node:${key}`);\r\n    } catch {\r\n      // Non-fatal\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Publish invalidation hint to other servers\r\n   * \r\n   * This is a HINT only. Servers receiving this can:\r\n   * - Proactively sync their storage\r\n   * - Pre-warm caches\r\n   * - Notify waiting clients early\r\n   * \r\n   * BUT: They MUST NOT rely on this for correctness.\r\n   */\r\n  async publishInvalidation(keys: string[]): Promise<void> {\r\n    if (!this.connected || !this.pubSubEnabled) return;\r\n\r\n    try {\r\n      const message = JSON.stringify({\r\n        keys,\r\n        source: this.serverId,\r\n        timestamp: Date.now(),\r\n      });\r\n\r\n      await this.client.publish(`${this.prefix}invalidations`, message);\r\n\r\n      if (this.debug) {\r\n        console.log(`[Redis] Published invalidation for ${keys.length} keys`);\r\n      }\r\n    } catch (error) {\r\n      if (this.debug) {\r\n        console.warn('[Redis] Publish invalidation failed:', error);\r\n      }\r\n      // Non-fatal - continue without pub/sub\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register handler for invalidation hints\r\n   */\r\n  onInvalidation(handler: (keys: string[], source: string) => void): () => void {\r\n    this.invalidationHandlers.add(handler);\r\n    return () => this.invalidationHandlers.delete(handler);\r\n  }\r\n\r\n  /**\r\n   * Cache mesh gossip for quick peer discovery\r\n   */\r\n  async cacheGossip(gossip: GossipPayload): Promise<void> {\r\n    if (!this.connected) return;\r\n\r\n    try {\r\n      const key = `${this.prefix}gossip:${gossip.serverId}`;\r\n      await this.client.set(key, JSON.stringify(gossip), { EX: this.ttl });\r\n    } catch {\r\n      // Non-fatal\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached gossip from a server\r\n   */\r\n  async getCachedGossip(serverId: string): Promise<GossipPayload | null> {\r\n    if (!this.connected) return null;\r\n\r\n    try {\r\n      const data = await this.client.get(`${this.prefix}gossip:${serverId}`);\r\n      if (!data) return null;\r\n      return JSON.parse(data) as GossipPayload;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up pub/sub subscriptions\r\n   */\r\n  private async setupPubSub(): Promise<void> {\r\n    try {\r\n      await this.client.subscribe(\r\n        `${this.prefix}invalidations`,\r\n        (message: string) => {\r\n          try {\r\n            const data = JSON.parse(message) as {\r\n              keys: string[];\r\n              source: string;\r\n              timestamp: number;\r\n            };\r\n\r\n            // Ignore our own messages\r\n            if (data.source === this.serverId) return;\r\n\r\n            // Notify handlers\r\n            for (const handler of this.invalidationHandlers) {\r\n              try {\r\n                handler(data.keys, data.source);\r\n              } catch {\r\n                // Ignore handler errors\r\n              }\r\n            }\r\n          } catch {\r\n            // Ignore invalid messages\r\n          }\r\n        }\r\n      );\r\n    } catch (error) {\r\n      if (this.debug) {\r\n        console.warn('[Redis] Pub/sub setup failed:', error);\r\n      }\r\n      // Non-fatal - continue without pub/sub\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get accelerator statistics\r\n   */\r\n  getStats(): {\r\n    connected: boolean;\r\n    pubSubEnabled: boolean;\r\n    handlerCount: number;\r\n  } {\r\n    return {\r\n      connected: this.connected,\r\n      pubSubEnabled: this.pubSubEnabled,\r\n      handlerCount: this.invalidationHandlers.size,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create Redis accelerator\r\n */\r\nexport function createRedisAccelerator(config: RedisAcceleratorConfig): RedisAccelerator {\r\n  return new RedisAccelerator(config);\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Express Adapter\r\n * \r\n * Adapter for Express.js framework.\r\n */\r\n\r\nimport type { RealityRequest } from '../types';\r\nimport type { HandlerDeps } from './handlers';\r\nimport {\r\n  handleSync,\r\n  handleInvalidation,\r\n  handleVersionQuery,\r\n  handleHealth,\r\n  handleNodeUpdate,\r\n  handleCors,\r\n} from './handlers';\r\n\r\n/**\r\n * Express-compatible request\r\n */\r\ninterface ExpressRequest {\r\n  method: string;\r\n  url: string;\r\n  originalUrl: string;\r\n  path: string;\r\n  headers: Record<string, string | string[] | undefined>;\r\n  body: unknown;\r\n  params: Record<string, string>;\r\n  query: Record<string, string | string[] | undefined>;\r\n}\r\n\r\n/**\r\n * Express-compatible response\r\n */\r\ninterface ExpressResponse {\r\n  status(code: number): ExpressResponse;\r\n  set(headers: Record<string, string>): ExpressResponse;\r\n  json(data: unknown): void;\r\n  send(data: unknown): void;\r\n  end(): void;\r\n}\r\n\r\n/**\r\n * Express middleware type\r\n */\r\ntype ExpressMiddleware = (\r\n  req: ExpressRequest,\r\n  res: ExpressResponse,\r\n  next: () => void\r\n) => void | Promise<void>;\r\n\r\n/**\r\n * Convert Express request to Reality request\r\n */\r\nfunction toRealityRequest(req: ExpressRequest): RealityRequest {\r\n  const headers = new Headers();\r\n  for (const [key, value] of Object.entries(req.headers)) {\r\n    if (value) {\r\n      headers.set(key, Array.isArray(value) ? value[0] ?? '' : value);\r\n    }\r\n  }\r\n\r\n  const query: Record<string, string> = {};\r\n  for (const [key, value] of Object.entries(req.query)) {\r\n    if (value) {\r\n      query[key] = Array.isArray(value) ? value[0] ?? '' : value;\r\n    }\r\n  }\r\n\r\n  return {\r\n    method: req.method,\r\n    url: req.originalUrl,\r\n    headers,\r\n    body: req.body,\r\n    params: req.params,\r\n    query,\r\n  };\r\n}\r\n\r\n/**\r\n * Create Express middleware for Reality server\r\n * \r\n * @example\r\n * ```typescript\r\n * import express from 'express';\r\n * import { createExpressMiddleware } from '@rootlodge/reality-server/http';\r\n * \r\n * const app = express();\r\n * app.use(express.json());\r\n * \r\n * const realityMiddleware = createExpressMiddleware({\r\n *   storage,\r\n *   mesh,\r\n *   serverId: 'server-1',\r\n *   version: '1.0.0',\r\n *   startTime: Date.now(),\r\n * });\r\n * \r\n * app.use('/reality', realityMiddleware);\r\n * ```\r\n */\r\nexport function createExpressMiddleware(deps: HandlerDeps): ExpressMiddleware {\r\n  return async (req: ExpressRequest, res: ExpressResponse, next: () => void) => {\r\n    const realityReq = toRealityRequest(req);\r\n    \r\n    // Handle CORS preflight\r\n    if (req.method === 'OPTIONS') {\r\n      const corsResponse = handleCors(realityReq, ['*']);\r\n      res.status(corsResponse.status).set(corsResponse.headers).end();\r\n      return;\r\n    }\r\n\r\n    // Route to appropriate handler\r\n    let response;\r\n    \r\n    try {\r\n      switch (req.path) {\r\n        case '/sync':\r\n          if (req.method !== 'POST') {\r\n            res.status(405).json({ error: 'Method not allowed' });\r\n            return;\r\n          }\r\n          response = await handleSync(realityReq, deps);\r\n          break;\r\n\r\n        case '/invalidate':\r\n          if (req.method !== 'POST') {\r\n            res.status(405).json({ error: 'Method not allowed' });\r\n            return;\r\n          }\r\n          response = await handleInvalidation(realityReq, deps);\r\n          break;\r\n\r\n        case '/versions':\r\n          if (req.method !== 'GET') {\r\n            res.status(405).json({ error: 'Method not allowed' });\r\n            return;\r\n          }\r\n          response = await handleVersionQuery(realityReq, deps);\r\n          break;\r\n\r\n        case '/health':\r\n          response = await handleHealth(realityReq, deps);\r\n          break;\r\n\r\n        case '/update':\r\n          if (req.method !== 'POST') {\r\n            res.status(405).json({ error: 'Method not allowed' });\r\n            return;\r\n          }\r\n          response = await handleNodeUpdate(realityReq, deps);\r\n          break;\r\n\r\n        default:\r\n          // Not a Reality route, pass to next middleware\r\n          next();\r\n          return;\r\n      }\r\n\r\n      // Send response\r\n      res.status(response.status).set(response.headers).json(response.body);\r\n    } catch (error) {\r\n      res.status(500).json({\r\n        error: error instanceof Error ? error.message : 'Internal server error',\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Create Express router with all Reality routes\r\n * \r\n * For use with app.use() when you want Reality at a specific path prefix.\r\n */\r\nexport function createExpressRouter(deps: HandlerDeps) {\r\n  // Return an object that can be used with minimal Express-like setup\r\n  const routes: Array<{\r\n    method: 'get' | 'post' | 'options';\r\n    path: string;\r\n    handler: (req: ExpressRequest, res: ExpressResponse) => Promise<void>;\r\n  }> = [\r\n    {\r\n      method: 'options',\r\n      path: '*',\r\n      handler: async (req, res) => {\r\n        const response = handleCors(toRealityRequest(req), ['*']);\r\n        res.status(response.status).set(response.headers).end();\r\n      },\r\n    },\r\n    {\r\n      method: 'post',\r\n      path: '/sync',\r\n      handler: async (req, res) => {\r\n        const response = await handleSync(toRealityRequest(req), deps);\r\n        res.status(response.status).set(response.headers).json(response.body);\r\n      },\r\n    },\r\n    {\r\n      method: 'post',\r\n      path: '/invalidate',\r\n      handler: async (req, res) => {\r\n        const response = await handleInvalidation(toRealityRequest(req), deps);\r\n        res.status(response.status).set(response.headers).json(response.body);\r\n      },\r\n    },\r\n    {\r\n      method: 'get',\r\n      path: '/versions',\r\n      handler: async (req, res) => {\r\n        const response = await handleVersionQuery(toRealityRequest(req), deps);\r\n        res.status(response.status).set(response.headers).json(response.body);\r\n      },\r\n    },\r\n    {\r\n      method: 'get',\r\n      path: '/health',\r\n      handler: async (req, res) => {\r\n        const response = await handleHealth(toRealityRequest(req), deps);\r\n        res.status(response.status).set(response.headers).json(response.body);\r\n      },\r\n    },\r\n    {\r\n      method: 'post',\r\n      path: '/update',\r\n      handler: async (req, res) => {\r\n        const response = await handleNodeUpdate(toRealityRequest(req), deps);\r\n        res.status(response.status).set(response.headers).json(response.body);\r\n      },\r\n    },\r\n  ];\r\n\r\n  return { routes };\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Server SSE Compatibility\r\n * \r\n * Server-side compatibility for SSE migration.\r\n * Translates Reality updates into SSE-formatted responses.\r\n */\r\n\r\nimport type { RealityStorage, RealityNodeMeta } from '../types';\r\nimport { MeshCoordinator } from '../mesh/coordinator';\r\n\r\n/**\r\n * SSE Compatibility adapter configuration\r\n */\r\nexport interface SSECompatConfig {\r\n  /** Storage adapter */\r\n  storage: RealityStorage;\r\n  /** Mesh coordinator */\r\n  mesh: MeshCoordinator;\r\n  /** Transform node data for SSE event */\r\n  transform?: (key: string, data: unknown) => string;\r\n  /** Optional: Fetch payload for a key */\r\n  payloadFetcher?: (key: string) => Promise<unknown>;\r\n}\r\n\r\n/**\r\n * SSE message format\r\n */\r\ninterface SSEMessage {\r\n  id: string;\r\n  event?: string;\r\n  data: string;\r\n  retry?: number;\r\n}\r\n\r\n/**\r\n * Format SSE message\r\n */\r\nfunction formatSSEMessage(message: SSEMessage): string {\r\n  let result = '';\r\n  \r\n  if (message.id) {\r\n    result += `id: ${message.id}\\n`;\r\n  }\r\n  if (message.event) {\r\n    result += `event: ${message.event}\\n`;\r\n  }\r\n  if (message.retry !== undefined) {\r\n    result += `retry: ${message.retry}\\n`;\r\n  }\r\n  \r\n  // Data can be multiline\r\n  const dataLines = message.data.split('\\n');\r\n  for (const line of dataLines) {\r\n    result += `data: ${line}\\n`;\r\n  }\r\n  \r\n  result += '\\n';\r\n  return result;\r\n}\r\n\r\n/**\r\n * SSE Compatibility Adapter\r\n * \r\n * This adapter helps migrate SSE endpoints to Reality by:\r\n * 1. Accepting SSE-style requests\r\n * 2. Converting Reality node updates to SSE event format\r\n * 3. Returning short-lived HTTP responses (NOT streaming)\r\n * \r\n * IMPORTANT: This does NOT create long-lived SSE connections.\r\n * It returns data in SSE format for clients to process identically.\r\n */\r\nexport class SSECompatAdapter {\r\n  private config: SSECompatConfig;\r\n\r\n  constructor(config: SSECompatConfig) {\r\n    this.config = {\r\n      transform: (_key, data) => JSON.stringify(data),\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle an SSE-style request\r\n   * \r\n   * Returns data in SSE format but via a normal HTTP response.\r\n   * Client's EventSource polyfill will need to poll this endpoint.\r\n   * \r\n   * @param lastEventId - The Last-Event-ID from the client\r\n   * @param keys - Keys to check for updates (derived from URL path)\r\n   * @returns SSE-formatted response body\r\n   */\r\n  async handleRequest(\r\n    lastEventId: string | null,\r\n    keys: string[]\r\n  ): Promise<{\r\n    body: string;\r\n    headers: Record<string, string>;\r\n    hasChanges: boolean;\r\n  }> {\r\n    // Parse last event ID to get version\r\n    const lastVersion = this.parseEventId(lastEventId);\r\n\r\n    // Get nodes that have changed\r\n    const changedNodes = await this.config.storage.listChangedSince(lastVersion);\r\n\r\n    // Filter to only requested keys\r\n    const relevantChanges = changedNodes.filter((node) =>\r\n      keys.length === 0 || keys.includes(node.key)\r\n    );\r\n\r\n    // Build SSE response\r\n    let body = '';\r\n    let maxVersion = lastVersion;\r\n\r\n    for (const node of relevantChanges) {\r\n      // Fetch payload if available\r\n      let payload: unknown = null;\r\n      if (this.config.payloadFetcher) {\r\n        try {\r\n          payload = await this.config.payloadFetcher(node.key);\r\n        } catch {\r\n          // Skip if payload fetch fails\r\n          continue;\r\n        }\r\n      }\r\n\r\n      const message: SSEMessage = {\r\n        id: this.createEventId(node),\r\n        event: 'update',\r\n        data: this.config.transform!(node.key, payload ?? { key: node.key, version: node.version }),\r\n      };\r\n\r\n      body += formatSSEMessage(message);\r\n      maxVersion = Math.max(maxVersion, node.version);\r\n    }\r\n\r\n    // Add a heartbeat message if no changes\r\n    if (body === '') {\r\n      const heartbeat: SSEMessage = {\r\n        id: `heartbeat:${Date.now()}`,\r\n        event: 'heartbeat',\r\n        data: JSON.stringify({ timestamp: Date.now() }),\r\n      };\r\n      body = formatSSEMessage(heartbeat);\r\n    }\r\n\r\n    return {\r\n      body,\r\n      headers: {\r\n        'Content-Type': 'text/event-stream',\r\n        'Cache-Control': 'no-cache',\r\n        'X-Accel-Buffering': 'no',\r\n        'X-Reality-Version': String(maxVersion),\r\n      },\r\n      hasChanges: relevantChanges.length > 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a Fetch API handler for SSE-compatible endpoint\r\n   */\r\n  createFetchHandler(\r\n    getKeysFromRequest: (request: Request) => string[]\r\n  ): (request: Request) => Promise<Response> {\r\n    return async (request: Request): Promise<Response> => {\r\n      const lastEventId = request.headers.get('Last-Event-ID');\r\n      const keys = getKeysFromRequest(request);\r\n\r\n      const result = await this.handleRequest(lastEventId, keys);\r\n\r\n      return new Response(result.body, {\r\n        status: 200,\r\n        headers: result.headers,\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse event ID to extract version\r\n   */\r\n  private parseEventId(eventId: string | null): number {\r\n    if (!eventId) return 0;\r\n    \r\n    // Format: \"version:hash\" or just version number\r\n    const parts = eventId.split(':');\r\n    const version = parseInt(parts[0] ?? '0', 10);\r\n    return isNaN(version) ? 0 : version;\r\n  }\r\n\r\n  /**\r\n   * Create event ID from node metadata\r\n   */\r\n  private createEventId(node: RealityNodeMeta): string {\r\n    return `${node.version}:${node.hash}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Create SSE compatibility adapter\r\n */\r\nexport function createSSECompatAdapter(config: SSECompatConfig): SSECompatAdapter {\r\n  return new SSECompatAdapter(config);\r\n}\r\n","/**\r\n * @rootlodge/reality-server - Server Polling Compatibility\r\n * \r\n * Server-side compatibility for polling migration.\r\n * Returns data in the same format as traditional polling endpoints.\r\n */\r\n\r\nimport type { RealityStorage } from '../types';\r\nimport { MeshCoordinator } from '../mesh/coordinator';\r\n\r\n/**\r\n * Polling compatibility adapter configuration\r\n */\r\nexport interface PollingCompatConfig {\r\n  /** Storage adapter */\r\n  storage: RealityStorage;\r\n  /** Mesh coordinator */\r\n  mesh: MeshCoordinator;\r\n  /** Optional: Fetch payload for a key */\r\n  payloadFetcher?: (key: string) => Promise<unknown>;\r\n  /** Optional: Transform response format */\r\n  transform?: (data: Map<string, unknown>) => unknown;\r\n}\r\n\r\n/**\r\n * Polling Compatibility Adapter\r\n * \r\n * This adapter helps migrate polling endpoints to Reality by:\r\n * 1. Accepting requests in the same format as existing polling endpoints\r\n * 2. Returning data in the same format\r\n * 3. Adding Reality versioning for efficient future syncs\r\n */\r\nexport class PollingCompatAdapter {\r\n  private config: PollingCompatConfig;\r\n\r\n  constructor(config: PollingCompatConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Handle a polling-style request\r\n   * \r\n   * @param keys - Keys to fetch\r\n   * @param ifModifiedSince - Optional version for conditional request\r\n   * @returns Response data and metadata\r\n   */\r\n  async handleRequest(\r\n    keys: string[],\r\n    ifModifiedSince?: number\r\n  ): Promise<{\r\n    data: unknown;\r\n    headers: Record<string, string>;\r\n    status: number;\r\n    modified: boolean;\r\n  }> {\r\n    // Get current metadata for all keys\r\n    const metas = await this.config.storage.getNodes(keys);\r\n\r\n    // Check if any have changed since ifModifiedSince\r\n    let maxVersion = 0;\r\n    let hasChanges = false;\r\n\r\n    for (const meta of metas.values()) {\r\n      maxVersion = Math.max(maxVersion, meta.version);\r\n      if (ifModifiedSince === undefined || meta.version > ifModifiedSince) {\r\n        hasChanges = true;\r\n      }\r\n    }\r\n\r\n    // If nothing changed, return 304\r\n    if (ifModifiedSince !== undefined && !hasChanges) {\r\n      return {\r\n        data: null,\r\n        headers: {\r\n          'X-Reality-Version': String(maxVersion),\r\n        },\r\n        status: 304,\r\n        modified: false,\r\n      };\r\n    }\r\n\r\n    // Fetch payloads\r\n    const payloads = new Map<string, unknown>();\r\n\r\n    for (const key of keys) {\r\n      if (this.config.payloadFetcher) {\r\n        try {\r\n          const payload = await this.config.payloadFetcher(key);\r\n          payloads.set(key, payload);\r\n        } catch {\r\n          // Skip failed fetches\r\n        }\r\n      }\r\n    }\r\n\r\n    // Transform response\r\n    const data = this.config.transform\r\n      ? this.config.transform(payloads)\r\n      : Object.fromEntries(payloads);\r\n\r\n    return {\r\n      data,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Reality-Version': String(maxVersion),\r\n        'Cache-Control': 'no-cache',\r\n      },\r\n      status: 200,\r\n      modified: true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a Fetch API handler for polling-compatible endpoint\r\n   */\r\n  createFetchHandler(\r\n    getKeysFromRequest: (request: Request) => string[]\r\n  ): (request: Request) => Promise<Response> {\r\n    return async (request: Request): Promise<Response> => {\r\n      const ifModifiedSince = request.headers.get('X-Reality-Version');\r\n      const version = ifModifiedSince ? parseInt(ifModifiedSince, 10) : undefined;\r\n      const keys = getKeysFromRequest(request);\r\n\r\n      const result = await this.handleRequest(keys, version);\r\n\r\n      if (result.status === 304) {\r\n        return new Response(null, {\r\n          status: 304,\r\n          headers: result.headers,\r\n        });\r\n      }\r\n\r\n      return new Response(JSON.stringify(result.data), {\r\n        status: result.status,\r\n        headers: result.headers,\r\n      });\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create polling compatibility adapter\r\n */\r\nexport function createPollingCompatAdapter(config: PollingCompatConfig): PollingCompatAdapter {\r\n  return new PollingCompatAdapter(config);\r\n}\r\n"]}