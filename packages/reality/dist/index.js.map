{"version":3,"sources":["../src/index.ts","../src/core/store.ts","../src/core/filter.ts","../src/client/transport.ts","../src/client/createClient.ts","../src/core/event.ts"],"sourcesContent":["// Default export is the Client API\r\nexport * from './client/createClient';\r\nexport * from './client/transport';\r\nexport * from './core/event';\r\nexport * from './core/filter';\r\nexport * from './core/store';\r\n","import { RealityEvent } from './event';\r\n\r\nexport interface StoreOptions {\r\n  maxEvents?: number;\r\n  ttl?: number; // Time to live in ms\r\n}\r\n\r\nexport class EventStore {\r\n  private events: RealityEvent[] = [];\r\n  private knownIds: Set<string> = new Set();\r\n  private maxEvents: number;\r\n  private ttl: number;\r\n\r\n  constructor(options: StoreOptions = {}) {\r\n    this.maxEvents = options.maxEvents ?? 10000;\r\n    this.ttl = options.ttl ?? 24 * 60 * 60 * 1000; // 24 hours default\r\n  }\r\n\r\n  /**\r\n   * Add an event to the store.\r\n   * Returns true if event was new, false if duplicate.\r\n   */\r\n  add(event: RealityEvent): boolean {\r\n    if (this.knownIds.has(event.id)) {\r\n      return false;\r\n    }\r\n\r\n    // Insert sorted by timestamp (simple append usually fits if clocks roughly sync)\r\n    // For now, strict append is fine, we can sort on retrieval if needed\r\n    this.events.push(event);\r\n    this.knownIds.add(event.id);\r\n\r\n    // Prune if needed\r\n    if (this.events.length > this.maxEvents) {\r\n      this.gc();\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if we have an event\r\n   */\r\n  has(id: string): boolean {\r\n    return this.knownIds.has(id);\r\n  }\r\n\r\n  /**\r\n   * Get all events\r\n   */\r\n  getAll(): RealityEvent[] {\r\n    return this.events;\r\n  }\r\n\r\n  /**\r\n   * Get events not present in the provided check function (Filter)\r\n   */\r\n  getMissing(hasIt: (id: string) => boolean): RealityEvent[] {\r\n    // Return events that the OTHER party does NOT have\r\n    const missing: RealityEvent[] = [];\r\n    for (const event of this.events) {\r\n      if (!hasIt(event.id)) {\r\n        missing.push(event);\r\n      }\r\n    }\r\n    return missing;\r\n  }\r\n\r\n  /**\r\n   * Garbage Collection\r\n   * Remove old events or exceed limit\r\n   */\r\n  private gc() {\r\n    const now = Date.now();\r\n    \r\n    // 1. TTL Pruning\r\n    // 2. Size Pruning\r\n    \r\n    // Efficient approach: Filter in place\r\n    // But Array.filter creates new array. splice is better for huge arrays at start.\r\n    \r\n    // Find split point for TTL\r\n    // assuming rough time order\r\n    \r\n    // Simple implementation: Strict Limit Enforcement\r\n    if (this.events.length > this.maxEvents) {\r\n      const excess = this.events.length - this.maxEvents;\r\n      const removed = this.events.splice(0, excess);\r\n      for (const ev of removed) {\r\n        this.knownIds.delete(ev.id);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear store\r\n   */\r\n  clear() {\r\n    this.events = [];\r\n    this.knownIds.clear();\r\n  }\r\n}\r\n","import { BloomFilter } from 'bloom-filters';\r\nimport { RealityFilter } from './event';\r\n\r\n/**\r\n * Filter implementation using Bloom Filters.\r\n * Probabilistic set:\r\n * - False positives possible (might say \"I have this event\" when I don't)\r\n * - False negatives IMPOSSIBLE (never says \"I don't have this\" if I do)\r\n * \r\n * This is safe for sync because if I falsely claim to have an event, \r\n * I just miss receiving it this round. Next round with a fresh/different filter \r\n * (or just random chance) likely fixes it. Or explicit \"fill gaps\" mechanism.\r\n * \r\n * Actually, for Reality 2.0, false positives in \"Have\" filter = Missing Data permanently if not careful.\r\n * \r\n * BUT: The gossip protocol sends \"Here is my filter (what I have)\".\r\n * Peer checks: \"Do I have anything NOT in this filter?\"\r\n * If Peer has Event E, and Filter says \"Yes I have E\" (False Positive), peer won't send E.\r\n * \r\n * To mitigate:\r\n * 1. Low error rate configuration.\r\n * 2. Periodic full-sync or \"I'm missing X\" explicit requests if gaps detected.\r\n * 3. Or use Invertible Bloom Lookup Tables (IBLT) for exact reconciliation (advanced).\r\n * \r\n * For Reality 2.0 MVP, we use standard Bloom Filter with conservative sizing.\r\n */\r\nexport class BloomRealityFilter implements RealityFilter {\r\n  private filter: BloomFilter;\r\n\r\n  constructor(size = 1000, errorRate = 0.01) {\r\n    // Estimate: m = ceil((n * log(p)) / log(1 / (pow(2, log(2)))));\r\n    // k = round((m / n) * log(2));\r\n    this.filter = BloomFilter.create(size, errorRate);\r\n  }\r\n\r\n  add(id: string): void {\r\n    this.filter.add(id);\r\n  }\r\n\r\n  has(id: string): boolean {\r\n    return this.filter.has(id);\r\n  }\r\n\r\n  serialize(): string {\r\n    const json = this.filter.saveAsJSON();\r\n    // Compress or encode if needed, for now JSON string is fine\r\n    return JSON.stringify(json);\r\n  }\r\n\r\n  static from(serialized: string): BloomRealityFilter {\r\n    const instance = new BloomRealityFilter();\r\n    const json = JSON.parse(serialized);\r\n    instance.filter = BloomFilter.fromJSON(json);\r\n    return instance;\r\n  }\r\n\r\n  merge(other: RealityFilter): void {\r\n    // Bloom filters can be merged with bitwise OR if same size/seeds\r\n    // simplified: we don't merge filters in MVP, we just replace or add items\r\n    throw new Error('Merge not implemented for simple BloomFilter');\r\n  }\r\n}\r\n","import { RealityEvent } from '../core/event';\r\n\r\nexport interface RealityTransport {\r\n  sendFilter(filter: string): Promise<{ events: RealityEvent[]; serverFilter: string }>;\r\n  sendEvents(events: RealityEvent[]): Promise<{ added: number }>;\r\n}\r\n\r\nexport class HttpTransport implements RealityTransport {\r\n  constructor(private url: string) {}\r\n\r\n  async sendFilter(filter: string): Promise<{ events: RealityEvent[]; serverFilter: string }> {\r\n    const res = await fetch(`${this.url}/filter`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        filter,\r\n        origin: 'client', // TODO: Client ID\r\n      }),\r\n    });\r\n    \r\n    if (!res.ok) throw new Error(`Reality Sync Error: ${res.status}`);\r\n    return res.json();\r\n  }\r\n\r\n  async sendEvents(events: RealityEvent[]): Promise<{ added: number }> {\r\n    const res = await fetch(`${this.url}/events`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        events,\r\n        origin: 'client',\r\n      }),\r\n    });\r\n\r\n    if (!res.ok) throw new Error(`Reality Push Error: ${res.status}`);\r\n    return res.json();\r\n  }\r\n}\r\n","import { EventStore } from '../core/store';\r\nimport { BloomRealityFilter } from '../core/filter';\r\nimport { RealityEvent } from '../core/event';\r\nimport { HttpTransport, RealityTransport } from './transport';\r\nimport { nanoid } from 'nanoid';\r\nimport EventEmitter from 'eventemitter3';\r\n\r\nexport interface RealityClientOptions {\r\n  peers?: string[];\r\n  namespace?: string;\r\n  transport?: RealityTransport; // Custom transport override\r\n  autoSync?: boolean;\r\n}\r\n\r\nexport class RealityClient extends EventEmitter {\r\n  private store: EventStore;\r\n  private filter: BloomRealityFilter;\r\n  private transports: RealityTransport[] = [];\r\n  private syncTimer: any;\r\n  private isSyncing = false;\r\n  private clientId: string;\r\n\r\n  constructor(options: RealityClientOptions = {}) {\r\n    super();\r\n    this.store = new EventStore();\r\n    this.filter = new BloomRealityFilter(); // Local knowledge\r\n    this.clientId = nanoid();\r\n\r\n    if (options.transport) {\r\n      this.transports.push(options.transport);\r\n    } else if (options.peers) {\r\n      this.transports = options.peers.map(p => {\r\n        // Normalize URL to include /__reality prefix if not customized? \r\n        // Spec says server handles /__reality. Client typically configured with base URL.\r\n        // direct peer URL\r\n        return new HttpTransport(p);\r\n      });\r\n    }\r\n\r\n    if (options.autoSync !== false) {\r\n      this.startSyncLoop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Publish an event\r\n   */\r\n  publish(topic: string, payload: unknown) {\r\n    const event: RealityEvent = {\r\n      id: nanoid(),\r\n      topic,\r\n      payload,\r\n      timestamp: Date.now(),\r\n      origin: this.clientId,\r\n    };\r\n\r\n    if (this.store.add(event)) {\r\n      this.filter.add(event.id);\r\n      this.emit(topic, event);\r\n      this.emit('*', event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic (alias for on)\r\n   */\r\n  subscribe(topic: string, cb: (event: RealityEvent) => void) {\r\n    this.on(topic, cb);\r\n    \r\n    // Replay existing events for this topic?\r\n    // Reality 1.0 didn't, but usually good for \"state\".\r\n    // For \"Events\", maybe not.\r\n    // Let's stick to valid Event Emitter behavior (future events).\r\n    // If user wants state, they can query store.\r\n    return () => this.off(topic, cb);\r\n  }\r\n\r\n  /**\r\n   * Get current events for topic\r\n   */\r\n  getEvents(topic: string): RealityEvent[] {\r\n    return this.store.getAll().filter(e => e.topic === topic);\r\n  }\r\n\r\n  /**\r\n   * Sync Loop\r\n   */\r\n  private startSyncLoop() {\r\n    const jitter = Math.random() * 500 + 500; // 500-1000ms\r\n    this.syncTimer = setTimeout(() => {\r\n      this.sync().finally(() => {\r\n        this.startSyncLoop();\r\n      });\r\n    }, jitter);\r\n  }\r\n\r\n  async sync() {\r\n    if (this.isSyncing) return;\r\n    if (this.transports.length === 0) return;\r\n\r\n    this.isSyncing = true;\r\n    try {\r\n      // Pick random peer\r\n      const transport = this.transports[Math.floor(Math.random() * this.transports.length)];\r\n\r\n      // 1. Send Filter -> Get Missing Events + Server Filter\r\n      const { events, serverFilter } = await transport.sendFilter(this.filter.serialize());\r\n\r\n      // 2. Add received events\r\n      let newCount = 0;\r\n      for (const event of events) {\r\n        if (this.store.add(event)) {\r\n          this.filter.add(event.id);\r\n          this.emit(event.topic, event);\r\n          this.emit('*', event);\r\n          newCount++;\r\n        }\r\n      }\r\n\r\n      // 3. Diff Server Filter -> Find what Server is missing\r\n      // We check OUR store against SERVER filter\r\n      const serverBloom = BloomRealityFilter.from(serverFilter);\r\n      const missingOnServer = this.store.getMissing((id) => serverBloom.has(id));\r\n\r\n      if (missingOnServer.length > 0) {\r\n        // 4. Send events server is missing\r\n        await transport.sendEvents(missingOnServer);\r\n      }\r\n      \r\n      // console.log(`[Reality] Sync: Recv ${newCount}, Sent ${missingOnServer.length}`);\r\n\r\n    } catch (e) {\r\n      console.warn('[Reality] Sync failed:', e);\r\n    } finally {\r\n      this.isSyncing = false;\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    clearTimeout(this.syncTimer);\r\n  }\r\n}\r\n\r\nexport function createRealityClient(options: RealityClientOptions) {\r\n  return new RealityClient(options);\r\n}\r\n","/**\r\n * Reality Event\r\n * The fundamental atomic unit of truth in Reality 2.0.\r\n */\r\nimport { z } from 'zod';\r\n\r\nexport interface RealityEvent<T = unknown> {\r\n  id: string;              // Deterministic hash of content + timestamp\r\n  topic: string;           // Channel/Namespace\r\n  payload: T;              // Actual data\r\n  timestamp: number;       // Logical/Wall clock\r\n  origin: string;          // Node ID where event was born\r\n}\r\n\r\nexport const RealityEventSchema = z.object({\r\n  id: z.string(),\r\n  topic: z.string(),\r\n  payload: z.unknown(),\r\n  timestamp: z.number(),\r\n  origin: z.string(),\r\n});\r\n\r\n/**\r\n * Filter represents a probabilistic set of known event IDs.\r\n * Used for efficient difference calculation.\r\n */\r\nexport interface RealityFilter {\r\n  add(id: string): void;\r\n  has(id: string): boolean;\r\n  serialize(): string;\r\n  merge(other: RealityFilter): void;\r\n}\r\n"],"mappings":"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","names":["EventEmitter"]}