{"version":3,"sources":["../../src/compat/sse.ts","../../src/compat/polling.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\r\n * @rootlodge/reality - SSE Compatibility Layer\r\n * \r\n * Drop-in replacement for EventSource that uses the Reality system internally.\r\n * Allows migration from SSE to Reality with minimal code changes.\r\n */\r\n\r\nimport type { RealityKeyOptions, RealityNodeState } from '../types';\r\nimport { RealityClient } from '../client/reality-client';\r\n\r\n/**\r\n * SSE message event compatible with native EventSource\r\n */\r\nexport interface SSEMessageEvent {\r\n  data: string;\r\n  lastEventId: string;\r\n  origin: string;\r\n  type: string;\r\n}\r\n\r\n/**\r\n * SSE event listener type\r\n */\r\nexport type SSEEventListener = (event: SSEMessageEvent) => void;\r\n\r\n/**\r\n * SSE ready states compatible with native EventSource\r\n */\r\nexport const SSEReadyState = {\r\n  CONNECTING: 0,\r\n  OPEN: 1,\r\n  CLOSED: 2,\r\n} as const;\r\n\r\n/**\r\n * Options for createEventSource\r\n */\r\nexport interface EventSourceOptions {\r\n  /** Reality key to subscribe to */\r\n  realityKey?: string;\r\n  /** Transform server data to SSE message format */\r\n  transform?: (data: unknown) => string;\r\n  /** Stale time in ms - triggers sync when exceeded */\r\n  staleTime?: number;\r\n}\r\n\r\n/**\r\n * EventSource-compatible class backed by Reality\r\n * \r\n * This provides API compatibility with native EventSource,\r\n * but uses Reality's deterministic pull mechanism internally.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Before (native SSE):\r\n * const es = new EventSource('/events');\r\n * es.onmessage = (e) => updateUI(JSON.parse(e.data));\r\n * \r\n * // After (Reality-backed):\r\n * import { createEventSource } from '@rootlodge/reality/compat';\r\n * \r\n * const es = createEventSource('/events');\r\n * es.onmessage = (e) => updateUI(JSON.parse(e.data)); // Same API!\r\n * ```\r\n */\r\nexport class RealityEventSource {\r\n  // EventSource API compatibility\r\n  readonly CONNECTING = SSEReadyState.CONNECTING;\r\n  readonly OPEN = SSEReadyState.OPEN;\r\n  readonly CLOSED = SSEReadyState.CLOSED;\r\n\r\n  readyState: number = SSEReadyState.CONNECTING;\r\n  url: string;\r\n  withCredentials = false;\r\n\r\n  onopen: ((event: Event) => void) | null = null;\r\n  onmessage: SSEEventListener | null = null;\r\n  onerror: ((event: Event) => void) | null = null;\r\n\r\n  private client: RealityClient;\r\n  private realityKey: string;\r\n  private transform: (data: unknown) => string;\r\n  private unsubscribe: (() => void) | null = null;\r\n  private eventListeners: Map<string, Set<SSEEventListener>> = new Map();\r\n  private lastEventId = '';\r\n\r\n  constructor(\r\n    url: string,\r\n    client: RealityClient,\r\n    options: EventSourceOptions = {}\r\n  ) {\r\n    this.url = url;\r\n    this.client = client;\r\n    this.realityKey = options.realityKey ?? this.urlToKey(url);\r\n    this.transform = options.transform ?? JSON.stringify;\r\n\r\n    // Subscribe to Reality node\r\n    this.connect(options);\r\n  }\r\n\r\n  /**\r\n   * Add event listener (EventSource API)\r\n   */\r\n  addEventListener(type: string, listener: SSEEventListener): void {\r\n    let listeners = this.eventListeners.get(type);\r\n    if (!listeners) {\r\n      listeners = new Set();\r\n      this.eventListeners.set(type, listeners);\r\n    }\r\n    listeners.add(listener);\r\n  }\r\n\r\n  /**\r\n   * Remove event listener (EventSource API)\r\n   */\r\n  removeEventListener(type: string, listener: SSEEventListener): void {\r\n    const listeners = this.eventListeners.get(type);\r\n    if (listeners) {\r\n      listeners.delete(listener);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatch event to listeners\r\n   */\r\n  private dispatchEvent(type: string, event: SSEMessageEvent): void {\r\n    // Call specific handler\r\n    if (type === 'message' && this.onmessage) {\r\n      this.onmessage(event);\r\n    }\r\n\r\n    // Call registered listeners\r\n    const listeners = this.eventListeners.get(type);\r\n    if (listeners) {\r\n      for (const listener of listeners) {\r\n        listener(event);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close the connection (EventSource API)\r\n   */\r\n  close(): void {\r\n    if (this.unsubscribe) {\r\n      this.unsubscribe();\r\n      this.unsubscribe = null;\r\n    }\r\n    this.readyState = SSEReadyState.CLOSED;\r\n  }\r\n\r\n  /**\r\n   * Connect to Reality node\r\n   */\r\n  private connect(options: EventSourceOptions): void {\r\n    const keyOptions: RealityKeyOptions = {\r\n      staleTime: options.staleTime ?? 30000,\r\n      refetchOnFocus: true,\r\n      refetchOnReconnect: true,\r\n    };\r\n\r\n    this.unsubscribe = this.client.subscribe(\r\n      this.realityKey,\r\n      (state: RealityNodeState) => {\r\n        this.handleStateChange(state);\r\n      },\r\n      keyOptions\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle Reality state changes\r\n   */\r\n  private handleStateChange(state: RealityNodeState): void {\r\n    // Handle connection state\r\n    if (this.readyState === SSEReadyState.CONNECTING && !state.isLoading) {\r\n      this.readyState = SSEReadyState.OPEN;\r\n      if (this.onopen) {\r\n        this.onopen(new Event('open'));\r\n      }\r\n    }\r\n\r\n    // Handle errors\r\n    if (state.error) {\r\n      if (this.onerror) {\r\n        this.onerror(new Event('error'));\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle data updates\r\n    if (state.data !== undefined && state.meta) {\r\n      const eventId = `${state.meta.version}-${state.meta.hash}`;\r\n      \r\n      // Only emit if this is a new event\r\n      if (eventId !== this.lastEventId) {\r\n        this.lastEventId = eventId;\r\n        \r\n        const event: SSEMessageEvent = {\r\n          data: this.transform(state.data),\r\n          lastEventId: eventId,\r\n          origin: this.url,\r\n          type: 'message',\r\n        };\r\n\r\n        this.dispatchEvent('message', event);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert URL to Reality key\r\n   */\r\n  private urlToKey(url: string): string {\r\n    // Remove protocol and query params, convert to key format\r\n    return url\r\n      .replace(/^https?:\\/\\/[^/]+/, '')\r\n      .replace(/\\?.*$/, '')\r\n      .replace(/^\\//, '')\r\n      .replace(/\\//g, ':');\r\n  }\r\n}\r\n\r\n/**\r\n * Create an EventSource-compatible object backed by Reality\r\n * \r\n * This is the primary migration helper for SSE applications.\r\n * \r\n * @param url - The original SSE URL (used as key basis)\r\n * @param client - Reality client instance\r\n * @param options - Configuration options\r\n * @returns EventSource-compatible object\r\n * \r\n * @example\r\n * ```typescript\r\n * // Migration: Replace EventSource with createEventSource\r\n * \r\n * // OLD:\r\n * const es = new EventSource('/api/events');\r\n * es.onmessage = (e) => handleUpdate(JSON.parse(e.data));\r\n * \r\n * // NEW:\r\n * const client = createRealityClient({ servers: ['https://api.example.com'] });\r\n * const es = createEventSource('/api/events', client);\r\n * es.onmessage = (e) => handleUpdate(JSON.parse(e.data)); // Same handler!\r\n * ```\r\n */\r\nexport function createEventSource(\r\n  url: string,\r\n  client: RealityClient,\r\n  options: EventSourceOptions = {}\r\n): RealityEventSource {\r\n  return new RealityEventSource(url, client, options);\r\n}\r\n\r\n/**\r\n * Create a factory for EventSource objects using a shared client\r\n * \r\n * Useful when migrating multiple SSE connections.\r\n * \r\n * @param client - Reality client instance\r\n * @returns Factory function that creates EventSource objects\r\n * \r\n * @example\r\n * ```typescript\r\n * const client = createRealityClient({ servers: ['https://api.example.com'] });\r\n * const EventSource = createEventSourceFactory(client);\r\n * \r\n * // Use just like native EventSource\r\n * const es1 = new EventSource('/events/chat');\r\n * const es2 = new EventSource('/events/notifications');\r\n * ```\r\n */\r\nexport function createEventSourceFactory(\r\n  client: RealityClient\r\n): new (url: string, options?: EventSourceOptions) => RealityEventSource {\r\n  return class extends RealityEventSource {\r\n    constructor(url: string, options?: EventSourceOptions) {\r\n      super(url, client, options);\r\n    }\r\n  };\r\n}\r\n","/**\r\n * @rootlodge/reality - Polling Compatibility Layer\r\n * \r\n * Drop-in replacement for setInterval-based polling that uses Reality.\r\n * Eliminates wasteful periodic network requests.\r\n */\r\n\r\nimport type { RealityKeyOptions, RealityNodeState, SyncHint } from '../types';\r\nimport { RealityClient } from '../client/reality-client';\r\n\r\n/**\r\n * Callback for polling adapter\r\n */\r\nexport type PollingCallback<T = unknown> = (data: T) => void;\r\n\r\n/**\r\n * Options for polling adapter\r\n */\r\nexport interface PollingAdapterOptions<T = unknown> {\r\n  /** Reality key to subscribe to */\r\n  realityKey?: string;\r\n  /** Transform data before passing to callback */\r\n  transform?: (data: unknown) => T;\r\n  /** Validation schema (zod) */\r\n  schema?: { safeParse: (data: unknown) => { success: boolean; data?: T; error?: unknown } };\r\n  /** Initial data / fallback */\r\n  initial?: T;\r\n  /** Sync on visibility change */\r\n  syncOnVisibility?: boolean;\r\n  /** Sync on focus */\r\n  syncOnFocus?: boolean;\r\n  /** Sync on interaction hint */\r\n  syncOnInteraction?: boolean;\r\n}\r\n\r\n/**\r\n * Polling adapter control object\r\n */\r\nexport interface PollingAdapterControl {\r\n  /** Manually trigger a sync */\r\n  sync: (hint?: SyncHint) => Promise<void>;\r\n  /** Stop the adapter */\r\n  stop: () => void;\r\n  /** Check if adapter is active */\r\n  isActive: () => boolean;\r\n  /** Get last sync timestamp */\r\n  getLastSyncTime: () => number | null;\r\n}\r\n\r\n/**\r\n * Create a polling adapter that uses Reality instead of setInterval\r\n * \r\n * This is the primary migration helper for polling-based applications.\r\n * Instead of making periodic requests, it syncs only when meaningful:\r\n * - User interaction\r\n * - Window focus/visibility\r\n * - Optimistic mutations\r\n * - Idle callbacks\r\n * \r\n * @param url - The original polling endpoint (used as key basis)\r\n * @param callback - Function to call with updates (same as polling callback)\r\n * @param client - Reality client instance\r\n * @param options - Configuration options\r\n * @returns Control object for the adapter\r\n * \r\n * @example\r\n * ```typescript\r\n * // BEFORE (wasteful polling):\r\n * setInterval(async () => {\r\n *   const data = await fetch('/updates').then(r => r.json());\r\n *   updateUI(data);\r\n * }, 1000);\r\n * \r\n * // AFTER (Reality):\r\n * const client = createRealityClient({ servers: ['https://api.example.com'] });\r\n * const adapter = createPollingAdapter('/updates', updateUI, client);\r\n * \r\n * // Optionally trigger manual sync:\r\n * document.getElementById('refresh').onclick = () => adapter.sync();\r\n * \r\n * // Cleanup when done:\r\n * adapter.stop();\r\n * ```\r\n */\r\nexport function createPollingAdapter<T = unknown>(\r\n  url: string,\r\n  callback: PollingCallback<T>,\r\n  client: RealityClient,\r\n  options: PollingAdapterOptions<T> = {}\r\n): PollingAdapterControl {\r\n  const realityKey = options.realityKey ?? urlToKey(url);\r\n  let isActive = true;\r\n  let lastSyncTime: number | null = null;\r\n  let unsubscribe: (() => void) | null = null;\r\n\r\n  // Build Reality options\r\n  const keyOptions: RealityKeyOptions<T> = {\r\n    fallback: options.initial,\r\n    transform: options.transform,\r\n    refetchOnFocus: options.syncOnFocus ?? true,\r\n    refetchOnReconnect: true,\r\n  };\r\n\r\n  // Subscribe to Reality\r\n  unsubscribe = client.subscribe<T>(\r\n    realityKey,\r\n    (state: RealityNodeState<T>) => {\r\n      if (!isActive) return;\r\n\r\n      // Update last sync time\r\n      if (state.lastSyncAt) {\r\n        lastSyncTime = state.lastSyncAt;\r\n      }\r\n\r\n      // Only call callback with actual data\r\n      if (state.data !== undefined && !state.isLoading && !state.error) {\r\n        callback(state.data);\r\n      }\r\n    },\r\n    keyOptions\r\n  );\r\n\r\n  // Set up visibility-based sync\r\n  if (options.syncOnVisibility !== false && typeof document !== 'undefined') {\r\n    const handleVisibilityChange = () => {\r\n      if (document.visibilityState === 'visible' && isActive) {\r\n        client.syncKeys([realityKey], 'focus');\r\n      }\r\n    };\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n  }\r\n\r\n  // Return control object\r\n  return {\r\n    sync: async (hint: SyncHint = 'interaction') => {\r\n      if (isActive) {\r\n        await client.syncKeys([realityKey], hint);\r\n      }\r\n    },\r\n    stop: () => {\r\n      isActive = false;\r\n      if (unsubscribe) {\r\n        unsubscribe();\r\n        unsubscribe = null;\r\n      }\r\n    },\r\n    isActive: () => isActive,\r\n    getLastSyncTime: () => lastSyncTime,\r\n  };\r\n}\r\n\r\n/**\r\n * Create a batch polling adapter for multiple endpoints\r\n * \r\n * Useful when migrating apps that poll multiple endpoints.\r\n * All endpoints are batched into a single sync request.\r\n * \r\n * @param configs - Array of polling configurations\r\n * @param client - Reality client instance\r\n * @returns Batch control object\r\n * \r\n * @example\r\n * ```typescript\r\n * const client = createRealityClient({ servers: ['https://api.example.com'] });\r\n * \r\n * const batch = createBatchPollingAdapter([\r\n *   { url: '/api/users', callback: updateUsers },\r\n *   { url: '/api/stats', callback: updateStats },\r\n *   { url: '/api/notifications', callback: updateNotifications },\r\n * ], client);\r\n * \r\n * // Sync all at once\r\n * batch.syncAll();\r\n * \r\n * // Stop all\r\n * batch.stopAll();\r\n * ```\r\n */\r\nexport function createBatchPollingAdapter<T = unknown>(\r\n  configs: Array<{\r\n    url: string;\r\n    callback: PollingCallback<T>;\r\n    options?: PollingAdapterOptions<T>;\r\n  }>,\r\n  client: RealityClient\r\n): {\r\n  adapters: Map<string, PollingAdapterControl>;\r\n  syncAll: (hint?: SyncHint) => Promise<void>;\r\n  stopAll: () => void;\r\n} {\r\n  const adapters = new Map<string, PollingAdapterControl>();\r\n\r\n  for (const config of configs) {\r\n    const adapter = createPollingAdapter(\r\n      config.url,\r\n      config.callback,\r\n      client,\r\n      config.options\r\n    );\r\n    adapters.set(config.url, adapter);\r\n  }\r\n\r\n  return {\r\n    adapters,\r\n    syncAll: async (hint: SyncHint = 'interaction') => {\r\n      const keys = configs.map((c) => c.options?.realityKey ?? urlToKey(c.url));\r\n      await client.syncKeys(keys, hint);\r\n    },\r\n    stopAll: () => {\r\n      for (const adapter of adapters.values()) {\r\n        adapter.stop();\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Interaction-triggered sync helper\r\n * \r\n * Wraps a callback to trigger sync on interaction.\r\n * \r\n * @example\r\n * ```typescript\r\n * const control = createPollingAdapter('/data', updateUI, client);\r\n * \r\n * // Trigger sync when user clicks\r\n * button.onclick = withInteractionSync(control, () => {\r\n *   console.log('User clicked, syncing...');\r\n * });\r\n * ```\r\n */\r\nexport function withInteractionSync(\r\n  control: PollingAdapterControl,\r\n  callback?: () => void\r\n): () => void {\r\n  return () => {\r\n    control.sync('interaction');\r\n    callback?.();\r\n  };\r\n}\r\n\r\n/**\r\n * Convert URL to Reality key\r\n */\r\nfunction urlToKey(url: string): string {\r\n  return url\r\n    .replace(/^https?:\\/\\/[^/]+/, '')\r\n    .replace(/\\?.*$/, '')\r\n    .replace(/^\\//, '')\r\n    .replace(/\\//g, ':');\r\n}\r\n"]}