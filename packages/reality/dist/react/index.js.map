{"version":3,"sources":["../../src/types/index.ts","../../src/utils/time.ts","../../src/transport/transport.ts","../../src/transport/embedded.ts","../../src/utils/hash.ts","../../src/client/sync-engine.ts","../../src/utils/uuid.ts","../../src/client/reality-client.ts","../../src/react/context.tsx","../../src/react/use-reality.ts","../../src/react/use-mutation.ts","../../src/react/use-sync.ts"],"names":["z","createContext","useRef","useEffect","useContext","useState","useCallback"],"mappings":";;;;;;;;;;;;AAaO,IAAM,oBAAoBA,KAAA,CAAE,IAAA,CAAK,CAAC,QAAA,EAAU,YAAA,EAAc,gBAAgB,CAAC,CAAA;AAO3E,IAAM,cAAA,GAAiBA,KAAA,CAAE,IAAA,CAAK,CAAC,aAAA,EAAe,SAAS,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS,WAAW,CAAC,CAAA;AAOlEA,MAAE,MAAA,CAAO;AAAA,EAC5C,GAAA,EAAKA,MAAE,MAAA,EAAO;AAAA,EACd,SAASA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,GAAM,WAAA,EAAY;AAAA,EACtC,IAAA,EAAMA,MAAE,MAAA,EAAO;AAAA,EACf,SAAA,EAAWA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA;AACxB,CAAC;AAQM,IAAM,gBAAA,GAAmBA,MAAE,IAAA,CAAK,CAAC,WAAW,UAAA,EAAY,WAAA,EAAa,SAAS,CAAC,CAAA;AAGrDA,MAAE,MAAA,CAAO;AAAA,EACxC,IAAA,EAAMA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,EAAI;AAAA,EACrB,gBAAgBA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,GAAM,WAAA,EAAY;AAAA,EAC7C,QAAA,EAAUA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,EAAI;AAAA,EACzB,MAAA,EAAQ,iBAAiB,QAAA;AAC3B,CAAC;AAQgCA,MAAE,MAAA,CAAO;AAAA,EACxC,KAAA,EAAOA,KAAA,CAAE,MAAA,CAAOA,KAAA,CAAE,MAAA,EAAO,EAAGA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,EAAI,CAAE,WAAA,EAAa,CAAA;AAAA,EAC1D,QAAA,EAAUA,KAAA,CAAE,MAAA,EAAO,CAAE,IAAA,EAAK;AAAA,EAC1B,IAAA,EAAM,iBAAA;AAAA,EACN,IAAA,EAAM,cAAA;AAAA,EACN,WAAWA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,GAAM,QAAA;AAC9B,CAAC;AAQM,IAAM,iBAAA,GAAoBA,MAAE,MAAA,CAAO;AAAA,EACxC,SAASA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,GAAM,WAAA,EAAY;AAAA,EACtC,IAAA,EAAMA,MAAE,MAAA,EAAO;AAAA,EACf,MAAA,EAAQA,KAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC5B,OAAA,EAASA,KAAA,CAAE,OAAA,EAAQ,CAAE,QAAA;AACvB,CAAC,CAAA;AAIM,IAAM,cAAA,GAAiBA,MAAE,MAAA,CAAO;AAAA,EACrC,OAAOA,KAAA,CAAE,MAAA,CAAOA,KAAA,CAAE,MAAA,IAAU,gBAAgB,CAAA;AAAA,EAC5C,aAAA,EAAeA,MAAE,MAAA,EAAO,CAAE,KAAI,CAAE,WAAA,GAAc,QAAA;AAChD,CAAC,CAAA;AAIM,IAAM,kBAAA,GAAqBA,MAAE,MAAA,CAAO;AAAA,EACzC,SAASA,KAAA,CAAE,MAAA,CAAOA,KAAA,CAAE,MAAA,IAAU,iBAAiB,CAAA;AAAA,EAC/C,IAAA,EAAM,cAAA;AAAA,EACN,UAAA,EAAYA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA;AACzB,CAAC,CAAA;AAc2CA,KAAA,CAAE,IAAA,CAAK,CAAC,MAAA,EAAQ,UAAA,EAAY,UAAU,CAAC;AAU5E,IAAM,0BAAA,GAA6BA,MAAE,IAAA,CAAK,CAAC,UAAU,cAAA,EAAgB,iBAAA,EAAmB,MAAM,CAAC,CAAA;AA8B/F,IAAM,oBAAA,GAAuBA,MAAE,MAAA,CAAO;AAAA;AAAA,EAE3C,OAAA,EAASA,KAAA,CAAE,KAAA,CAAMA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,EAAK,CAAA,CAAE,OAAA,CAAQ,EAAE,CAAA;AAAA;AAAA,EAE7C,IAAA,EAAM,iBAAA,CAAkB,OAAA,CAAQ,QAAQ,CAAA;AAAA;AAAA,EAExC,aAAA,EAAe,0BAAA,CAA2B,OAAA,CAAQ,MAAM,CAAA;AAAA;AAAA,EAExD,SAAA,EAAWA,KAAA,CAAE,MAAA,EAAyB,CAAE,QAAA,EAAS;AAAA;AAAA,EAEjD,UAAUA,KAAA,CAAE,MAAA,EAAO,CAAE,IAAA,GAAO,QAAA,EAAS;AAAA;AAAA,EAErC,YAAA,EAAcA,KAAA,CAAE,MAAA,CAAOA,KAAA,CAAE,QAAO,EAAGA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,EAAI,CAAE,WAAA,EAAa,EAAE,QAAA,EAAS;AAAA;AAAA,EAE5E,OAAA,EAASA,MAAE,MAAA,EAAO,CAAE,KAAI,CAAE,QAAA,EAAS,CAAE,OAAA,CAAQ,GAAK,CAAA;AAAA;AAAA,EAElD,UAAA,EAAYA,MAAE,MAAA,EAAO,CAAE,KAAI,CAAE,WAAA,EAAY,CAAE,OAAA,CAAQ,CAAC,CAAA;AAAA;AAAA,EAEpD,cAAA,EAAgBA,MAAE,MAAA,EAAO,CAAE,KAAI,CAAE,QAAA,EAAS,CAAE,OAAA,CAAQ,GAAG,CAAA;AAAA;AAAA,EAEvD,iBAAA,EAAmBA,MAAE,MAAA,EAAO,CAAE,KAAI,CAAE,QAAA,EAAS,CAAE,OAAA,CAAQ,GAAK,CAAA;AAAA;AAAA,EAE5D,KAAA,EAAOA,KAAA,CAAE,OAAA,EAAQ,CAAE,QAAQ,KAAK;AAClC,CAAC,CAAA;AAmEiCA,MAAE,MAAA,CAAO;AAAA;AAAA,EAEzC,QAAA,EAAUA,MAAE,MAAA,EAAO;AAAA;AAAA,EAEnB,KAAA,EAAOA,KAAA,CAAE,KAAA,CAAMA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,EAAK,CAAA,CAAE,OAAA,CAAQ,EAAE,CAAA;AAAA;AAAA,EAE3C,OAAA,EAASA,KAAA,CAAE,MAAA,EAAO,CAAE,QAAQ,QAAQ,CAAA;AAAA;AAAA,EAEpC,KAAA,EAAOA,MAAE,MAAA,CAAO;AAAA,IACd,OAAA,EAASA,MAAE,OAAA,EAAQ;AAAA,IACnB,GAAA,EAAKA,KAAA,CAAE,MAAA,EAAO,CAAE,QAAA;AAAS,GAC1B,EAAE,QAAA,EAAS;AAAA;AAAA,EAEZ,WAAA,EAAaA,KAAA,CAAE,KAAA,CAAMA,KAAA,CAAE,MAAA,EAAQ,CAAA,CAAE,OAAA,CAAQ,CAAC,GAAG,CAAC,CAAA;AAAA;AAAA,EAE9C,SAAA,EAAWA,MAAE,MAAA,CAAO;AAAA,IAClB,OAAA,EAASA,MAAE,OAAA,EAAQ;AAAA,IACnB,aAAaA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,GAAM,QAAA,EAAS;AAAA,IACvC,UAAUA,KAAA,CAAE,MAAA,EAAO,CAAE,GAAA,GAAM,QAAA;AAAS,GACrC,EAAE,QAAA;AACL,CAAC;;;ACrPM,SAAS,GAAA,GAAc;AAC5B,EAAA,OAAO,KAAK,GAAA,EAAI;AAClB;AA4EO,SAAS,OAAA,CAAW,OAAA,EAAqB,EAAA,EAAY,OAAA,EAA8B;AACxF,EAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAA,KAAW;AACtC,IAAA,MAAM,KAAA,GAAQ,WAAW,MAAM;AAC7B,MAAA,MAAA,CAAO,IAAI,KAAA,CAAM,OAAA,IAAW,CAAA,0BAAA,EAA6B,EAAE,IAAI,CAAC,CAAA;AAAA,IAClE,GAAG,EAAE,CAAA;AAEL,IAAA,OAAA,CAAQ,IAAA;AAAA,MACN,CAAC,KAAA,KAAU;AACT,QAAA,YAAA,CAAa,KAAK,CAAA;AAClB,QAAA,OAAA,CAAQ,KAAK,CAAA;AAAA,MACf,CAAA;AAAA,MACA,CAAC,KAAA,KAAU;AACT,QAAA,YAAA,CAAa,KAAK,CAAA;AAClB,QAAA,MAAA,CAAO,KAAK,CAAA;AAAA,MACd;AAAA,KACF;AAAA,EACF,CAAC,CAAA;AACH;AAYO,SAAS,QAAA,CACd,IACA,KAAA,EACkC;AAClC,EAAA,IAAI,KAAA,GAA8C,IAAA;AAElD,EAAA,OAAO,IAAI,IAAA,KAAwB;AACjC,IAAA,IAAI,KAAA,eAAoB,KAAK,CAAA;AAC7B,IAAA,KAAA,GAAQ,WAAW,MAAM;AACvB,MAAA,EAAA,CAAG,GAAG,IAAI,CAAA;AACV,MAAA,KAAA,GAAQ,IAAA;AAAA,IACV,GAAG,KAAK,CAAA;AAAA,EACV,CAAA;AACF;;;AC9FO,IAAM,gBAAN,MAAgD;AAAA,EAIrD,YAAY,OAAA,EAAiC;AAH7C,IAAA,IAAA,CAAQ,OAAA,uBAAyC,GAAA,EAAI;AAInD,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AAGf,IAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,OAAA,EAAS;AACjC,MAAA,IAAA,CAAK,OAAA,CAAQ,IAAI,GAAA,EAAK;AAAA,QACpB,GAAA;AAAA,QACA,MAAA,EAAQ,SAAA;AAAA,QACR,WAAA,EAAa,CAAA;AAAA,QACb,SAAA,EAAW,CAAA;AAAA,QACX,mBAAA,EAAqB,CAAA;AAAA,QACrB,OAAA,EAAS,CAAA;AAAA,QACT,cAAA,EAAgB,CAAA;AAAA,QAChB,gBAAA,EAAkB;AAAA,OACnB,CAAA;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAuB;AACrB,IAAA,OAAO,KAAK,OAAA,CAAQ,IAAA,GAAO,KAAK,IAAA,CAAK,aAAA,GAAgB,MAAA,GAAS,CAAA;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,OAAA,GAA0C;AACxC,IAAA,OAAO,MAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,OAAA,EAA6C;AACtD,IAAA,MAAM,OAAA,GAAU,KAAK,aAAA,EAAc;AAEnC,IAAA,IAAI,OAAA,CAAQ,WAAW,CAAA,EAAG;AACxB,MAAA,MAAM,IAAI,MAAM,8BAA8B,CAAA;AAAA,IAChD;AAEA,IAAA,IAAI,SAAA,GAA0B,IAAA;AAE9B,IAAA,KAAA,MAAW,UAAU,OAAA,EAAS;AAC5B,MAAA,IAAI;AACF,QAAA,MAAM,WAAW,MAAM,IAAA,CAAK,cAAA,CAAe,MAAA,CAAO,KAAK,OAAO,CAAA;AAC9D,QAAA,IAAA,CAAK,aAAA,CAAc,MAAA,CAAO,GAAA,EAAK,QAAQ,CAAA;AACvC,QAAA,OAAO,QAAA;AAAA,MACT,SAAS,KAAA,EAAO;AACd,QAAA,SAAA,GAAY,iBAAiB,KAAA,GAAQ,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,KAAK,CAAC,CAAA;AACpE,QAAA,IAAA,CAAK,aAAA,CAAc,MAAA,CAAO,GAAA,EAAK,SAAS,CAAA;AAExC,QAAA,IAAI,IAAA,CAAK,QAAQ,KAAA,EAAO;AACtB,UAAA,OAAA,CAAQ,KAAK,CAAA,2BAAA,EAA8B,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA,EAAK,UAAU,OAAO,CAAA;AAAA,QAC7E;AAAA,MACF;AAAA,IACF;AAEA,IAAA,MAAM,SAAA,IAAa,IAAI,KAAA,CAAM,8BAA8B,CAAA;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cAAA,CAAe,GAAA,EAAa,OAAA,EAA6C;AACrF,IAAA,MAAM,YAAY,GAAA,EAAI;AAEtB,IAAA,MAAM,YAAA,GAAe,KAAA,CAAM,CAAA,EAAG,GAAG,CAAA,aAAA,CAAA,EAAiB;AAAA,MAChD,MAAA,EAAQ,MAAA;AAAA,MACR,OAAA,EAAS;AAAA,QACP,cAAA,EAAgB,kBAAA;AAAA,QAChB,QAAA,EAAU;AAAA,OACZ;AAAA,MACA,IAAA,EAAM,IAAA,CAAK,SAAA,CAAU,OAAO;AAAA,KAC7B,CAAA;AAED,IAAA,MAAM,WAAW,MAAM,OAAA;AAAA,MACrB,YAAA;AAAA,MACA,KAAK,OAAA,CAAQ,OAAA;AAAA,MACb,cAAc,GAAG,CAAA,UAAA;AAAA,KACnB;AAEA,IAAA,IAAI,CAAC,SAAS,EAAA,EAAI;AAChB,MAAA,MAAM,YAAY,MAAM,QAAA,CAAS,MAAK,CAAE,KAAA,CAAM,MAAM,eAAe,CAAA;AACnE,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,gBAAA,EAAmB,SAAS,MAAM,CAAA,EAAA,EAAK,SAAS,CAAA,CAAE,CAAA;AAAA,IACpE;AAEA,IAAA,MAAM,IAAA,GAAO,MAAM,QAAA,CAAS,IAAA,EAAK;AACjC,IAAA,MAAM,MAAA,GAAS,kBAAA,CAAmB,SAAA,CAAU,IAAI,CAAA;AAEhD,IAAA,IAAI,CAAC,OAAO,OAAA,EAAS;AACnB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yBAAA,EAA4B,MAAA,CAAO,KAAA,CAAM,OAAO,CAAA,CAAE,CAAA;AAAA,IACpE;AAGA,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,GAAG,CAAA;AACnC,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,MAAA,CAAO,OAAA,GAAU,KAAI,GAAI,SAAA;AAAA,IAC3B;AAEA,IAAA,OAAO,MAAA,CAAO,IAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,aAAA,GAAgC;AACtC,IAAA,MAAM,cAAc,GAAA,EAAI;AAExB,IAAA,OAAO,MAAM,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAQ,CAAA,CACpC,MAAA,CAAO,CAAC,CAAA,KAAM,EAAE,gBAAA,GAAmB,WAAW,EAC9C,IAAA,CAAK,CAAC,GAAG,CAAA,KAAM;AAEd,MAAA,MAAM,WAAA,GAAc,EAAE,OAAA,EAAS,CAAA,EAAG,SAAS,CAAA,EAAG,QAAA,EAAU,CAAA,EAAG,SAAA,EAAW,CAAA,EAAE;AACxE,MAAA,MAAM,aAAa,WAAA,CAAY,CAAA,CAAE,MAAM,CAAA,GAAI,WAAA,CAAY,EAAE,MAAM,CAAA;AAC/D,MAAA,IAAI,UAAA,KAAe,GAAG,OAAO,UAAA;AAG7B,MAAA,MAAM,WAAA,GAAc,CAAA,CAAE,cAAA,GAAiB,CAAA,CAAE,cAAA;AACzC,MAAA,IAAI,WAAA,KAAgB,GAAG,OAAO,WAAA;AAG9B,MAAA,IAAI,CAAA,CAAE,OAAA,KAAY,CAAA,IAAK,CAAA,CAAE,YAAY,CAAA,EAAG;AACtC,QAAA,OAAO,CAAA,CAAE,UAAU,CAAA,CAAE,OAAA;AAAA,MACvB;AAGA,MAAA,OAAO,CAAA,CAAE,GAAA,CAAI,aAAA,CAAc,CAAA,CAAE,GAAG,CAAA;AAAA,IAClC,CAAC,CAAA;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAA,CAAc,KAAa,QAAA,EAA8B;AAC/D,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,GAAG,CAAA;AACnC,IAAA,IAAI,CAAC,MAAA,EAAQ;AAEb,IAAA,MAAA,CAAO,MAAA,GAAS,SAAA;AAChB,IAAA,MAAA,CAAO,cAAc,GAAA,EAAI;AACzB,IAAA,MAAA,CAAO,mBAAA,GAAsB,CAAA;AAC7B,IAAA,MAAA,CAAO,gBAAA,GAAmB,CAAA;AAE1B,IAAA,IAAI,QAAA,CAAS,IAAA,CAAK,aAAA,KAAkB,MAAA,EAAW;AAC7C,MAAA,MAAA,CAAO,iBAAiB,IAAA,CAAK,GAAA,CAAI,OAAO,cAAA,EAAgB,QAAA,CAAS,KAAK,aAAa,CAAA;AAAA,IACrF;AAGA,IAAA,KAAA,MAAW,CAAC,SAAS,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,QAAA,CAAS,IAAA,CAAK,KAAK,CAAA,EAAG;AACnE,MAAA,MAAM,UAAA,GAAa,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,OAAO,CAAA;AAC3C,MAAA,IAAI,UAAA,IAAc,eAAe,MAAA,EAAQ;AACvC,QAAA,UAAA,CAAW,MAAA,GAAS,MAAA;AAAA,MACtB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAA,CAAc,KAAa,MAAA,EAAqB;AACtD,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,GAAG,CAAA;AACnC,IAAA,IAAI,CAAC,MAAA,EAAQ;AAEb,IAAA,MAAA,CAAO,YAAY,GAAA,EAAI;AACvB,IAAA,MAAA,CAAO,mBAAA,EAAA;AAGP,IAAA,IAAI,MAAA,CAAO,uBAAuB,CAAA,EAAG;AACnC,MAAA,MAAA,CAAO,MAAA,GAAS,WAAA;AAChB,MAAA,MAAA,CAAO,gBAAA,GAAmB,GAAA,EAAI,GAAI,IAAA,CAAK,OAAA,CAAQ,iBAAA;AAAA,IACjD,CAAA,MAAA,IAAW,MAAA,CAAO,mBAAA,IAAuB,CAAA,EAAG;AAC1C,MAAA,MAAA,CAAO,MAAA,GAAS,UAAA;AAAA,IAClB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,eAAA,GAA6C;AAC3C,IAAA,OAAO,IAAI,GAAA,CAAI,IAAA,CAAK,OAAO,CAAA;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,GAAA,EAAmB;AAC3B,IAAA,IAAI,CAAC,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,GAAG,CAAA,EAAG;AAC1B,MAAA,IAAA,CAAK,OAAA,CAAQ,IAAI,GAAA,EAAK;AAAA,QACpB,GAAA;AAAA,QACA,MAAA,EAAQ,SAAA;AAAA,QACR,WAAA,EAAa,CAAA;AAAA,QACb,SAAA,EAAW,CAAA;AAAA,QACX,mBAAA,EAAqB,CAAA;AAAA,QACrB,OAAA,EAAS,CAAA;AAAA,QACT,cAAA,EAAgB,CAAA;AAAA,QAChB,gBAAA,EAAkB;AAAA,OACnB,CAAA;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,GAAA,EAAmB;AAC9B,IAAA,IAAA,CAAK,OAAA,CAAQ,OAAO,GAAG,CAAA;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,GAAA,EAAmB;AAChC,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,GAAG,CAAA;AACnC,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,MAAA,CAAO,gBAAA,GAAmB,CAAA;AAC1B,MAAA,MAAA,CAAO,MAAA,GAAS,SAAA;AAChB,MAAA,MAAA,CAAO,mBAAA,GAAsB,CAAA;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAA,GAA2B;AACzB,IAAA,KAAA,MAAW,MAAA,IAAU,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAO,EAAG;AAC1C,MAAA,MAAA,CAAO,gBAAA,GAAmB,CAAA;AAC1B,MAAA,MAAA,CAAO,MAAA,GAAS,SAAA;AAChB,MAAA,MAAA,CAAO,mBAAA,GAAsB,CAAA;AAAA,IAC/B;AAAA,EACF;AACF,CAAA;;;ACzOA,IAAM,sBAAA,uBAA6B,GAAA,EAAmC;AAmB/D,SAAS,kBAAkB,QAAA,EAAsD;AACtF,EAAA,IAAI,QAAA,EAAU;AACZ,IAAA,OAAO,sBAAA,CAAuB,IAAI,QAAQ,CAAA;AAAA,EAC5C;AAEA,EAAA,MAAM,KAAA,GAAQ,sBAAA,CAAuB,MAAA,EAAO,CAAE,IAAA,EAAK;AACnD,EAAA,OAAO,KAAA,CAAM,IAAA,GAAO,MAAA,GAAY,KAAA,CAAM,KAAA;AACxC;AAKO,SAAS,iBAAA,GAA6B;AAC3C,EAAA,OAAO,uBAAuB,IAAA,GAAO,CAAA;AACvC;AAMO,IAAM,oBAAN,MAAoD;AAAA,EAIzD,WAAA,CAAY,OAAA,GAKR,EAAC,EAAG;AACN,IAAA,IAAA,CAAK,WAAW,OAAA,CAAQ,QAAA;AACxB,IAAA,IAAA,CAAK,oBAAoB,OAAA,CAAQ,QAAA;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAuB;AACrB,IAAA,OAAO,iBAAA,EAAkB,KAAM,IAAA,CAAK,iBAAA,EAAmB,aAAY,IAAK,KAAA,CAAA;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA,EAKA,OAAA,GAA0C;AACxC,IAAA,IAAI,mBAAkB,EAAG;AACvB,MAAA,OAAO,UAAA;AAAA,IACT;AACA,IAAA,OAAO,IAAA,CAAK,iBAAA,EAAmB,OAAA,EAAQ,IAAK,UAAA;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,OAAA,EAA6C;AACtD,IAAA,MAAM,MAAA,GAAS,iBAAA,CAAkB,IAAA,CAAK,QAAQ,CAAA;AAE9C,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,OAAO,MAAA,CAAO,WAAW,OAAO,CAAA;AAAA,IAClC;AAEA,IAAA,IAAI,KAAK,iBAAA,EAAmB;AAC1B,MAAA,OAAO,IAAA,CAAK,iBAAA,CAAkB,IAAA,CAAK,OAAO,CAAA;AAAA,IAC5C;AAEA,IAAA,MAAM,IAAI,MAAM,mEAAmE,CAAA;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,IAAA,EAA+B;AAC9C,IAAA,MAAM,MAAA,GAAS,iBAAA,CAAkB,IAAA,CAAK,QAAQ,CAAA;AAE9C,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,MAAM,MAAA,CAAO,WAAW,IAAI,CAAA;AAC5B,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,CAAK,mBAAmB,UAAA,EAAY;AACtC,MAAA,MAAM,IAAA,CAAK,iBAAA,CAAkB,UAAA,CAAW,IAAI,CAAA;AAC5C,MAAA;AAAA,IACF;AAAA,EAGF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,SAAA,EAAmC;AAC7C,IAAA,IAAA,CAAK,iBAAA,GAAoB,SAAA;AAAA,EAC3B;AACF,CAAA;;;ACpGO,SAAS,UAAA,CAAW,GAAW,CAAA,EAAoB;AACxD,EAAA,IAAI,CAAA,CAAE,MAAA,KAAW,CAAA,CAAE,MAAA,EAAQ,OAAO,KAAA;AAClC,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,CAAE,QAAQ,CAAA,EAAA,EAAK;AACjC,IAAA,MAAA,IAAU,EAAE,UAAA,CAAW,CAAC,CAAA,GAAI,CAAA,CAAE,WAAW,CAAC,CAAA;AAAA,EAC5C;AACA,EAAA,OAAO,MAAA,KAAW,CAAA;AACpB;;;ACFO,IAAM,aAAN,MAAiB;AAAA,EAUtB,YAAY,MAAA,EAA0B;AARtC,IAAA,IAAA,CAAQ,KAAA,uBAA4C,GAAA,EAAI;AACxD,IAAA,IAAA,CAAQ,KAAA,uBAAiC,GAAA,EAAI;AAC7C,IAAA,IAAA,CAAQ,aAAA,uBAAqE,GAAA,EAAI;AACjF,IAAA,IAAA,CAAQ,WAAA,uBAA+B,GAAA,EAAI;AAE3C,IAAA,IAAA,CAAQ,SAAA,GAAY,KAAA;AACpB,IAAA,IAAA,CAAQ,YAAA,GAAe,CAAA;AAGrB,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,aAAA,GAAgB,SAAS,MAAM,IAAA,CAAK,YAAY,MAAM,CAAA,EAAG,MAAA,CAAO,UAAA,IAAc,EAAE,CAAA;AAAA,EACvF;AAAA;AAAA;AAAA;AAAA,EAKA,SAAA,CACE,GAAA,EACA,QAAA,EACA,OAAA,GAAgC,EAAC,EACrB;AACZ,IAAA,IAAI,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAE7B,IAAA,IAAI,CAAC,IAAA,EAAM;AACT,MAAA,IAAA,GAAO,IAAA,CAAK,UAAA,CAAc,GAAA,EAAK,OAAO,CAAA;AACtC,MAAA,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAA,EAAK,IAAyB,CAAA;AAAA,IAC/C;AAEA,IAAA,IAAA,CAAK,WAAA,CAAY,IAAI,QAAgC,CAAA;AAGrD,IAAA,QAAA,CAAS,IAAA,CAAK,cAAA,CAAe,IAAI,CAAC,CAAA;AAGlC,IAAA,IAAI,IAAA,CAAK,MAAA,KAAW,MAAA,IAAU,IAAA,CAAK,OAAA,EAAS;AAC1C,MAAA,IAAA,CAAK,aAAa,GAAG,CAAA;AAAA,IACvB;AAGA,IAAA,OAAO,MAAM;AACX,MAAA,IAAA,CAAM,WAAA,CAAY,OAAO,QAAgC,CAAA;AAGzD,MAAA,IAAI,IAAA,CAAM,WAAA,CAAY,IAAA,KAAS,CAAA,EAAG;AAChC,QAAA,IAAA,CAAK,KAAA,CAAM,OAAO,GAAG,CAAA;AACrB,QAAA,IAAA,CAAK,KAAA,CAAM,OAAO,GAAG,CAAA;AAAA,MACvB;AAAA,IACF,CAAA;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,SAAY,GAAA,EAAyC;AACnD,IAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,IAAA,OAAO,IAAA,GAAO,IAAA,CAAK,cAAA,CAAe,IAAI,CAAA,GAAI,IAAA;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAA,CAAS,IAAA,EAAgB,IAAA,GAAiB,aAAA,EAA8B;AAC5E,IAAA,KAAA,MAAW,OAAO,IAAA,EAAM;AACtB,MAAA,IAAA,CAAK,WAAA,CAAY,IAAI,GAAG,CAAA;AAAA,IAC1B;AACA,IAAA,MAAM,IAAA,CAAK,YAAY,IAAI,CAAA;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAA,CAAQ,IAAA,GAAiB,aAAA,EAA8B;AAC3D,IAAA,KAAA,MAAW,GAAA,IAAO,IAAA,CAAK,KAAA,CAAM,IAAA,EAAK,EAAG;AACnC,MAAA,IAAA,CAAK,WAAA,CAAY,IAAI,GAAG,CAAA;AAAA,IAC1B;AACA,IAAA,MAAM,IAAA,CAAK,YAAY,IAAI,CAAA;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAA,CACE,KACA,MAAA,EACY;AACZ,IAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,IAAA,IAAI,CAAC,IAAA,EAAM;AACT,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,KAAA,EAAQ,GAAG,CAAA,UAAA,CAAY,CAAA;AAAA,IACzC;AAGA,IAAA,IAAA,CAAK,eAAe,IAAA,CAAK,IAAA;AAGzB,IAAA,IAAA,CAAK,cAAA,GAAiB,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA;AACtC,IAAA,IAAA,CAAK,OAAO,IAAA,CAAK,cAAA;AAGjB,IAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAG3B,IAAA,OAAO,MAAM;AACX,MAAA,IAAI,IAAA,CAAK,iBAAiB,MAAA,EAAW;AACnC,QAAA,IAAA,CAAK,OAAO,IAAA,CAAK,YAAA;AACjB,QAAA,IAAA,CAAK,cAAA,GAAiB,MAAA;AACtB,QAAA,IAAA,CAAK,YAAA,GAAe,MAAA;AACpB,QAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAAA,MAC7B;AAAA,IACF,CAAA;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,GAAA,EAAmB;AACjC,IAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,IAAA,IAAI,IAAA,EAAM;AACR,MAAA,IAAA,CAAK,cAAA,GAAiB,MAAA;AACtB,MAAA,IAAA,CAAK,YAAA,GAAe,MAAA;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,EAAA,CAAgB,MAAwB,OAAA,EAA6C;AACnF,IAAA,IAAI,QAAA,GAAW,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,IAAI,CAAA;AAC1C,IAAA,IAAI,CAAC,QAAA,EAAU;AACb,MAAA,QAAA,uBAAe,GAAA,EAAI;AACnB,MAAA,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,IAAA,EAAM,QAAQ,CAAA;AAAA,IACvC;AACA,IAAA,QAAA,CAAS,IAAI,OAA8B,CAAA;AAE3C,IAAA,OAAO,MAAM;AACX,MAAA,QAAA,CAAU,OAAO,OAA8B,CAAA;AAAA,IACjD,CAAA;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,IAAA,CAAQ,MAAwB,IAAA,EAAe;AACrD,IAAA,MAAM,KAAA,GAAyB;AAAA,MAC7B,IAAA;AAAA,MACA,WAAW,GAAA,EAAI;AAAA,MACf;AAAA,KACF;AAEA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,IAAI,CAAA;AAC5C,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,QAAA,IAAI;AACF,UAAA,OAAA,CAAQ,KAAK,CAAA;AAAA,QACf,SAAS,KAAA,EAAO;AACd,UAAA,IAAI,IAAA,CAAK,OAAO,KAAA,EAAO;AACrB,YAAA,OAAA,CAAQ,KAAA,CAAM,kCAAkC,KAAK,CAAA;AAAA,UACvD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAA,CAAc,KAAa,OAAA,EAAqD;AACtF,IAAA,OAAO;AAAA,MACL,GAAA;AAAA,MACA,MAAM,OAAA,CAAQ,QAAA;AAAA,MACd,IAAA,EAAM,IAAA;AAAA,MACN,MAAA,EAAQ,MAAA;AAAA,MACR,KAAA,EAAO,IAAA;AAAA,MACP,SAAA,EAAW,KAAA;AAAA,MACX,SAAA,EAAW,KAAA;AAAA,MACX,OAAA,EAAS,IAAA;AAAA,MACT,UAAA,EAAY,IAAA;AAAA,MACZ,OAAA;AAAA,MACA,WAAA,sBAAiB,GAAA,EAAI;AAAA,MACrB,YAAA,EAAc,IAAA;AAAA,MACd,cAAA,EAAgB,MAAA;AAAA,MAChB,YAAA,EAAc;AAAA,KAChB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAkB,IAAA,EAAiD;AACzE,IAAA,OAAO;AAAA,MACL,KAAK,IAAA,CAAK,GAAA;AAAA,MACV,IAAA,EAAM,IAAA,CAAK,cAAA,IAAkB,IAAA,CAAK,IAAA;AAAA,MAClC,MAAM,IAAA,CAAK,IAAA;AAAA,MACX,QAAQ,IAAA,CAAK,MAAA;AAAA,MACb,OAAO,IAAA,CAAK,KAAA;AAAA,MACZ,WAAW,IAAA,CAAK,SAAA;AAAA,MAChB,WAAW,IAAA,CAAK,SAAA;AAAA,MAChB,SAAS,IAAA,CAAK,OAAA;AAAA,MACd,YAAY,IAAA,CAAK;AAAA,KACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,GAAA,EAAmB;AACtC,IAAA,IAAA,CAAK,WAAA,CAAY,IAAI,GAAG,CAAA;AACxB,IAAA,IAAA,CAAK,aAAA,EAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,YAAY,IAAA,EAA+B;AACvD,IAAA,IAAI,KAAK,SAAA,EAAW;AACpB,IAAA,IAAI,IAAA,CAAK,WAAA,CAAY,IAAA,KAAS,CAAA,EAAG;AAEjC,IAAA,IAAA,CAAK,SAAA,GAAY,IAAA;AAGjB,IAAA,MAAM,UAAA,GAAa,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,WAAW,CAAA;AAC9C,IAAA,IAAA,CAAK,YAAY,KAAA,EAAM;AAGvB,IAAA,MAAM,gBAAwC,EAAC;AAC/C,IAAA,KAAA,MAAW,OAAO,UAAA,EAAY;AAC5B,MAAA,MAAM,OAAA,GAAU,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAClC,MAAA,IAAI,YAAY,MAAA,EAAW;AACzB,QAAA,aAAA,CAAc,GAAG,CAAA,GAAI,OAAA;AAAA,MACvB,CAAA,MAAO;AACL,QAAA,aAAA,CAAc,GAAG,CAAA,GAAI,CAAA;AAAA,MACvB;AAAA,IACF;AAGA,IAAA,KAAA,MAAW,OAAO,UAAA,EAAY;AAC5B,MAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,MAAA,IAAI,IAAA,EAAM;AACR,QAAA,IAAA,CAAK,SAAA,GAAY,IAAA;AACjB,QAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAAA,MAC7B;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,KAAK,YAAA,EAAc,EAAE,IAAA,EAAM,UAAA,EAAY,MAAM,CAAA;AAElD,IAAA,IAAI;AACF,MAAA,MAAM,OAAA,GAAuB;AAAA,QAC3B,KAAA,EAAO,aAAA;AAAA,QACP,QAAA,EAAU,KAAK,MAAA,CAAO,QAAA;AAAA,QACtB,IAAA,EAAM,KAAK,MAAA,CAAO,IAAA;AAAA,QAClB,IAAA;AAAA,QACA,WAAW,GAAA;AAAI,OACjB;AAEA,MAAA,MAAM,WAAW,MAAM,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,KAAK,OAAO,CAAA;AACzD,MAAA,MAAM,IAAA,CAAK,iBAAA,CAAkB,QAAA,EAAU,UAAU,CAAA;AAEjD,MAAA,IAAA,CAAK,eAAe,GAAA,EAAI;AACxB,MAAA,IAAA,CAAK,KAAK,eAAA,EAAiB,EAAE,IAAA,EAAM,UAAA,EAAY,UAAU,CAAA;AAAA,IAC3D,SAAS,KAAA,EAAO;AACd,MAAA,MAAM,GAAA,GAAM,iBAAiB,KAAA,GAAQ,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,KAAK,CAAC,CAAA;AAGpE,MAAA,KAAA,MAAW,OAAO,UAAA,EAAY;AAC5B,QAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,QAAA,IAAI,IAAA,EAAM;AACR,UAAA,IAAA,CAAK,MAAA,GAAS,OAAA;AACd,UAAA,IAAA,CAAK,KAAA,GAAQ,GAAA;AACb,UAAA,IAAA,CAAK,SAAA,GAAY,KAAA;AACjB,UAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAAA,QAC7B;AAAA,MACF;AAEA,MAAA,IAAA,CAAK,KAAK,YAAA,EAAc,EAAE,MAAM,UAAA,EAAY,KAAA,EAAO,KAAK,CAAA;AAExD,MAAA,IAAI,IAAA,CAAK,OAAO,KAAA,EAAO;AACrB,QAAA,OAAA,CAAQ,KAAA,CAAM,yBAAyB,GAAG,CAAA;AAAA,MAC5C;AAAA,IACF,CAAA,SAAE;AACA,MAAA,IAAA,CAAK,SAAA,GAAY,KAAA;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAA,CAAkB,QAAA,EAAwB,UAAA,EAAqC;AAE3F,IAAA,IAAA,CAAK,IAAA,CAAK,aAAA,EAAe,QAAA,CAAS,IAAI,CAAA;AAGtC,IAAA,KAAA,MAAW,CAAC,KAAK,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,QAAA,CAAS,OAAO,CAAA,EAAG;AAC5D,MAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,MAAA,IAAI,CAAC,IAAA,EAAM;AAEX,MAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA,IAAK,CAAA;AAG9C,MAAA,IAAI,MAAA,CAAO,UAAU,cAAA,EAAgB;AACnC,QAAA,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAA,EAAK,MAAA,CAAO,OAAO,CAAA;AAElC,QAAA,MAAM,UAAU,IAAA,CAAK,IAAA;AACrB,QAAA,IAAA,CAAK,IAAA,GAAO;AAAA,UACV,GAAA;AAAA,UACA,SAAS,MAAA,CAAO,OAAA;AAAA,UAChB,MAAM,MAAA,CAAO,IAAA;AAAA,UACb,WAAW,QAAA,CAAS;AAAA,SACtB;AAGA,QAAA,MAAM,WAAA,GAAc,CAAC,OAAA,IAAW,CAAC,WAAW,OAAA,CAAQ,IAAA,EAAM,OAAO,IAAI,CAAA;AAErE,QAAA,IAAI,WAAA,EAAa;AAEf,UAAA,MAAM,IAAA,CAAK,YAAA,CAAa,IAAA,EAAM,MAAA,CAAO,OAAO,CAAA;AAAA,QAC9C;AAEA,QAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,QAAA,IAAA,CAAK,KAAA,GAAQ,IAAA;AACb,QAAA,IAAA,CAAK,SAAA,GAAY,KAAA;AACjB,QAAA,IAAA,CAAK,OAAA,GAAU,KAAA;AACf,QAAA,IAAA,CAAK,aAAa,GAAA,EAAI;AAEtB,QAAA,IAAA,CAAK,IAAA,CAAK,aAAA,EAAe,EAAE,GAAA,EAAK,IAAA,EAAM,KAAK,IAAA,EAAM,IAAA,EAAM,IAAA,CAAK,IAAA,EAAM,CAAA;AAAA,MACpE,CAAA,MAAO;AAEL,QAAA,IAAA,CAAK,SAAA,GAAY,KAAA;AACjB,QAAA,IAAA,CAAK,OAAA,GAAU,KAAA;AACf,QAAA,IAAA,CAAK,aAAa,GAAA,EAAI;AAAA,MACxB;AAEA,MAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAAA,IAC7B;AAGA,IAAA,KAAA,MAAW,OAAO,UAAA,EAAY;AAC5B,MAAA,IAAI,EAAE,GAAA,IAAO,QAAA,CAAS,OAAA,CAAA,EAAU;AAC9B,QAAA,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,QAAA,IAAI,IAAA,EAAM;AACR,UAAA,IAAA,CAAK,SAAA,GAAY,KAAA;AACjB,UAAA,IAAA,CAAK,OAAA,GAAU,KAAA;AACf,UAAA,IAAA,CAAK,aAAa,GAAA,EAAI;AACtB,UAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,YAAA,CAAgB,IAAA,EAA4B,aAAA,EAAwC;AAEhG,IAAA,IAAI,kBAAkB,MAAA,EAAW;AAC/B,MAAA,IAAA,CAAK,IAAA,GAAO,IAAA,CAAK,gBAAA,CAAiB,IAAA,EAAM,aAAa,CAAA;AACrD,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,OAAA,IAAW,KAAK,MAAA,CAAO,cAAA;AAEpD,IAAA,IAAI,CAAC,OAAA,IAAW,CAAC,IAAA,CAAK,IAAA,EAAM;AAC1B,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,KAAK,YAAA,EAAc;AACrB,MAAA;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,SAAA,GAAY,IAAA;AACjB,IAAA,IAAA,CAAK,MAAA,GAAS,SAAA;AACd,IAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAE3B,IAAA,IAAI;AACF,MAAA,IAAA,CAAK,YAAA,GAAe,OAAA,CAAQ,IAAA,CAAK,GAAA,EAAK,KAAK,IAAI,CAAA;AAC/C,MAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,YAAA;AAG3B,MAAA,IAAI,IAAA,CAAK,IAAA,IAAQ,IAAA,CAAK,IAAA,CAAK,OAAA,KAAY,KAAK,KAAA,CAAM,GAAA,CAAI,IAAA,CAAK,GAAG,CAAA,EAAG;AAC/D,QAAA,IAAA,CAAK,IAAA,GAAO,IAAA,CAAK,gBAAA,CAAiB,IAAA,EAAM,OAAO,CAAA;AAAA,MACjD;AAAA,IACF,SAAS,KAAA,EAAO;AACd,MAAA,IAAA,CAAK,KAAA,GAAQ,iBAAiB,KAAA,GAAQ,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,KAAK,CAAC,CAAA;AACrE,MAAA,IAAA,CAAK,MAAA,GAAS,OAAA;AAEd,MAAA,IAAI,IAAA,CAAK,OAAO,KAAA,EAAO;AACrB,QAAA,OAAA,CAAQ,KAAA,CAAM,CAAA,kCAAA,EAAqC,IAAA,CAAK,GAAG,KAAK,KAAK,CAAA;AAAA,MACvE;AAAA,IACF,CAAA,SAAE;AACA,MAAA,IAAA,CAAK,SAAA,GAAY,KAAA;AACjB,MAAA,IAAA,CAAK,YAAA,GAAe,IAAA;AACpB,MAAA,IAAA,CAAK,kBAAkB,IAAI,CAAA;AAAA,IAC7B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,gBAAA,CAAoB,MAA4B,OAAA,EAAqB;AAE3E,IAAA,IAAI,IAAA,CAAK,QAAQ,MAAA,EAAQ;AACvB,MAAA,MAAM,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,UAAU,OAAO,CAAA;AACpD,MAAA,IAAI,CAAC,OAAO,OAAA,EAAS;AACnB,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,mBAAA,EAAsB,MAAA,CAAO,KAAA,CAAM,OAAO,CAAA,CAAE,CAAA;AAAA,MAC9D;AACA,MAAA,OAAO,MAAA,CAAO,IAAA;AAAA,IAChB;AAGA,IAAA,IAAI,IAAA,CAAK,QAAQ,SAAA,EAAW;AAC1B,MAAA,OAAO,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,OAAO,CAAA;AAAA,IACvC;AAEA,IAAA,OAAO,OAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAqB,IAAA,EAAkC;AAC7D,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,cAAA,CAAe,IAAI,CAAA;AAC5C,IAAA,KAAA,MAAW,QAAA,IAAY,KAAK,WAAA,EAAa;AACvC,MAAA,IAAI;AACF,QAAA,QAAA,CAAS,WAAW,CAAA;AAAA,MACtB,SAAS,KAAA,EAAO;AACd,QAAA,IAAI,IAAA,CAAK,OAAO,KAAA,EAAO;AACrB,UAAA,OAAA,CAAQ,KAAA,CAAM,CAAA,+BAAA,EAAkC,IAAA,CAAK,GAAG,KAAK,KAAK,CAAA;AAAA,QACpE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAA,GAAwC;AACtC,IAAA,OAAO,IAAI,GAAA,CAAI,IAAA,CAAK,KAAK,CAAA;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,QAAA,GAIE;AACA,IAAA,OAAO;AAAA,MACL,cAAA,EAAgB,KAAK,KAAA,CAAM,IAAA;AAAA,MAC3B,cAAc,IAAA,CAAK,YAAA;AAAA,MACnB,WAAW,IAAA,CAAK;AAAA,KAClB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAA,GAAgB;AACd,IAAA,IAAA,CAAK,MAAM,KAAA,EAAM;AACjB,IAAA,IAAA,CAAK,MAAM,KAAA,EAAM;AACjB,IAAA,IAAA,CAAK,cAAc,KAAA,EAAM;AACzB,IAAA,IAAA,CAAK,YAAY,KAAA,EAAM;AAAA,EACzB;AACF,CAAA;;;AC7fO,SAAS,YAAA,GAAuB;AAErC,EAAA,IAAI,OAAO,MAAA,KAAW,WAAA,IAAe,OAAO,MAAA,CAAO,eAAe,UAAA,EAAY;AAC5E,IAAA,OAAO,OAAO,UAAA,EAAW;AAAA,EAC3B;AAGA,EAAA,IAAI,OAAO,MAAA,KAAW,WAAA,IAAe,OAAO,MAAA,CAAO,oBAAoB,UAAA,EAAY;AACjF,IAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,EAAE,CAAA;AAC/B,IAAA,MAAA,CAAO,gBAAgB,KAAK,CAAA;AAG5B,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,KAAA,CAAM,CAAC,IAAK,EAAA,GAAQ,EAAA;AAChC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,KAAA,CAAM,CAAC,IAAK,EAAA,GAAQ,GAAA;AAEhC,IAAA,OAAO,WAAW,KAAK,CAAA;AAAA,EACzB;AAGA,EAAA,OAAO,sCAAA,CAAuC,OAAA,CAAQ,OAAA,EAAS,CAAC,CAAA,KAAM;AACpE,IAAA,MAAM,CAAA,GAAK,IAAA,CAAK,MAAA,EAAO,GAAI,EAAA,GAAM,CAAA;AACjC,IAAA,MAAM,CAAA,GAAI,CAAA,KAAM,GAAA,GAAM,CAAA,GAAK,IAAI,CAAA,GAAO,CAAA;AACtC,IAAA,OAAO,CAAA,CAAE,SAAS,EAAE,CAAA;AAAA,EACtB,CAAC,CAAA;AACH;AAKA,SAAS,WAAW,KAAA,EAA2B;AAC7C,EAAA,MAAM,MAAM,KAAA,CAAM,IAAA,CAAK,KAAK,CAAA,CACzB,GAAA,CAAI,CAAC,CAAA,KAAM,CAAA,CAAE,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAC1C,KAAK,EAAE,CAAA;AAEV,EAAA,OAAO;AAAA,IACL,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA;AAAA,IACd,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAAA,IACf,GAAA,CAAI,KAAA,CAAM,EAAA,EAAI,EAAE,CAAA;AAAA,IAChB,GAAA,CAAI,KAAA,CAAM,EAAA,EAAI,EAAE,CAAA;AAAA,IAChB,GAAA,CAAI,KAAA,CAAM,EAAA,EAAI,EAAE;AAAA,GAClB,CAAE,KAAK,GAAG,CAAA;AACZ;;;ACXA,SAAS,mBAAA,GAA4C;AAEnD,EAAA,IAAI,mBAAkB,EAAG;AACvB,IAAA,OAAO,cAAA;AAAA,EACT;AAGA,EAAA,IAAI,OAAO,MAAA,KAAW,WAAA,IAAe,OAAO,aAAa,WAAA,EAAa;AACpE,IAAA,OAAO,QAAA;AAAA,EACT;AAGA,EAAA,IAAI,OAAO,OAAA,KAAY,WAAA,IAAe,OAAA,CAAQ,UAAU,IAAA,EAAM;AAC5D,IAAA,OAAO,cAAA;AAAA,EACT;AAEA,EAAA,OAAO,QAAA;AACT;AAKA,SAAS,gBAAgB,OAAA,EAAmD;AAE1E,EAAA,IAAI,QAAQ,SAAA,EAAW;AACrB,IAAA,OAAO,OAAA,CAAQ,SAAA;AAAA,EACjB;AAEA,EAAA,MAAM,gBAAgB,OAAA,CAAQ,aAAA,KAAkB,MAAA,GAC5C,mBAAA,KACA,OAAA,CAAQ,aAAA;AAEZ,EAAA,QAAQ,aAAA;AAAe,IACrB,KAAK,cAAA;AAEH,MAAA,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,GAAS,CAAA,EAAG;AAC9B,QAAA,OAAO,IAAI,iBAAA,CAAkB;AAAA,UAC3B,QAAA,EAAU,IAAI,aAAA,CAAc,OAAO;AAAA,SACpC,CAAA;AAAA,MACH;AACA,MAAA,OAAO,IAAI,iBAAA,EAAkB;AAAA,IAE/B,KAAK,iBAAA;AAAA,IACL,KAAK,QAAA;AAAA,IACL;AACE,MAAA,IAAI,OAAA,CAAQ,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG;AAChC,QAAA,MAAM,IAAI,MAAM,wDAAwD,CAAA;AAAA,MAC1E;AACA,MAAA,OAAO,IAAI,cAAc,OAAO,CAAA;AAAA;AAEtC;AAKO,IAAM,gBAAN,MAAoB;AAAA,EAQzB,YAAY,OAAA,EAAyB;AAHrC,IAAA,IAAA,CAAQ,aAA6B,EAAC;AAKpC,IAAA,MAAM,MAAA,GAAS,oBAAA,CAAqB,SAAA,CAAU,OAAO,CAAA;AACrD,IAAA,IAAI,CAAC,OAAO,OAAA,EAAS;AACnB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yBAAA,EAA4B,MAAA,CAAO,KAAA,CAAM,OAAO,CAAA,CAAE,CAAA;AAAA,IACpE;AAEA,IAAA,IAAA,CAAK,OAAA,GAAU;AAAA,MACb,GAAG,MAAA,CAAO,IAAA;AAAA,MACV,QAAA,EAAU,MAAA,CAAO,IAAA,CAAK,QAAA,IAAY,YAAA;AAAa,KACjD;AAGA,IAAA,IAAA,CAAK,SAAA,GAAY,eAAA,CAAgB,IAAA,CAAK,OAAO,CAAA;AAG7C,IAAA,IAAA,CAAK,UAAA,GAAa,IAAI,UAAA,CAAW;AAAA,MAC/B,QAAA,EAAU,KAAK,OAAA,CAAQ,QAAA;AAAA,MACvB,IAAA,EAAM,KAAK,OAAA,CAAQ,IAAA;AAAA,MACnB,WAAW,IAAA,CAAK,SAAA;AAAA,MAChB,KAAA,EAAO,KAAK,OAAA,CAAQ,KAAA;AAAA,MACpB,gBAAgB,IAAA,CAAK;AAAA,KACtB,CAAA;AAGD,IAAA,IAAA,CAAK,UAAA,GAAa;AAAA,MAChB,SAAA,EAAW,IAAA;AAAA,MACX,SAAA,EAAW,IAAA;AAAA,MACX,eAAe,GAAA,EAAI;AAAA,MACnB,aAAa,GAAA;AAAI,KACnB;AAGA,IAAA,IAAA,CAAK,mBAAA,EAAoB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAA,GAAmD;AACjD,IAAA,OAAO,IAAA,CAAK,UAAU,OAAA,EAAQ;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,SAAA,CACE,GAAA,EACA,QAAA,EACA,OAAA,GAAgC,EAAC,EACrB;AACZ,IAAA,OAAO,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,GAAA,EAAK,UAAU,OAAO,CAAA;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAY,GAAA,EAAyC;AACnD,IAAA,OAAO,IAAA,CAAK,UAAA,CAAW,QAAA,CAAS,GAAG,CAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,QAAA,CAAY,GAAA,EAAa,OAAA,GAAgC,EAAC,EAAG;AAC3D,IAAA,OAAO;AAAA,MACL,SAAA,EAAW,CAAC,QAAA,KAAmD;AAC7D,QAAA,OAAO,IAAA,CAAK,SAAA,CAAU,GAAA,EAAK,QAAA,EAAU,OAAO,CAAA;AAAA,MAC9C,CAAA;AAAA,MACA,QAAA,EAAU,MAAM,IAAA,CAAK,QAAA,CAAY,GAAG,CAAA;AAAA,MACpC,IAAA,EAAM,CAAC,IAAA,GAAiB,aAAA,KAAkB,KAAK,QAAA,CAAS,CAAC,GAAG,CAAA,EAAG,IAAI;AAAA,KACrE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAA,CAAS,IAAA,EAAgB,IAAA,GAAiB,aAAA,EAA8B;AAC5E,IAAA,OAAO,IAAA,CAAK,UAAA,CAAW,QAAA,CAAS,IAAA,EAAM,IAAI,CAAA;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAA,CAAQ,IAAA,GAAiB,aAAA,EAA8B;AAC3D,IAAA,OAAO,IAAA,CAAK,UAAA,CAAW,OAAA,CAAQ,IAAI,CAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAA,CACJ,GAAA,EACA,OACA,UAAA,EACA,OAAA,GAAsC,EAAC,EAC3B;AACZ,IAAA,IAAI,QAAA,GAAgC,IAAA;AAGpC,IAAA,IAAI,QAAQ,gBAAA,EAAkB;AAC5B,MAAA,QAAA,GAAW,KAAK,UAAA,CAAW,qBAAA;AAAA,QACzB,GAAA;AAAA,QACA,CAAC,OAAA,KAAY,OAAA,CAAQ,gBAAA,CAAkB,SAAS,KAAK;AAAA,OACvD;AAAA,IACF;AAEA,IAAA,IAAI;AAEF,MAAA,MAAM,MAAA,GAAS,MAAM,UAAA,CAAW,KAAK,CAAA;AAGrC,MAAA,IAAA,CAAK,UAAA,CAAW,gBAAgB,GAAG,CAAA;AAGnC,MAAA,MAAM,IAAA,CAAK,QAAA,CAAS,CAAC,GAAG,GAAG,UAAU,CAAA;AAGrC,MAAA,IAAI,OAAA,CAAQ,cAAA,IAAkB,OAAA,CAAQ,cAAA,CAAe,SAAS,CAAA,EAAG;AAC/D,QAAA,MAAM,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,cAAA,EAAgB,UAAU,CAAA;AAAA,MACxD;AAEA,MAAA,OAAO,MAAA;AAAA,IACT,SAAS,KAAA,EAAO;AAEd,MAAA,IAAI,QAAA,IAAY,OAAA,CAAQ,eAAA,KAAoB,KAAA,EAAO;AACjD,QAAA,QAAA,EAAS;AAAA,MACX;AACA,MAAA,MAAM,KAAA;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,IAAA,EAA+B;AAC9C,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,IAAA,EAAM,UAAU,CAAA;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,EAAA,CAAgB,OAAyB,OAAA,EAA6C;AACpF,IAAA,OAAO,IAAA,CAAK,UAAA,CAAW,EAAA,CAAG,KAAA,EAAO,OAAO,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,OAAA,EAAyE;AACzF,IAAA,IAAA,CAAK,cAAA,GAAiB,OAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAsB;AACpB,IAAA,OAAO,KAAK,OAAA,CAAQ,QAAA;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAA,GAAU;AACR,IAAA,OAAO,KAAK,OAAA,CAAQ,IAAA;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,eAAA,GAAkB;AAChB,IAAA,OAAO,IAAA,CAAK,SAAA,CAAU,eAAA,IAAkB,wBAAS,GAAA,EAAI;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKA,QAAA,GAAW;AACT,IAAA,OAAO,IAAA,CAAK,WAAW,QAAA,EAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,SAAA,GAAqB;AACnB,IAAA,OAAO,KAAK,UAAA,CAAW,SAAA;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,SAAA,GAAqB;AACnB,IAAA,OAAO,KAAK,UAAA,CAAW,SAAA;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAA,GAA4B;AAElC,IAAA,IAAI,OAAO,aAAa,WAAA,EAAa;AACnC,MAAA,MAAM,yBAAyB,MAAM;AACnC,QAAA,MAAM,SAAA,GAAY,SAAS,eAAA,KAAoB,SAAA;AAC/C,QAAA,IAAI,SAAA,IAAa,CAAC,IAAA,CAAK,UAAA,CAAW,SAAA,EAAW;AAE3C,UAAA,IAAA,CAAK,UAAA,CAAW,gBAAgB,GAAA,EAAI;AACpC,UAAA,IAAA,CAAK,QAAQ,OAAO,CAAA;AAAA,QACtB;AACA,QAAA,IAAA,CAAK,WAAW,SAAA,GAAY,SAAA;AAAA,MAC9B,CAAA;AAEA,MAAA,MAAM,cAAc,MAAM;AACxB,QAAA,IAAI,CAAC,IAAA,CAAK,UAAA,CAAW,SAAA,EAAW;AAC9B,UAAA,IAAA,CAAK,UAAA,CAAW,cAAc,GAAA,EAAI;AAClC,UAAA,IAAA,CAAK,QAAQ,OAAO,CAAA;AAAA,QACtB;AACA,QAAA,IAAA,CAAK,WAAW,SAAA,GAAY,IAAA;AAAA,MAC9B,CAAA;AAEA,MAAA,MAAM,aAAa,MAAM;AACvB,QAAA,IAAA,CAAK,WAAW,SAAA,GAAY,KAAA;AAAA,MAC9B,CAAA;AAEA,MAAA,QAAA,CAAS,gBAAA,CAAiB,oBAAoB,sBAAsB,CAAA;AACpE,MAAA,MAAA,CAAO,gBAAA,CAAiB,SAAS,WAAW,CAAA;AAC5C,MAAA,MAAA,CAAO,gBAAA,CAAiB,QAAQ,UAAU,CAAA;AAE1C,MAAA,IAAA,CAAK,UAAA,CAAW,KAAK,MAAM;AACzB,QAAA,QAAA,CAAS,mBAAA,CAAoB,oBAAoB,sBAAsB,CAAA;AACvE,QAAA,MAAA,CAAO,mBAAA,CAAoB,SAAS,WAAW,CAAA;AAC/C,QAAA,MAAA,CAAO,mBAAA,CAAoB,QAAQ,UAAU,CAAA;AAAA,MAC/C,CAAC,CAAA;AAAA,IACH;AAGA,IAAA,IAAI,OAAO,MAAA,KAAW,WAAA,IAAgB,MAAA,CAAmC,QAAA,EAAU;AACjF,MAAA,MAAM,WAAY,MAAA,CAAmC,QAAA;AAIrD,MAAA,MAAM,YAAA,GAAe,QAAA,CAAS,gBAAA,CAAiB,QAAA,EAAU,CAAC,KAAA,KAAkB;AAC1E,QAAA,MAAM,WAAW,KAAA,KAAU,QAAA;AAC3B,QAAA,IAAI,QAAA,IAAY,CAAC,IAAA,CAAK,UAAA,CAAW,SAAA,EAAW;AAC1C,UAAA,IAAA,CAAK,UAAA,CAAW,gBAAgB,GAAA,EAAI;AACpC,UAAA,IAAA,CAAK,QAAQ,OAAO,CAAA;AAAA,QACtB;AACA,QAAA,IAAA,CAAK,WAAW,SAAA,GAAY,QAAA;AAC5B,QAAA,IAAA,CAAK,WAAW,SAAA,GAAY,QAAA;AAAA,MAC9B,CAAC,CAAA;AAED,MAAA,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,MAAM,YAAA,CAAa,QAAQ,CAAA;AAAA,IAClD;AAGA,IAAA,IAAI,OAAO,MAAA,KAAW,WAAA,IAAe,WAAA,IAAe,MAAA,EAAQ;AAC1D,MAAA,MAAM,eAAe,MAAM;AACzB,QAAA,IAAA,CAAK,UAAU,kBAAA,IAAqB;AACpC,QAAA,IAAA,CAAK,QAAQ,WAAW,CAAA;AAAA,MAC1B,CAAA;AAEA,MAAA,MAAA,CAAO,gBAAA,CAAiB,UAAU,YAAY,CAAA;AAC9C,MAAA,IAAA,CAAK,WAAW,IAAA,CAAK,MAAM,OAAO,mBAAA,CAAoB,QAAA,EAAU,YAAY,CAAC,CAAA;AAAA,IAC/E;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAA,GAAgB;AACd,IAAA,KAAA,MAAW,OAAA,IAAW,KAAK,UAAA,EAAY;AACrC,MAAA,OAAA,EAAQ;AAAA,IACV;AACA,IAAA,IAAA,CAAK,aAAa,EAAC;AACnB,IAAA,IAAA,CAAK,WAAW,OAAA,EAAQ;AAAA,EAC1B;AACF,CAAA;AAKO,SAAS,oBAAoB,OAAA,EAAwC;AAC1E,EAAA,OAAO,IAAI,cAAc,OAAO,CAAA;AAClC;AC5XA,IAAM,cAAA,GAAiBC,oBAAoC,IAAI,CAAA;AAyBxD,SAAS,gBAAgB,EAAE,QAAA,EAAU,OAAA,EAAS,MAAA,EAAQ,gBAAe,EAAyB;AACnG,EAAA,MAAM,SAAA,GAAYC,YAAA,CAA6B,cAAA,IAAkB,IAAI,CAAA;AAGrE,EAAA,IAAI,CAAC,UAAU,OAAA,EAAS;AACtB,IAAA,SAAA,CAAU,OAAA,GAAU,oBAAoB,OAAO,CAAA;AAAA,EACjD;AAGA,EAAAC,eAAA,CAAU,MAAM;AACd,IAAA,OAAO,MAAM;AACX,MAAA,IAAI,CAAC,cAAA,IAAkB,SAAA,CAAU,OAAA,EAAS;AACxC,QAAA,SAAA,CAAU,QAAQ,OAAA,EAAQ;AAAA,MAC5B;AAAA,IACF,CAAA;AAAA,EACF,CAAA,EAAG,CAAC,cAAc,CAAC,CAAA;AAEnB,EAAA,sCACG,cAAA,CAAe,QAAA,EAAf,EAAwB,KAAA,EAAO,SAAA,CAAU,SACvC,QAAA,EACH,CAAA;AAEJ;AAOO,SAAS,gBAAA,GAAkC;AAChD,EAAA,MAAM,MAAA,GAASC,iBAAW,cAAc,CAAA;AAExC,EAAA,IAAI,CAAC,MAAA,EAAQ;AACX,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KAEF;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAKO,SAAS,oBAAA,GAAgC;AAC9C,EAAA,OAAOA,gBAAA,CAAW,cAAc,CAAA,KAAM,IAAA;AACxC;ACrBO,SAAS,UAAA,CACd,GAAA,EACA,OAAA,GAAgC,EAAC,EACZ;AACrB,EAAA,MAAM,SAAS,gBAAA,EAAiB;AAGhC,EAAA,MAAM,UAAA,GAAaF,aAAO,OAAO,CAAA;AACjC,EAAA,UAAA,CAAW,OAAA,GAAU,OAAA;AAGrB,EAAA,MAAM,CAAC,KAAA,EAAO,QAAQ,CAAA,GAAIG,eAA8B,MAAM;AAC5D,IAAA,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA,CAAY,GAAG,CAAA;AACvC,IAAA,OAAO,QAAA,IAAY;AAAA,MACjB,GAAA;AAAA,MACA,MAAM,OAAA,CAAQ,QAAA;AAAA,MACd,IAAA,EAAM,IAAA;AAAA,MACN,MAAA,EAAQ,MAAA;AAAA,MACR,KAAA,EAAO,IAAA;AAAA,MACP,SAAA,EAAW,IAAA;AAAA,MACX,SAAA,EAAW,KAAA;AAAA,MACX,OAAA,EAAS,IAAA;AAAA,MACT,UAAA,EAAY;AAAA,KACd;AAAA,EACF,CAAC,CAAA;AAGD,EAAAF,gBAAU,MAAM;AACd,IAAA,MAAM,cAAc,MAAA,CAAO,SAAA,CAAa,GAAA,EAAK,QAAA,EAAU,WAAW,OAAO,CAAA;AAEzE,IAAA,OAAO,MAAM;AACX,MAAA,WAAA,EAAY;AAAA,IACd,CAAA;AAAA,EACF,CAAA,EAAG,CAAC,MAAA,EAAQ,GAAG,CAAC,CAAA;AAGhB,EAAA,MAAM,IAAA,GAAOG,iBAAA;AAAA,IACX,OAAO,OAAiB,aAAA,KAAkB;AACxC,MAAA,MAAM,MAAA,CAAO,QAAA,CAAS,CAAC,GAAG,GAAG,IAAI,CAAA;AAAA,IACnC,CAAA;AAAA,IACA,CAAC,QAAQ,GAAG;AAAA,GACd;AAGA,EAAA,MAAM,UAAA,GAAaA,kBAAY,YAAY;AACzC,IAAA,MAAM,MAAA,CAAO,UAAA,CAAW,CAAC,GAAG,CAAC,CAAA;AAAA,EAC/B,CAAA,EAAG,CAAC,MAAA,EAAQ,GAAG,CAAC,CAAA;AAEhB,EAAA,OAAO;AAAA,IACL,MAAM,KAAA,CAAM,IAAA;AAAA,IACZ,OAAO,KAAA,CAAM,KAAA;AAAA,IACb,WAAW,KAAA,CAAM,SAAA;AAAA,IACjB,WAAW,KAAA,CAAM,SAAA;AAAA,IACjB,SAAS,KAAA,CAAM,OAAA;AAAA,IACf,MAAM,KAAA,CAAM,IAAA;AAAA,IACZ,YAAY,KAAA,CAAM,UAAA;AAAA,IAClB,IAAA;AAAA,IACA;AAAA,GACF;AACF;AA4BO,SAAS,kBAAA,CACd,IAAA,EACA,OAAA,GAAgC,EAAC,EACC;AAClC,EAAA,MAAM,SAAS,gBAAA,EAAiB;AAChC,EAAA,MAAM,UAAA,GAAaJ,aAAO,OAAO,CAAA;AACjC,EAAA,UAAA,CAAW,OAAA,GAAU,OAAA;AAGrB,EAAA,MAAM,CAAC,MAAA,EAAQ,SAAS,CAAA,GAAIG,eAA2C,MAAM;AAC3E,IAAA,MAAM,OAAA,uBAAc,GAAA,EAAiC;AACrD,IAAA,KAAA,MAAW,OAAO,IAAA,EAAM;AACtB,MAAA,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA,CAAY,GAAG,CAAA;AACvC,MAAA,OAAA,CAAQ,GAAA,CAAI,KAAK,QAAA,IAAY;AAAA,QAC3B,GAAA;AAAA,QACA,MAAM,OAAA,CAAQ,QAAA;AAAA,QACd,IAAA,EAAM,IAAA;AAAA,QACN,MAAA,EAAQ,MAAA;AAAA,QACR,KAAA,EAAO,IAAA;AAAA,QACP,SAAA,EAAW,IAAA;AAAA,QACX,SAAA,EAAW,KAAA;AAAA,QACX,OAAA,EAAS,IAAA;AAAA,QACT,UAAA,EAAY;AAAA,OACb,CAAA;AAAA,IACH;AACA,IAAA,OAAO,OAAA;AAAA,EACT,CAAC,CAAA;AAGD,EAAAF,gBAAU,MAAM;AACd,IAAA,MAAM,eAA+B,EAAC;AAEtC,IAAA,KAAA,MAAW,OAAO,IAAA,EAAM;AACtB,MAAA,MAAM,WAAA,GAAc,MAAA,CAAO,SAAA,CAAa,GAAA,EAAK,CAAC,KAAA,KAAU;AACtD,QAAA,SAAA,CAAU,CAAC,IAAA,KAAS;AAClB,UAAA,MAAM,IAAA,GAAO,IAAI,GAAA,CAAI,IAAI,CAAA;AACzB,UAAA,IAAA,CAAK,GAAA,CAAI,KAAK,KAAK,CAAA;AACnB,UAAA,OAAO,IAAA;AAAA,QACT,CAAC,CAAA;AAAA,MACH,CAAA,EAAG,WAAW,OAAO,CAAA;AAErB,MAAA,YAAA,CAAa,KAAK,WAAW,CAAA;AAAA,IAC/B;AAEA,IAAA,OAAO,MAAM;AACX,MAAA,KAAA,MAAW,eAAe,YAAA,EAAc;AACtC,QAAA,WAAA,EAAY;AAAA,MACd;AAAA,IACF,CAAA;AAAA,EACF,GAAG,CAAC,MAAA,EAAQ,KAAK,IAAA,CAAK,GAAG,CAAC,CAAC,CAAA;AAG3B,EAAA,MAAM,MAAA,uBAAa,GAAA,EAAiC;AAEpD,EAAA,KAAA,MAAW,CAAC,GAAA,EAAK,KAAK,CAAA,IAAK,MAAA,EAAQ;AACjC,IAAA,MAAA,CAAO,IAAI,GAAA,EAAK;AAAA,MACd,MAAM,KAAA,CAAM,IAAA;AAAA,MACZ,OAAO,KAAA,CAAM,KAAA;AAAA,MACb,WAAW,KAAA,CAAM,SAAA;AAAA,MACjB,WAAW,KAAA,CAAM,SAAA;AAAA,MACjB,SAAS,KAAA,CAAM,OAAA;AAAA,MACf,MAAM,KAAA,CAAM,IAAA;AAAA,MACZ,YAAY,KAAA,CAAM,UAAA;AAAA,MAClB,IAAA,EAAM,OAAO,IAAA,GAAiB,aAAA,KAAkB;AAC9C,QAAA,MAAM,MAAA,CAAO,QAAA,CAAS,CAAC,GAAG,GAAG,IAAI,CAAA;AAAA,MACnC,CAAA;AAAA,MACA,YAAY,YAAY;AACtB,QAAA,MAAM,MAAA,CAAO,UAAA,CAAW,CAAC,GAAG,CAAC,CAAA;AAAA,MAC/B;AAAA,KACD,CAAA;AAAA,EACH;AAEA,EAAA,OAAO,MAAA;AACT;AC/JO,SAAS,WAAA,CACd,GAAA,EACA,UAAA,EACA,OAAA,GAAsC,EAAC,EACT;AAC9B,EAAA,MAAM,SAAS,gBAAA,EAAiB;AAChC,EAAA,MAAM,UAAA,GAAaD,aAAO,OAAO,CAAA;AACjC,EAAA,UAAA,CAAW,OAAA,GAAU,OAAA;AAErB,EAAA,MAAM,CAAC,KAAA,EAAO,QAAQ,CAAA,GAAIG,cAAAA,CAA4B;AAAA,IACpD,IAAA,EAAM,MAAA;AAAA,IACN,KAAA,EAAO,IAAA;AAAA,IACP,SAAA,EAAW;AAAA,GACZ,CAAA;AAED,EAAA,MAAM,MAAA,GAASC,iBAAAA;AAAA,IACb,OAAO,KAAA,KAA8B;AACnC,MAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAW,OAAO,IAAA,EAAM,SAAA,EAAW,MAAM,CAAA;AAE1D,MAAA,IAAI;AACF,QAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,MAAA,CAAO,KAAK,KAAA,EAAO,UAAA,EAAY,WAAW,OAAO,CAAA;AAC7E,QAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAQ,OAAO,IAAA,EAAM,SAAA,EAAW,OAAO,CAAA;AACxD,QAAA,OAAO,MAAA;AAAA,MACT,SAAS,KAAA,EAAO;AACd,QAAA,MAAM,GAAA,GAAM,iBAAiB,KAAA,GAAQ,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,KAAK,CAAC,CAAA;AACpE,QAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAW,OAAO,GAAA,EAAK,SAAA,EAAW,OAAO,CAAA;AAC1D,QAAA,MAAM,GAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,CAAC,MAAA,EAAQ,GAAA,EAAK,UAAU;AAAA,GAC1B;AAEA,EAAA,MAAM,KAAA,GAAQA,kBAAY,MAAM;AAC9B,IAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAW,OAAO,IAAA,EAAM,SAAA,EAAW,OAAO,CAAA;AAAA,EAC7D,CAAA,EAAG,EAAE,CAAA;AAEL,EAAA,OAAO;AAAA,IACL,MAAA;AAAA,IACA,MAAM,KAAA,CAAM,IAAA;AAAA,IACZ,OAAO,KAAA,CAAM,KAAA;AAAA,IACb,WAAW,KAAA,CAAM,SAAA;AAAA,IACjB;AAAA,GACF;AACF;AA2BO,SAAS,2BAAA,CACd,YACA,cAAA,EAC8B;AAC9B,EAAA,MAAM,SAAS,gBAAA,EAAiB;AAEhC,EAAA,MAAM,CAAC,KAAA,EAAO,QAAQ,CAAA,GAAID,cAAAA,CAA4B;AAAA,IACpD,IAAA,EAAM,MAAA;AAAA,IACN,KAAA,EAAO,IAAA;AAAA,IACP,SAAA,EAAW;AAAA,GACZ,CAAA;AAED,EAAA,MAAM,MAAA,GAASC,iBAAAA;AAAA,IACb,OAAO,KAAA,KAA8B;AACnC,MAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAW,OAAO,IAAA,EAAM,SAAA,EAAW,MAAM,CAAA;AAE1D,MAAA,IAAI;AACF,QAAA,MAAM,MAAA,GAAS,MAAM,UAAA,CAAW,KAAK,CAAA;AAGrC,QAAA,MAAM,MAAA,CAAO,WAAW,cAAc,CAAA;AAEtC,QAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAQ,OAAO,IAAA,EAAM,SAAA,EAAW,OAAO,CAAA;AACxD,QAAA,OAAO,MAAA;AAAA,MACT,SAAS,KAAA,EAAO;AACd,QAAA,MAAM,GAAA,GAAM,iBAAiB,KAAA,GAAQ,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,KAAK,CAAC,CAAA;AACpE,QAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAW,OAAO,GAAA,EAAK,SAAA,EAAW,OAAO,CAAA;AAC1D,QAAA,MAAM,GAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,CAAC,MAAA,EAAQ,UAAA,EAAY,cAAA,CAAe,IAAA,CAAK,GAAG,CAAC;AAAA,GAC/C;AAEA,EAAA,MAAM,KAAA,GAAQA,kBAAY,MAAM;AAC9B,IAAA,QAAA,CAAS,EAAE,IAAA,EAAM,MAAA,EAAW,OAAO,IAAA,EAAM,SAAA,EAAW,OAAO,CAAA;AAAA,EAC7D,CAAA,EAAG,EAAE,CAAA;AAEL,EAAA,OAAO;AAAA,IACL,MAAA;AAAA,IACA,MAAM,KAAA,CAAM,IAAA;AAAA,IACZ,OAAO,KAAA,CAAM,KAAA;AAAA,IACb,WAAW,KAAA,CAAM,SAAA;AAAA,IACjB;AAAA,GACF;AACF;AChIO,SAAS,OAAA,GAAyB;AACvC,EAAA,MAAM,SAAS,gBAAA,EAAiB;AAEhC,EAAA,MAAM,QAAA,GAAWA,iBAAAA;AAAA,IACf,OAAO,IAAA,EAAgB,IAAA,GAAiB,aAAA,KAAkB;AACxD,MAAA,MAAM,MAAA,CAAO,QAAA,CAAS,IAAA,EAAM,IAAI,CAAA;AAAA,IAClC,CAAA;AAAA,IACA,CAAC,MAAM;AAAA,GACT;AAEA,EAAA,MAAM,OAAA,GAAUA,iBAAAA;AAAA,IACd,OAAO,OAAiB,aAAA,KAAkB;AACxC,MAAA,MAAM,MAAA,CAAO,QAAQ,IAAI,CAAA;AAAA,IAC3B,CAAA;AAAA,IACA,CAAC,MAAM;AAAA,GACT;AAEA,EAAA,MAAM,UAAA,GAAaA,iBAAAA;AAAA,IACjB,OAAO,IAAA,KAAmB;AACxB,MAAA,MAAM,MAAA,CAAO,WAAW,IAAI,CAAA;AAAA,IAC9B,CAAA;AAAA,IACA,CAAC,MAAM;AAAA,GACT;AAEA,EAAA,MAAM,QAAA,GAAWA,kBAAY,MAAM,MAAA,CAAO,UAAS,EAAG,CAAC,MAAM,CAAC,CAAA;AAE9D,EAAA,OAAO;AAAA,IACL,QAAA;AAAA,IACA,OAAA;AAAA,IACA,UAAA;AAAA,IACA;AAAA,GACF;AACF;AA0BO,SAAS,qBAAqB,IAAA,EAA4B;AAC/D,EAAA,MAAM,EAAE,QAAA,EAAS,GAAI,OAAA,EAAQ;AAE7B,EAAA,OAAOA,kBAAY,MAAM;AACvB,IAAA,QAAA,CAAS,MAAM,aAAa,CAAA;AAAA,EAC9B,GAAG,CAAC,QAAA,EAAU,KAAK,IAAA,CAAK,GAAG,CAAC,CAAC,CAAA;AAC/B;AAgBO,SAAS,eAAe,IAAA,EAAsB;AACnD,EAAA,MAAM,EAAE,QAAA,EAAS,GAAI,OAAA,EAAQ;AAG7B,EAAA,IAAI,OAAO,WAAW,WAAA,EAAa;AAEjC,IAAA,MAAM,EAAE,eAAA,EAAgB,GAAI,SAAA,CAAQ,OAAO,CAAA;AAC3C,IAAA,eAAA,CAAgB,MAAM;AACpB,MAAA,QAAA,CAAS,MAAM,OAAO,CAAA;AAAA,IACxB,GAAG,CAAC,IAAA,CAAK,IAAA,CAAK,GAAG,CAAC,CAAC,CAAA;AAAA,EACrB;AACF","file":"index.js","sourcesContent":["/**\r\n * @rootlodge/reality - Core Types\r\n * \r\n * Shared type definitions for the Reality socketless real-time system.\r\n * These types are used by both client and server packages.\r\n */\r\n\r\nimport { z } from 'zod';\r\n\r\n// ============================================================================\r\n// Reality Mode\r\n// ============================================================================\r\n\r\nexport const RealityModeSchema = z.enum(['native', 'sse-compat', 'polling-compat']);\r\nexport type RealityMode = z.infer<typeof RealityModeSchema>;\r\n\r\n// ============================================================================\r\n// Sync Hints\r\n// ============================================================================\r\n\r\nexport const SyncHintSchema = z.enum(['interaction', 'focus', 'idle', 'mutation', 'mount', 'reconnect']);\r\nexport type SyncHint = z.infer<typeof SyncHintSchema>;\r\n\r\n// ============================================================================\r\n// Reality Node Metadata (Global Invalidation Graph)\r\n// ============================================================================\r\n\r\nexport const RealityNodeMetaSchema = z.object({\r\n  key: z.string(),\r\n  version: z.number().int().nonnegative(),\r\n  hash: z.string(),\r\n  updatedAt: z.number().int(),\r\n});\r\n\r\nexport type RealityNodeMeta = z.infer<typeof RealityNodeMetaSchema>;\r\n\r\n// ============================================================================\r\n// Peer Summary (Mesh Awareness)\r\n// ============================================================================\r\n\r\nexport const PeerHealthSchema = z.enum(['healthy', 'degraded', 'unhealthy', 'unknown']);\r\nexport type PeerHealth = z.infer<typeof PeerHealthSchema>;\r\n\r\nexport const PeerSummarySchema = z.object({\r\n  peer: z.string().url(),\r\n  maxVersionSeen: z.number().int().nonnegative(),\r\n  lastSeen: z.number().int(),\r\n  health: PeerHealthSchema.optional(),\r\n});\r\n\r\nexport type PeerSummary = z.infer<typeof PeerSummarySchema>;\r\n\r\n// ============================================================================\r\n// Client-Server Protocol: Sync Request\r\n// ============================================================================\r\n\r\nexport const SyncRequestSchema = z.object({\r\n  known: z.record(z.string(), z.number().int().nonnegative()),\r\n  clientId: z.string().uuid(),\r\n  mode: RealityModeSchema,\r\n  hint: SyncHintSchema,\r\n  timestamp: z.number().int().optional(),\r\n});\r\n\r\nexport type SyncRequest = z.infer<typeof SyncRequestSchema>;\r\n\r\n// ============================================================================\r\n// Client-Server Protocol: Sync Response\r\n// ============================================================================\r\n\r\nexport const ChangedNodeSchema = z.object({\r\n  version: z.number().int().nonnegative(),\r\n  hash: z.string(),\r\n  source: z.string().optional(),\r\n  payload: z.unknown().optional(),\r\n});\r\n\r\nexport type ChangedNode = z.infer<typeof ChangedNodeSchema>;\r\n\r\nexport const MeshInfoSchema = z.object({\r\n  peers: z.record(z.string(), PeerHealthSchema),\r\n  serverVersion: z.number().int().nonnegative().optional(),\r\n});\r\n\r\nexport type MeshInfo = z.infer<typeof MeshInfoSchema>;\r\n\r\nexport const SyncResponseSchema = z.object({\r\n  changed: z.record(z.string(), ChangedNodeSchema),\r\n  mesh: MeshInfoSchema,\r\n  serverTime: z.number().int(),\r\n});\r\n\r\nexport type SyncResponse = z.infer<typeof SyncResponseSchema>;\r\n\r\n// ============================================================================\r\n// Execution & Persistence Modes\r\n// ============================================================================\r\n\r\n/**\r\n * Persistence mode for Reality\r\n * - 'none': No database required, in-memory only\r\n * - 'advisory': Optional DB adapters for invalidation hints\r\n * - 'external': Application manages its own persistence\r\n */\r\nexport const RealityPersistenceModeSchema = z.enum(['none', 'advisory', 'external']);\r\nexport type RealityPersistenceMode = z.infer<typeof RealityPersistenceModeSchema>;\r\n\r\n/**\r\n * Execution mode for Reality\r\n * - 'client': Browser/client-side, HTTP to external servers\r\n * - 'ssr-embedded': SSR with in-process server (TanStack/Vite)\r\n * - 'server-external': Dedicated server mode\r\n * - 'auto': Automatically detect based on environment\r\n */\r\nexport const RealityExecutionModeSchema = z.enum(['client', 'ssr-embedded', 'server-external', 'auto']);\r\nexport type RealityExecutionMode = z.infer<typeof RealityExecutionModeSchema>;\r\n\r\n// ============================================================================\r\n// Transport Interface\r\n// ============================================================================\r\n\r\n/**\r\n * Transport abstraction for Reality client\r\n * Allows switching between HTTP, embedded, or custom transports\r\n */\r\nexport interface RealityTransport {\r\n  /** Execute a sync request */\r\n  sync(request: SyncRequest): Promise<SyncResponse>;\r\n  /** Invalidate keys (for embedded/SSR mode) */\r\n  invalidate?(keys: string[]): Promise<void>;\r\n  /** Check if transport is available */\r\n  isAvailable(): boolean;\r\n  /** Get transport type identifier */\r\n  getType(): 'http' | 'embedded' | 'custom';\r\n  /** Get server status (HTTP transport only) */\r\n  getServerStatus?(): Map<string, unknown>;\r\n  /** Clear all blacklists (HTTP transport only) */\r\n  clearAllBlacklists?(): void;\r\n}\r\n\r\n// ============================================================================\r\n// Reality Client Options\r\n// ============================================================================\r\n\r\nexport const RealityOptionsSchema = z.object({\r\n  /** Base URL(s) of Reality server(s) - optional for embedded mode */\r\n  servers: z.array(z.string().url()).default([]),\r\n  /** Operating mode (compatibility) */\r\n  mode: RealityModeSchema.default('native'),\r\n  /** Execution mode - where Reality runs */\r\n  executionMode: RealityExecutionModeSchema.default('auto'),\r\n  /** Custom transport (overrides executionMode) */\r\n  transport: z.custom<RealityTransport>().optional(),\r\n  /** Client identifier (auto-generated if not provided) */\r\n  clientId: z.string().uuid().optional(),\r\n  /** Initial known versions */\r\n  initialKnown: z.record(z.string(), z.number().int().nonnegative()).optional(),\r\n  /** Request timeout in ms */\r\n  timeout: z.number().int().positive().default(10000),\r\n  /** Max retries per request */\r\n  maxRetries: z.number().int().nonnegative().default(3),\r\n  /** Base delay for exponential backoff in ms */\r\n  retryBaseDelay: z.number().int().positive().default(100),\r\n  /** Server blacklist duration in ms */\r\n  blacklistDuration: z.number().int().positive().default(30000),\r\n  /** Enable debug logging */\r\n  debug: z.boolean().default(false),\r\n});\r\n\r\nexport type RealityOptions = z.input<typeof RealityOptionsSchema>;\r\nexport type ResolvedRealityOptions = z.output<typeof RealityOptionsSchema>;\r\n\r\n// ============================================================================\r\n// Reality Key Options\r\n// ============================================================================\r\n\r\nexport interface RealityKeyOptions<T = unknown> {\r\n  /** Default value while loading */\r\n  fallback?: T;\r\n  /** Transform function for payload */\r\n  transform?: (raw: unknown) => T;\r\n  /** Validation schema */\r\n  schema?: z.ZodType<T>;\r\n  /** Stale time in ms - how long data is considered fresh */\r\n  staleTime?: number;\r\n  /** Refetch on window focus */\r\n  refetchOnFocus?: boolean;\r\n  /** Refetch on reconnect */\r\n  refetchOnReconnect?: boolean;\r\n  /** Custom fetch function for payload */\r\n  fetcher?: (key: string, meta: RealityNodeMeta) => Promise<T>;\r\n}\r\n\r\n// ============================================================================\r\n// Reality Node State (Client-side)\r\n// ============================================================================\r\n\r\nexport type RealityNodeStatus = 'idle' | 'loading' | 'syncing' | 'error' | 'stale';\r\n\r\nexport interface RealityNodeState<T = unknown> {\r\n  key: string;\r\n  data: T | undefined;\r\n  meta: RealityNodeMeta | null;\r\n  status: RealityNodeStatus;\r\n  error: Error | null;\r\n  isLoading: boolean;\r\n  isSyncing: boolean;\r\n  isStale: boolean;\r\n  lastSyncAt: number | null;\r\n}\r\n\r\n// ============================================================================\r\n// Mutation Types\r\n// ============================================================================\r\n\r\nexport interface MutationOptions<T, TInput = unknown> {\r\n  /** Optimistic update function */\r\n  optimisticUpdate?: (current: T | undefined, input: TInput) => T;\r\n  /** Rollback on error */\r\n  rollbackOnError?: boolean;\r\n  /** Invalidate keys after mutation */\r\n  invalidateKeys?: string[];\r\n}\r\n\r\nexport interface MutationResult<T> {\r\n  data: T | undefined;\r\n  error: Error | null;\r\n  isLoading: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// Server Configuration\r\n// ============================================================================\r\n\r\nexport const ServerConfigSchema = z.object({\r\n  /** Server identifier */\r\n  serverId: z.string(),\r\n  /** Peer server URLs */\r\n  peers: z.array(z.string().url()).default([]),\r\n  /** Storage adapter name */\r\n  storage: z.string().default('memory'),\r\n  /** Enable Redis acceleration */\r\n  redis: z.object({\r\n    enabled: z.boolean(),\r\n    url: z.string().optional(),\r\n  }).optional(),\r\n  /** CORS origins */\r\n  corsOrigins: z.array(z.string()).default(['*']),\r\n  /** Rate limiting */\r\n  rateLimit: z.object({\r\n    enabled: z.boolean(),\r\n    maxRequests: z.number().int().positive(),\r\n    windowMs: z.number().int().positive(),\r\n  }).optional(),\r\n});\r\n\r\nexport type ServerConfig = z.input<typeof ServerConfigSchema>;\r\nexport type ResolvedServerConfig = z.output<typeof ServerConfigSchema>;\r\n\r\n// ============================================================================\r\n// Storage Interface\r\n// ============================================================================\r\n\r\nexport interface RealityStorage {\r\n  /** Get metadata for a node */\r\n  getNode(key: string): Promise<RealityNodeMeta | null>;\r\n  /** Set metadata for a node */\r\n  setNode(meta: RealityNodeMeta): Promise<void>;\r\n  /** Increment version and update hash */\r\n  incrementVersion(key: string, hash: string): Promise<RealityNodeMeta>;\r\n  /** List nodes changed since a given version */\r\n  listChangedSince(version: number): Promise<RealityNodeMeta[]>;\r\n  /** Get multiple nodes by keys */\r\n  getNodes(keys: string[]): Promise<Map<string, RealityNodeMeta>>;\r\n  /** Get current max version across all nodes */\r\n  getMaxVersion(): Promise<number>;\r\n  /** Delete a node */\r\n  deleteNode(key: string): Promise<void>;\r\n  /** Health check */\r\n  isHealthy(): Promise<boolean>;\r\n}\r\n\r\n// ============================================================================\r\n// Database Adapter Interface\r\n// ============================================================================\r\n\r\nexport interface DatabaseAdapter {\r\n  /** Fetch payload for a key */\r\n  fetchPayload<T = unknown>(key: string): Promise<T | null>;\r\n  /** Store payload for a key */\r\n  storePayload<T = unknown>(key: string, payload: T): Promise<void>;\r\n  /** Delete payload */\r\n  deletePayload(key: string): Promise<void>;\r\n  /** Batch fetch payloads */\r\n  fetchPayloads<T = unknown>(keys: string[]): Promise<Map<string, T>>;\r\n}\r\n\r\n// ============================================================================\r\n// Compatibility Types\r\n// ============================================================================\r\n\r\nexport interface SSEMessage {\r\n  id?: string;\r\n  event?: string;\r\n  data: string;\r\n  retry?: number;\r\n}\r\n\r\nexport interface PollingConfig {\r\n  /** Minimum interval between syncs in ms */\r\n  minInterval: number;\r\n  /** Maximum interval between syncs in ms */\r\n  maxInterval: number;\r\n  /** Backoff multiplier on error */\r\n  backoffMultiplier: number;\r\n}\r\n\r\n// ============================================================================\r\n// Invalidation Adapter Interface\r\n// ============================================================================\r\n\r\n/**\r\n * Invalidation adapter for advisory database integration\r\n * Reality does NOT own your data - this is optional!\r\n */\r\nexport interface RealityInvalidationAdapter {\r\n  /** Hook called when keys should be invalidated */\r\n  onInvalidate(keys: string[]): Promise<void>;\r\n  /** Hook called before a transaction (for auto-invalidation) */\r\n  beforeTransaction?<T>(fn: () => Promise<T>): Promise<T>;\r\n  /** Hook called after a transaction (for auto-invalidation) */\r\n  afterTransaction?(affectedKeys: string[]): Promise<void>;\r\n}\r\n\r\n/**\r\n * Configuration for invalidation behavior\r\n */\r\nexport interface InvalidationConfig {\r\n  /** Invalidation adapter instance */\r\n  adapter?: RealityInvalidationAdapter;\r\n  /** Persistence mode */\r\n  mode?: RealityPersistenceMode;\r\n}\r\n\r\n// ============================================================================\r\n// Event Types\r\n// ============================================================================\r\n\r\nexport type RealityEventType = \r\n  | 'sync:start'\r\n  | 'sync:complete'\r\n  | 'sync:error'\r\n  | 'node:update'\r\n  | 'node:delete'\r\n  | 'mesh:update'\r\n  | 'server:healthy'\r\n  | 'server:unhealthy';\r\n\r\nexport interface RealityEvent<T = unknown> {\r\n  type: RealityEventType;\r\n  timestamp: number;\r\n  data: T;\r\n}\r\n\r\nexport type RealityEventHandler<T = unknown> = (event: RealityEvent<T>) => void;\r\n\r\n// ============================================================================\r\n// Utility Types\r\n// ============================================================================\r\n\r\nexport type DeepPartial<T> = {\r\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\r\n};\r\n\r\nexport type Awaitable<T> = T | Promise<T>;\r\n\r\nexport type KeyOf<T> = Extract<keyof T, string>;\r\n","/**\r\n * @rootlodge/reality - Time Utilities\r\n * \r\n * Cross-platform time utilities with clock skew handling.\r\n */\r\n\r\n/**\r\n * Get current timestamp in milliseconds\r\n */\r\nexport function now(): number {\r\n  return Date.now();\r\n}\r\n\r\n/**\r\n * Get high-resolution time if available, otherwise fall back to Date.now()\r\n */\r\nexport function hrTime(): number {\r\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\r\n    return performance.timeOrigin + performance.now();\r\n  }\r\n  return Date.now();\r\n}\r\n\r\n/**\r\n * Calculate server time offset from response\r\n */\r\nexport function calculateClockSkew(serverTime: number, requestStartTime: number, responseTime: number): number {\r\n  const roundTripTime = responseTime - requestStartTime;\r\n  const estimatedServerTime = requestStartTime + roundTripTime / 2;\r\n  return serverTime - estimatedServerTime;\r\n}\r\n\r\n/**\r\n * Adjust local time to estimated server time\r\n */\r\nexport function adjustToServerTime(localTime: number, clockSkew: number): number {\r\n  return localTime + clockSkew;\r\n}\r\n\r\n/**\r\n * Format timestamp as ISO string\r\n */\r\nexport function toISOString(timestamp: number): string {\r\n  return new Date(timestamp).toISOString();\r\n}\r\n\r\n/**\r\n * Check if a timestamp is stale (older than threshold)\r\n */\r\nexport function isStale(timestamp: number, staleThreshold: number): boolean {\r\n  return now() - timestamp > staleThreshold;\r\n}\r\n\r\n/**\r\n * Calculate exponential backoff delay\r\n */\r\nexport function backoffDelay(attempt: number, baseDelay: number, maxDelay: number = 30000): number {\r\n  const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\r\n  // Add jitter to prevent thundering herd\r\n  const jitter = delay * 0.1 * Math.random();\r\n  return Math.floor(delay + jitter);\r\n}\r\n\r\n/**\r\n * Create a deferred promise\r\n */\r\nexport interface Deferred<T> {\r\n  promise: Promise<T>;\r\n  resolve: (value: T | PromiseLike<T>) => void;\r\n  reject: (reason?: unknown) => void;\r\n}\r\n\r\nexport function createDeferred<T>(): Deferred<T> {\r\n  let resolve!: (value: T | PromiseLike<T>) => void;\r\n  let reject!: (reason?: unknown) => void;\r\n  \r\n  const promise = new Promise<T>((res, rej) => {\r\n    resolve = res;\r\n    reject = rej;\r\n  });\r\n  \r\n  return { promise, resolve, reject };\r\n}\r\n\r\n/**\r\n * Create a timeout promise\r\n */\r\nexport function timeout<T>(promise: Promise<T>, ms: number, message?: string): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    const timer = setTimeout(() => {\r\n      reject(new Error(message ?? `Operation timed out after ${ms}ms`));\r\n    }, ms);\r\n    \r\n    promise.then(\r\n      (value) => {\r\n        clearTimeout(timer);\r\n        resolve(value);\r\n      },\r\n      (error) => {\r\n        clearTimeout(timer);\r\n        reject(error);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Sleep for a specified duration\r\n */\r\nexport function sleep(ms: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Debounce a function\r\n */\r\nexport function debounce<T extends (...args: Parameters<T>) => ReturnType<T>>(\r\n  fn: T,\r\n  delay: number\r\n): (...args: Parameters<T>) => void {\r\n  let timer: ReturnType<typeof setTimeout> | null = null;\r\n  \r\n  return (...args: Parameters<T>) => {\r\n    if (timer) clearTimeout(timer);\r\n    timer = setTimeout(() => {\r\n      fn(...args);\r\n      timer = null;\r\n    }, delay);\r\n  };\r\n}\r\n\r\n/**\r\n * Throttle a function\r\n */\r\nexport function throttle<T extends (...args: Parameters<T>) => ReturnType<T>>(\r\n  fn: T,\r\n  limit: number\r\n): (...args: Parameters<T>) => void {\r\n  let lastRun = 0;\r\n  let timer: ReturnType<typeof setTimeout> | null = null;\r\n  \r\n  return (...args: Parameters<T>) => {\r\n    const elapsed = now() - lastRun;\r\n    \r\n    if (elapsed >= limit) {\r\n      lastRun = now();\r\n      fn(...args);\r\n    } else if (!timer) {\r\n      timer = setTimeout(() => {\r\n        lastRun = now();\r\n        timer = null;\r\n        fn(...args);\r\n      }, limit - elapsed);\r\n    }\r\n  };\r\n}\r\n","/**\r\n * @rootlodge/reality - Transport Layer\r\n * \r\n * Handles HTTP communication with Reality servers.\r\n * Supports all environments: Node.js, Browser, React Native, Edge.\r\n */\r\n\r\nimport type {\r\n  SyncRequest,\r\n  SyncResponse,\r\n  PeerHealth,\r\n  ResolvedRealityOptions,\r\n  RealityTransport,\r\n} from '../types';\r\nimport { SyncResponseSchema } from '../types';\r\nimport { now, timeout } from '../utils/time';\r\n\r\n/**\r\n * Server health status tracking\r\n */\r\nexport interface ServerStatus {\r\n  url: string;\r\n  health: PeerHealth;\r\n  lastSuccess: number;\r\n  lastError: number;\r\n  consecutiveFailures: number;\r\n  latency: number;\r\n  maxVersionSeen: number;\r\n  blacklistedUntil: number;\r\n}\r\n\r\n/**\r\n * HTTP Transport - communicates with external Reality servers via HTTP\r\n * Implements the RealityTransport interface\r\n */\r\nexport class HttpTransport implements RealityTransport {\r\n  private servers: Map<string, ServerStatus> = new Map();\r\n  private options: ResolvedRealityOptions;\r\n\r\n  constructor(options: ResolvedRealityOptions) {\r\n    this.options = options;\r\n    \r\n    // Initialize server status\r\n    for (const url of options.servers) {\r\n      this.servers.set(url, {\r\n        url,\r\n        health: 'unknown',\r\n        lastSuccess: 0,\r\n        lastError: 0,\r\n        consecutiveFailures: 0,\r\n        latency: 0,\r\n        maxVersionSeen: 0,\r\n        blacklistedUntil: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if HTTP transport is available\r\n   */\r\n  isAvailable(): boolean {\r\n    return this.servers.size > 0 && this.selectServers().length > 0;\r\n  }\r\n\r\n  /**\r\n   * Get transport type\r\n   */\r\n  getType(): 'http' | 'embedded' | 'custom' {\r\n    return 'http';\r\n  }\r\n\r\n  /**\r\n   * Sync with the best available server\r\n   */\r\n  async sync(request: SyncRequest): Promise<SyncResponse> {\r\n    const servers = this.selectServers();\r\n    \r\n    if (servers.length === 0) {\r\n      throw new Error('No healthy servers available');\r\n    }\r\n\r\n    let lastError: Error | null = null;\r\n    \r\n    for (const server of servers) {\r\n      try {\r\n        const response = await this.syncWithServer(server.url, request);\r\n        this.recordSuccess(server.url, response);\r\n        return response;\r\n      } catch (error) {\r\n        lastError = error instanceof Error ? error : new Error(String(error));\r\n        this.recordFailure(server.url, lastError);\r\n        \r\n        if (this.options.debug) {\r\n          console.warn(`[Reality] Sync failed with ${server.url}:`, lastError.message);\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError ?? new Error('Sync failed with all servers');\r\n  }\r\n\r\n  /**\r\n   * Sync with a specific server\r\n   */\r\n  private async syncWithServer(url: string, request: SyncRequest): Promise<SyncResponse> {\r\n    const startTime = now();\r\n    \r\n    const fetchPromise = fetch(`${url}/reality/sync`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Accept': 'application/json',\r\n      },\r\n      body: JSON.stringify(request),\r\n    });\r\n\r\n    const response = await timeout(\r\n      fetchPromise,\r\n      this.options.timeout,\r\n      `Request to ${url} timed out`\r\n    );\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text().catch(() => 'Unknown error');\r\n      throw new Error(`Server returned ${response.status}: ${errorText}`);\r\n    }\r\n\r\n    const json = await response.json();\r\n    const parsed = SyncResponseSchema.safeParse(json);\r\n    \r\n    if (!parsed.success) {\r\n      throw new Error(`Invalid response format: ${parsed.error.message}`);\r\n    }\r\n\r\n    // Record latency\r\n    const server = this.servers.get(url);\r\n    if (server) {\r\n      server.latency = now() - startTime;\r\n    }\r\n\r\n    return parsed.data;\r\n  }\r\n\r\n  /**\r\n   * Select servers in order of preference\r\n   * Prefers: healthy > known latency > alphabetical\r\n   */\r\n  private selectServers(): ServerStatus[] {\r\n    const currentTime = now();\r\n    \r\n    return Array.from(this.servers.values())\r\n      .filter((s) => s.blacklistedUntil < currentTime)\r\n      .sort((a, b) => {\r\n        // Prefer healthy servers\r\n        const healthOrder = { healthy: 0, unknown: 1, degraded: 2, unhealthy: 3 };\r\n        const healthDiff = healthOrder[a.health] - healthOrder[b.health];\r\n        if (healthDiff !== 0) return healthDiff;\r\n        \r\n        // Then prefer least-stale (highest maxVersionSeen)\r\n        const versionDiff = b.maxVersionSeen - a.maxVersionSeen;\r\n        if (versionDiff !== 0) return versionDiff;\r\n        \r\n        // Then prefer lowest latency\r\n        if (a.latency !== 0 && b.latency !== 0) {\r\n          return a.latency - b.latency;\r\n        }\r\n        \r\n        // Finally, alphabetical for stability\r\n        return a.url.localeCompare(b.url);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Record a successful sync\r\n   */\r\n  private recordSuccess(url: string, response: SyncResponse): void {\r\n    const server = this.servers.get(url);\r\n    if (!server) return;\r\n\r\n    server.health = 'healthy';\r\n    server.lastSuccess = now();\r\n    server.consecutiveFailures = 0;\r\n    server.blacklistedUntil = 0;\r\n    \r\n    if (response.mesh.serverVersion !== undefined) {\r\n      server.maxVersionSeen = Math.max(server.maxVersionSeen, response.mesh.serverVersion);\r\n    }\r\n\r\n    // Update peer health from mesh info\r\n    for (const [peerUrl, health] of Object.entries(response.mesh.peers)) {\r\n      const peerServer = this.servers.get(peerUrl);\r\n      if (peerServer && peerServer !== server) {\r\n        peerServer.health = health;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record a failed sync attempt\r\n   */\r\n  private recordFailure(url: string, _error: Error): void {\r\n    const server = this.servers.get(url);\r\n    if (!server) return;\r\n\r\n    server.lastError = now();\r\n    server.consecutiveFailures++;\r\n    \r\n    // Update health based on consecutive failures\r\n    if (server.consecutiveFailures >= 3) {\r\n      server.health = 'unhealthy';\r\n      server.blacklistedUntil = now() + this.options.blacklistDuration;\r\n    } else if (server.consecutiveFailures >= 1) {\r\n      server.health = 'degraded';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current server status\r\n   */\r\n  getServerStatus(): Map<string, ServerStatus> {\r\n    return new Map(this.servers);\r\n  }\r\n\r\n  /**\r\n   * Add a server dynamically (e.g., from mesh discovery)\r\n   */\r\n  addServer(url: string): void {\r\n    if (!this.servers.has(url)) {\r\n      this.servers.set(url, {\r\n        url,\r\n        health: 'unknown',\r\n        lastSuccess: 0,\r\n        lastError: 0,\r\n        consecutiveFailures: 0,\r\n        latency: 0,\r\n        maxVersionSeen: 0,\r\n        blacklistedUntil: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a server\r\n   */\r\n  removeServer(url: string): void {\r\n    this.servers.delete(url);\r\n  }\r\n\r\n  /**\r\n   * Clear blacklist for a server (e.g., for manual retry)\r\n   */\r\n  clearBlacklist(url: string): void {\r\n    const server = this.servers.get(url);\r\n    if (server) {\r\n      server.blacklistedUntil = 0;\r\n      server.health = 'unknown';\r\n      server.consecutiveFailures = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all blacklists\r\n   */\r\n  clearAllBlacklists(): void {\r\n    for (const server of this.servers.values()) {\r\n      server.blacklistedUntil = 0;\r\n      server.health = 'unknown';\r\n      server.consecutiveFailures = 0;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @rootlodge/reality - Embedded Transport\r\n * \r\n * In-process transport for SSR/TanStack/Vite environments.\r\n * No HTTP overhead - direct function calls to embedded server.\r\n */\r\n\r\nimport type {\r\n  SyncRequest,\r\n  SyncResponse,\r\n  RealityTransport,\r\n  RealityNodeMeta,\r\n  ChangedNode,\r\n  PeerHealth,\r\n} from '../types';\r\n\r\n/**\r\n * Embedded server interface\r\n * This is a minimal interface that embedded servers must implement\r\n */\r\nexport interface EmbeddedRealityServer {\r\n  /** Handle a sync request directly */\r\n  handleSync(request: SyncRequest): Promise<SyncResponse>;\r\n  /** Invalidate keys */\r\n  invalidate(keys: string[]): Promise<void>;\r\n  /** Get node metadata */\r\n  getNode(key: string): Promise<RealityNodeMeta | null>;\r\n  /** Update a node's version */\r\n  updateNode(key: string, hash: string): Promise<RealityNodeMeta>;\r\n  /** Get server ID */\r\n  getServerId(): string;\r\n}\r\n\r\n/**\r\n * Global registry of embedded servers for SSR context\r\n * Allows multiple embedded servers per request context\r\n */\r\nconst embeddedServerRegistry = new Map<string, EmbeddedRealityServer>();\r\n\r\n/**\r\n * Register an embedded server instance\r\n */\r\nexport function registerEmbeddedServer(serverId: string, server: EmbeddedRealityServer): void {\r\n  embeddedServerRegistry.set(serverId, server);\r\n}\r\n\r\n/**\r\n * Unregister an embedded server instance\r\n */\r\nexport function unregisterEmbeddedServer(serverId: string): void {\r\n  embeddedServerRegistry.delete(serverId);\r\n}\r\n\r\n/**\r\n * Get an embedded server by ID\r\n */\r\nexport function getEmbeddedServer(serverId?: string): EmbeddedRealityServer | undefined {\r\n  if (serverId) {\r\n    return embeddedServerRegistry.get(serverId);\r\n  }\r\n  // Return first available server if no ID specified\r\n  const first = embeddedServerRegistry.values().next();\r\n  return first.done ? undefined : first.value;\r\n}\r\n\r\n/**\r\n * Check if any embedded server is available\r\n */\r\nexport function hasEmbeddedServer(): boolean {\r\n  return embeddedServerRegistry.size > 0;\r\n}\r\n\r\n/**\r\n * Embedded Transport - in-process communication for SSR\r\n * Implements the RealityTransport interface\r\n */\r\nexport class EmbeddedTransport implements RealityTransport {\r\n  private serverId?: string;\r\n  private fallbackTransport?: RealityTransport;\r\n\r\n  constructor(options: {\r\n    /** Specific server ID to use */\r\n    serverId?: string;\r\n    /** Fallback transport if embedded not available */\r\n    fallback?: RealityTransport;\r\n  } = {}) {\r\n    this.serverId = options.serverId;\r\n    this.fallbackTransport = options.fallback;\r\n  }\r\n\r\n  /**\r\n   * Check if embedded transport is available\r\n   */\r\n  isAvailable(): boolean {\r\n    return hasEmbeddedServer() || (this.fallbackTransport?.isAvailable() ?? false);\r\n  }\r\n\r\n  /**\r\n   * Get transport type\r\n   */\r\n  getType(): 'http' | 'embedded' | 'custom' {\r\n    if (hasEmbeddedServer()) {\r\n      return 'embedded';\r\n    }\r\n    return this.fallbackTransport?.getType() ?? 'embedded';\r\n  }\r\n\r\n  /**\r\n   * Sync using embedded server or fallback\r\n   */\r\n  async sync(request: SyncRequest): Promise<SyncResponse> {\r\n    const server = getEmbeddedServer(this.serverId);\r\n    \r\n    if (server) {\r\n      return server.handleSync(request);\r\n    }\r\n    \r\n    if (this.fallbackTransport) {\r\n      return this.fallbackTransport.sync(request);\r\n    }\r\n    \r\n    throw new Error('No embedded server available and no fallback transport configured');\r\n  }\r\n\r\n  /**\r\n   * Invalidate keys using embedded server\r\n   */\r\n  async invalidate(keys: string[]): Promise<void> {\r\n    const server = getEmbeddedServer(this.serverId);\r\n    \r\n    if (server) {\r\n      await server.invalidate(keys);\r\n      return;\r\n    }\r\n    \r\n    if (this.fallbackTransport?.invalidate) {\r\n      await this.fallbackTransport.invalidate(keys);\r\n      return;\r\n    }\r\n    \r\n    // Silently ignore if no server available\r\n  }\r\n\r\n  /**\r\n   * Set fallback transport\r\n   */\r\n  setFallback(transport: RealityTransport): void {\r\n    this.fallbackTransport = transport;\r\n  }\r\n}\r\n\r\n/**\r\n * Create an auto-selecting transport\r\n * Prefers embedded, falls back to HTTP\r\n */\r\nexport function createAutoTransport(options: {\r\n  /** HTTP server URLs for fallback */\r\n  servers?: string[];\r\n  /** Preferred embedded server ID */\r\n  embeddedServerId?: string;\r\n  /** Custom fallback transport */\r\n  fallback?: RealityTransport;\r\n}): RealityTransport {\r\n  // If we have an embedded server, use it with HTTP fallback\r\n  if (hasEmbeddedServer()) {\r\n    return new EmbeddedTransport({\r\n      serverId: options.embeddedServerId,\r\n      fallback: options.fallback,\r\n    });\r\n  }\r\n  \r\n  // Otherwise return the fallback or throw\r\n  if (options.fallback) {\r\n    return options.fallback;\r\n  }\r\n  \r\n  throw new Error('No embedded server available and no fallback transport provided');\r\n}\r\n\r\n/**\r\n * Simple in-memory embedded server for SSR\r\n * Use this for basic SSR scenarios where you don't need full server features\r\n */\r\nexport class SimpleEmbeddedServer implements EmbeddedRealityServer {\r\n  private nodes: Map<string, RealityNodeMeta> = new Map();\r\n  private maxVersion = 0;\r\n  private serverId: string;\r\n\r\n  constructor(serverId = 'embedded-ssr') {\r\n    this.serverId = serverId;\r\n  }\r\n\r\n  getServerId(): string {\r\n    return this.serverId;\r\n  }\r\n\r\n  async handleSync(request: SyncRequest): Promise<SyncResponse> {\r\n    const changed: Record<string, ChangedNode> = {};\r\n    \r\n    for (const [key, clientVersion] of Object.entries(request.known)) {\r\n      const meta = this.nodes.get(key);\r\n      \r\n      if (!meta) {\r\n        // Key doesn't exist\r\n        changed[key] = {\r\n          version: 0,\r\n          hash: '',\r\n          source: this.serverId,\r\n        };\r\n        continue;\r\n      }\r\n      \r\n      if (meta.version > clientVersion) {\r\n        changed[key] = {\r\n          version: meta.version,\r\n          hash: meta.hash,\r\n          source: this.serverId,\r\n        };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      changed,\r\n      mesh: {\r\n        peers: {} as Record<string, PeerHealth>,\r\n        serverVersion: this.maxVersion,\r\n      },\r\n      serverTime: Date.now(),\r\n    };\r\n  }\r\n\r\n  async invalidate(keys: string[]): Promise<void> {\r\n    for (const key of keys) {\r\n      const existing = this.nodes.get(key);\r\n      if (existing) {\r\n        this.maxVersion++;\r\n        this.nodes.set(key, {\r\n          ...existing,\r\n          version: this.maxVersion,\r\n          updatedAt: Date.now(),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  async getNode(key: string): Promise<RealityNodeMeta | null> {\r\n    return this.nodes.get(key) ?? null;\r\n  }\r\n\r\n  async updateNode(key: string, hash: string): Promise<RealityNodeMeta> {\r\n    this.maxVersion++;\r\n    const meta: RealityNodeMeta = {\r\n      key,\r\n      version: this.maxVersion,\r\n      hash,\r\n      updatedAt: Date.now(),\r\n    };\r\n    this.nodes.set(key, meta);\r\n    return meta;\r\n  }\r\n\r\n  /**\r\n   * Register this server in the global registry\r\n   */\r\n  register(): void {\r\n    registerEmbeddedServer(this.serverId, this);\r\n  }\r\n\r\n  /**\r\n   * Unregister this server\r\n   */\r\n  unregister(): void {\r\n    unregisterEmbeddedServer(this.serverId);\r\n  }\r\n}\r\n\r\n/**\r\n * Create and register a simple embedded server\r\n */\r\nexport function createSimpleEmbeddedServer(serverId = 'embedded-ssr'): SimpleEmbeddedServer {\r\n  const server = new SimpleEmbeddedServer(serverId);\r\n  server.register();\r\n  return server;\r\n}\r\n","/**\r\n * @rootlodge/reality - Hash Utilities\r\n * \r\n * Deterministic hashing for content comparison.\r\n * Works in all environments: Node.js, Browser, React Native, Edge.\r\n */\r\n\r\n/**\r\n * Generate a deterministic hash from any serializable value.\r\n * Uses a fast, non-cryptographic hash suitable for content comparison.\r\n */\r\nexport function createHash(data: unknown): string {\r\n  const str = typeof data === 'string' ? data : JSON.stringify(data, sortReplacer);\r\n  return fnv1aHash(str);\r\n}\r\n\r\n/**\r\n * FNV-1a hash implementation\r\n * Fast, simple, good distribution for our use case\r\n */\r\nfunction fnv1aHash(str: string): string {\r\n  let hash = 2166136261; // FNV offset basis\r\n  for (let i = 0; i < str.length; i++) {\r\n    hash ^= str.charCodeAt(i);\r\n    // FNV prime multiplication using bit operations\r\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\r\n  }\r\n  // Convert to unsigned 32-bit and then to hex\r\n  return (hash >>> 0).toString(16).padStart(8, '0');\r\n}\r\n\r\n/**\r\n * JSON replacer that sorts object keys for deterministic serialization\r\n */\r\nfunction sortReplacer(_key: string, value: unknown): unknown {\r\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\r\n    return value;\r\n  }\r\n  return Object.keys(value as Record<string, unknown>)\r\n    .sort()\r\n    .reduce((sorted, key) => {\r\n      sorted[key] = (value as Record<string, unknown>)[key];\r\n      return sorted;\r\n    }, {} as Record<string, unknown>);\r\n}\r\n\r\n/**\r\n * Compare two hashes for equality\r\n */\r\nexport function hashEquals(a: string, b: string): boolean {\r\n  if (a.length !== b.length) return false;\r\n  let result = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    result |= a.charCodeAt(i) ^ b.charCodeAt(i);\r\n  }\r\n  return result === 0;\r\n}\r\n\r\n/**\r\n * Generate a composite hash from multiple hashes\r\n */\r\nexport function combineHashes(hashes: string[]): string {\r\n  return createHash(hashes.sort().join(':'));\r\n}\r\n","/**\r\n * @rootlodge/reality - Sync Engine\r\n * \r\n * Core synchronization logic for the Reality client.\r\n * Handles batching, deduplication, and state reconciliation.\r\n */\r\n\r\nimport type {\r\n  RealityNodeMeta,\r\n  RealityNodeState,\r\n  SyncRequest,\r\n  SyncResponse,\r\n  SyncHint,\r\n  RealityMode,\r\n  RealityEventType,\r\n  RealityEvent,\r\n  RealityEventHandler,\r\n  RealityKeyOptions,\r\n  RealityTransport,\r\n} from '../types';\r\nimport { now, debounce } from '../utils/time';\r\nimport { hashEquals } from '../utils/hash';\r\n\r\n/**\r\n * Subscription callback type\r\n */\r\ntype SubscriptionCallback<T = unknown> = (state: RealityNodeState<T>) => void;\r\n\r\n/**\r\n * Sync engine configuration\r\n */\r\ninterface SyncEngineConfig {\r\n  clientId: string;\r\n  mode: RealityMode;\r\n  transport: RealityTransport;\r\n  debug: boolean;\r\n  batchDelay?: number;\r\n  defaultFetcher?: (key: string, meta: RealityNodeMeta) => Promise<unknown>;\r\n}\r\n\r\n/**\r\n * Internal node state with additional tracking\r\n */\r\ninterface InternalNodeState<T = unknown> extends RealityNodeState<T> {\r\n  options: RealityKeyOptions<T>;\r\n  subscribers: Set<SubscriptionCallback<T>>;\r\n  pendingFetch: Promise<T> | null;\r\n  optimisticData: T | undefined;\r\n  rollbackData: T | undefined;\r\n}\r\n\r\n/**\r\n * Sync Engine - manages all Reality node states\r\n */\r\nexport class SyncEngine {\r\n  private config: SyncEngineConfig;\r\n  private nodes: Map<string, InternalNodeState> = new Map();\r\n  private known: Map<string, number> = new Map();\r\n  private eventHandlers: Map<RealityEventType, Set<RealityEventHandler>> = new Map();\r\n  private pendingSync: Set<string> = new Set();\r\n  private debouncedSync: () => void;\r\n  private isSyncing = false;\r\n  private lastSyncTime = 0;\r\n\r\n  constructor(config: SyncEngineConfig) {\r\n    this.config = config;\r\n    this.debouncedSync = debounce(() => this.performSync('idle'), config.batchDelay ?? 50);\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a Reality node\r\n   */\r\n  subscribe<T>(\r\n    key: string,\r\n    callback: SubscriptionCallback<T>,\r\n    options: RealityKeyOptions<T> = {}\r\n  ): () => void {\r\n    let node = this.nodes.get(key) as InternalNodeState<T> | undefined;\r\n\r\n    if (!node) {\r\n      node = this.createNode<T>(key, options);\r\n      this.nodes.set(key, node as InternalNodeState);\r\n    }\r\n\r\n    node.subscribers.add(callback as SubscriptionCallback);\r\n\r\n    // Immediately notify with current state\r\n    callback(this.getPublicState(node));\r\n\r\n    // Schedule sync if needed\r\n    if (node.status === 'idle' || node.isStale) {\r\n      this.scheduleSync(key);\r\n    }\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      node!.subscribers.delete(callback as SubscriptionCallback);\r\n      \r\n      // Clean up node if no more subscribers\r\n      if (node!.subscribers.size === 0) {\r\n        this.nodes.delete(key);\r\n        this.known.delete(key);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current state of a node\r\n   */\r\n  getState<T>(key: string): RealityNodeState<T> | null {\r\n    const node = this.nodes.get(key) as InternalNodeState<T> | undefined;\r\n    return node ? this.getPublicState(node) : null;\r\n  }\r\n\r\n  /**\r\n   * Trigger a sync for specific keys\r\n   */\r\n  async syncKeys(keys: string[], hint: SyncHint = 'interaction'): Promise<void> {\r\n    for (const key of keys) {\r\n      this.pendingSync.add(key);\r\n    }\r\n    await this.performSync(hint);\r\n  }\r\n\r\n  /**\r\n   * Trigger a sync for all subscribed keys\r\n   */\r\n  async syncAll(hint: SyncHint = 'interaction'): Promise<void> {\r\n    for (const key of this.nodes.keys()) {\r\n      this.pendingSync.add(key);\r\n    }\r\n    await this.performSync(hint);\r\n  }\r\n\r\n  /**\r\n   * Apply optimistic update\r\n   */\r\n  applyOptimisticUpdate<T>(\r\n    key: string,\r\n    update: (current: T | undefined) => T\r\n  ): () => void {\r\n    const node = this.nodes.get(key) as InternalNodeState<T> | undefined;\r\n    if (!node) {\r\n      throw new Error(`Node ${key} not found`);\r\n    }\r\n\r\n    // Store rollback data\r\n    node.rollbackData = node.data;\r\n    \r\n    // Apply optimistic update\r\n    node.optimisticData = update(node.data);\r\n    node.data = node.optimisticData;\r\n\r\n    // Notify subscribers\r\n    this.notifySubscribers(node);\r\n\r\n    // Return rollback function\r\n    return () => {\r\n      if (node.rollbackData !== undefined) {\r\n        node.data = node.rollbackData;\r\n        node.optimisticData = undefined;\r\n        node.rollbackData = undefined;\r\n        this.notifySubscribers(node);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear optimistic state after server confirms\r\n   */\r\n  clearOptimistic(key: string): void {\r\n    const node = this.nodes.get(key);\r\n    if (node) {\r\n      node.optimisticData = undefined;\r\n      node.rollbackData = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add event handler\r\n   */\r\n  on<T = unknown>(type: RealityEventType, handler: RealityEventHandler<T>): () => void {\r\n    let handlers = this.eventHandlers.get(type);\r\n    if (!handlers) {\r\n      handlers = new Set();\r\n      this.eventHandlers.set(type, handlers);\r\n    }\r\n    handlers.add(handler as RealityEventHandler);\r\n\r\n    return () => {\r\n      handlers!.delete(handler as RealityEventHandler);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Emit event\r\n   */\r\n  private emit<T>(type: RealityEventType, data: T): void {\r\n    const event: RealityEvent<T> = {\r\n      type,\r\n      timestamp: now(),\r\n      data,\r\n    };\r\n\r\n    const handlers = this.eventHandlers.get(type);\r\n    if (handlers) {\r\n      for (const handler of handlers) {\r\n        try {\r\n          handler(event);\r\n        } catch (error) {\r\n          if (this.config.debug) {\r\n            console.error(`[Reality] Event handler error:`, error);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new internal node state\r\n   */\r\n  private createNode<T>(key: string, options: RealityKeyOptions<T>): InternalNodeState<T> {\r\n    return {\r\n      key,\r\n      data: options.fallback,\r\n      meta: null,\r\n      status: 'idle',\r\n      error: null,\r\n      isLoading: false,\r\n      isSyncing: false,\r\n      isStale: true,\r\n      lastSyncAt: null,\r\n      options,\r\n      subscribers: new Set(),\r\n      pendingFetch: null,\r\n      optimisticData: undefined,\r\n      rollbackData: undefined,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Convert internal state to public state\r\n   */\r\n  private getPublicState<T>(node: InternalNodeState<T>): RealityNodeState<T> {\r\n    return {\r\n      key: node.key,\r\n      data: node.optimisticData ?? node.data,\r\n      meta: node.meta,\r\n      status: node.status,\r\n      error: node.error,\r\n      isLoading: node.isLoading,\r\n      isSyncing: node.isSyncing,\r\n      isStale: node.isStale,\r\n      lastSyncAt: node.lastSyncAt,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Schedule a sync operation\r\n   */\r\n  private scheduleSync(key: string): void {\r\n    this.pendingSync.add(key);\r\n    this.debouncedSync();\r\n  }\r\n\r\n  /**\r\n   * Perform sync with server\r\n   */\r\n  private async performSync(hint: SyncHint): Promise<void> {\r\n    if (this.isSyncing) return;\r\n    if (this.pendingSync.size === 0) return;\r\n\r\n    this.isSyncing = true;\r\n    \r\n    // Get keys to sync and clear pending set\r\n    const keysToSync = Array.from(this.pendingSync);\r\n    this.pendingSync.clear();\r\n\r\n    // Build known versions map for keys we're syncing\r\n    const knownVersions: Record<string, number> = {};\r\n    for (const key of keysToSync) {\r\n      const version = this.known.get(key);\r\n      if (version !== undefined) {\r\n        knownVersions[key] = version;\r\n      } else {\r\n        knownVersions[key] = 0;\r\n      }\r\n    }\r\n\r\n    // Mark nodes as syncing\r\n    for (const key of keysToSync) {\r\n      const node = this.nodes.get(key);\r\n      if (node) {\r\n        node.isSyncing = true;\r\n        this.notifySubscribers(node);\r\n      }\r\n    }\r\n\r\n    this.emit('sync:start', { keys: keysToSync, hint });\r\n\r\n    try {\r\n      const request: SyncRequest = {\r\n        known: knownVersions,\r\n        clientId: this.config.clientId,\r\n        mode: this.config.mode,\r\n        hint,\r\n        timestamp: now(),\r\n      };\r\n\r\n      const response = await this.config.transport.sync(request);\r\n      await this.reconcileResponse(response, keysToSync);\r\n      \r\n      this.lastSyncTime = now();\r\n      this.emit('sync:complete', { keys: keysToSync, response });\r\n    } catch (error) {\r\n      const err = error instanceof Error ? error : new Error(String(error));\r\n      \r\n      // Mark nodes as error\r\n      for (const key of keysToSync) {\r\n        const node = this.nodes.get(key);\r\n        if (node) {\r\n          node.status = 'error';\r\n          node.error = err;\r\n          node.isSyncing = false;\r\n          this.notifySubscribers(node);\r\n        }\r\n      }\r\n\r\n      this.emit('sync:error', { keys: keysToSync, error: err });\r\n      \r\n      if (this.config.debug) {\r\n        console.error(`[Reality] Sync error:`, err);\r\n      }\r\n    } finally {\r\n      this.isSyncing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reconcile server response with local state\r\n   */\r\n  private async reconcileResponse(response: SyncResponse, keysToSync: string[]): Promise<void> {\r\n    // Process mesh updates\r\n    this.emit('mesh:update', response.mesh);\r\n\r\n    // Process changed nodes\r\n    for (const [key, change] of Object.entries(response.changed)) {\r\n      const node = this.nodes.get(key);\r\n      if (!node) continue;\r\n\r\n      const currentVersion = this.known.get(key) ?? 0;\r\n      \r\n      // Only update if version is newer\r\n      if (change.version > currentVersion) {\r\n        this.known.set(key, change.version);\r\n        \r\n        const oldMeta = node.meta;\r\n        node.meta = {\r\n          key,\r\n          version: change.version,\r\n          hash: change.hash,\r\n          updatedAt: response.serverTime,\r\n        };\r\n\r\n        // Check if hash changed (actual data change)\r\n        const hashChanged = !oldMeta || !hashEquals(oldMeta.hash, change.hash);\r\n        \r\n        if (hashChanged) {\r\n          // Fetch new payload\r\n          await this.fetchPayload(node, change.payload);\r\n        }\r\n\r\n        node.status = 'idle';\r\n        node.error = null;\r\n        node.isSyncing = false;\r\n        node.isStale = false;\r\n        node.lastSyncAt = now();\r\n\r\n        this.emit('node:update', { key, meta: node.meta, data: node.data });\r\n      } else {\r\n        // No change needed\r\n        node.isSyncing = false;\r\n        node.isStale = false;\r\n        node.lastSyncAt = now();\r\n      }\r\n\r\n      this.notifySubscribers(node);\r\n    }\r\n\r\n    // Mark non-changed keys as synced\r\n    for (const key of keysToSync) {\r\n      if (!(key in response.changed)) {\r\n        const node = this.nodes.get(key);\r\n        if (node) {\r\n          node.isSyncing = false;\r\n          node.isStale = false;\r\n          node.lastSyncAt = now();\r\n          this.notifySubscribers(node);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch payload for a node\r\n   */\r\n  private async fetchPayload<T>(node: InternalNodeState<T>, inlinePayload?: unknown): Promise<void> {\r\n    // If payload was included in sync response, use it\r\n    if (inlinePayload !== undefined) {\r\n      node.data = this.transformPayload(node, inlinePayload);\r\n      return;\r\n    }\r\n\r\n    // Otherwise, fetch using configured fetcher\r\n    const fetcher = node.options.fetcher ?? this.config.defaultFetcher;\r\n    \r\n    if (!fetcher || !node.meta) {\r\n      return;\r\n    }\r\n\r\n    // Avoid duplicate fetches\r\n    if (node.pendingFetch) {\r\n      return;\r\n    }\r\n\r\n    node.isLoading = true;\r\n    node.status = 'loading';\r\n    this.notifySubscribers(node);\r\n\r\n    try {\r\n      node.pendingFetch = fetcher(node.key, node.meta) as Promise<T>;\r\n      const payload = await node.pendingFetch;\r\n      \r\n      // Only update if this is still the current version\r\n      if (node.meta && node.meta.version === this.known.get(node.key)) {\r\n        node.data = this.transformPayload(node, payload);\r\n      }\r\n    } catch (error) {\r\n      node.error = error instanceof Error ? error : new Error(String(error));\r\n      node.status = 'error';\r\n      \r\n      if (this.config.debug) {\r\n        console.error(`[Reality] Payload fetch error for ${node.key}:`, error);\r\n      }\r\n    } finally {\r\n      node.isLoading = false;\r\n      node.pendingFetch = null;\r\n      this.notifySubscribers(node);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform payload using node options\r\n   */\r\n  private transformPayload<T>(node: InternalNodeState<T>, payload: unknown): T {\r\n    // Validate if schema provided\r\n    if (node.options.schema) {\r\n      const result = node.options.schema.safeParse(payload);\r\n      if (!result.success) {\r\n        throw new Error(`Validation failed: ${result.error.message}`);\r\n      }\r\n      return result.data;\r\n    }\r\n\r\n    // Transform if transformer provided\r\n    if (node.options.transform) {\r\n      return node.options.transform(payload);\r\n    }\r\n\r\n    return payload as T;\r\n  }\r\n\r\n  /**\r\n   * Notify all subscribers of a node\r\n   */\r\n  private notifySubscribers<T>(node: InternalNodeState<T>): void {\r\n    const publicState = this.getPublicState(node);\r\n    for (const callback of node.subscribers) {\r\n      try {\r\n        callback(publicState);\r\n      } catch (error) {\r\n        if (this.config.debug) {\r\n          console.error(`[Reality] Subscriber error for ${node.key}:`, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all known versions\r\n   */\r\n  getKnownVersions(): Map<string, number> {\r\n    return new Map(this.known);\r\n  }\r\n\r\n  /**\r\n   * Get sync statistics\r\n   */\r\n  getStats(): {\r\n    subscribedKeys: number;\r\n    lastSyncTime: number;\r\n    isSyncing: boolean;\r\n  } {\r\n    return {\r\n      subscribedKeys: this.nodes.size,\r\n      lastSyncTime: this.lastSyncTime,\r\n      isSyncing: this.isSyncing,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy the sync engine\r\n   */\r\n  destroy(): void {\r\n    this.nodes.clear();\r\n    this.known.clear();\r\n    this.eventHandlers.clear();\r\n    this.pendingSync.clear();\r\n  }\r\n}\r\n","/**\r\n * @rootlodge/reality - UUID Utilities\r\n * \r\n * Cross-platform UUID generation for client identification.\r\n */\r\n\r\n/**\r\n * Generate a v4 UUID\r\n * Works in all environments: Node.js, Browser, React Native, Edge\r\n */\r\nexport function generateUUID(): string {\r\n  // Use crypto.randomUUID if available (modern browsers, Node 19+)\r\n  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\r\n    return crypto.randomUUID();\r\n  }\r\n\r\n  // Fallback implementation using crypto.getRandomValues\r\n  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {\r\n    const bytes = new Uint8Array(16);\r\n    crypto.getRandomValues(bytes);\r\n    \r\n    // Set version (4) and variant (RFC 4122)\r\n    bytes[6] = (bytes[6]! & 0x0f) | 0x40;\r\n    bytes[8] = (bytes[8]! & 0x3f) | 0x80;\r\n\r\n    return formatUUID(bytes);\r\n  }\r\n\r\n  // Last resort: Math.random (not cryptographically secure)\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    const r = (Math.random() * 16) | 0;\r\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n    return v.toString(16);\r\n  });\r\n}\r\n\r\n/**\r\n * Format bytes as UUID string\r\n */\r\nfunction formatUUID(bytes: Uint8Array): string {\r\n  const hex = Array.from(bytes)\r\n    .map((b) => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return [\r\n    hex.slice(0, 8),\r\n    hex.slice(8, 12),\r\n    hex.slice(12, 16),\r\n    hex.slice(16, 20),\r\n    hex.slice(20, 32),\r\n  ].join('-');\r\n}\r\n\r\n/**\r\n * Validate UUID format\r\n */\r\nexport function isValidUUID(str: string): boolean {\r\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n  return uuidRegex.test(str);\r\n}\r\n\r\n/**\r\n * Parse UUID to bytes\r\n */\r\nexport function parseUUID(uuid: string): Uint8Array | null {\r\n  if (!isValidUUID(uuid)) return null;\r\n  \r\n  const hex = uuid.replace(/-/g, '');\r\n  const bytes = new Uint8Array(16);\r\n  \r\n  for (let i = 0; i < 16; i++) {\r\n    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);\r\n  }\r\n  \r\n  return bytes;\r\n}\r\n","/**\r\n * @rootlodge/reality - Reality Client\r\n * \r\n * Main client class for the Reality system.\r\n * Provides the core API for subscribing to real-time data.\r\n */\r\n\r\nimport type {\r\n  RealityOptions,\r\n  ResolvedRealityOptions,\r\n  RealityKeyOptions,\r\n  RealityNodeState,\r\n  RealityNodeMeta,\r\n  SyncHint,\r\n  RealityEventType,\r\n  RealityEventHandler,\r\n  MutationOptions,\r\n  RealityTransport,\r\n  RealityExecutionMode,\r\n} from '../types';\r\nimport { RealityOptionsSchema } from '../types';\r\nimport { HttpTransport } from '../transport/transport';\r\nimport { EmbeddedTransport, hasEmbeddedServer } from '../transport/embedded';\r\nimport { SyncEngine } from './sync-engine';\r\nimport { generateUUID } from '../utils/uuid';\r\nimport { now } from '../utils/time';\r\n\r\n/**\r\n * Visibility and focus tracking for intelligent sync triggers\r\n */\r\ninterface VisibilityState {\r\n  isVisible: boolean;\r\n  isFocused: boolean;\r\n  lastVisibleAt: number;\r\n  lastFocusAt: number;\r\n}\r\n\r\n/**\r\n * Detect execution mode based on environment\r\n */\r\nfunction detectExecutionMode(): RealityExecutionMode {\r\n  // Check for embedded server first\r\n  if (hasEmbeddedServer()) {\r\n    return 'ssr-embedded';\r\n  }\r\n  \r\n  // Check if we're in a browser\r\n  if (typeof window !== 'undefined' && typeof document !== 'undefined') {\r\n    return 'client';\r\n  }\r\n  \r\n  // Check for server-side hints\r\n  if (typeof process !== 'undefined' && process.versions?.node) {\r\n    return 'ssr-embedded';\r\n  }\r\n  \r\n  return 'client';\r\n}\r\n\r\n/**\r\n * Create transport based on execution mode\r\n */\r\nfunction createTransport(options: ResolvedRealityOptions): RealityTransport {\r\n  // If custom transport is provided, use it\r\n  if (options.transport) {\r\n    return options.transport;\r\n  }\r\n  \r\n  const executionMode = options.executionMode === 'auto' \r\n    ? detectExecutionMode() \r\n    : options.executionMode;\r\n  \r\n  switch (executionMode) {\r\n    case 'ssr-embedded':\r\n      // Use embedded with HTTP fallback if servers are configured\r\n      if (options.servers.length > 0) {\r\n        return new EmbeddedTransport({\r\n          fallback: new HttpTransport(options),\r\n        });\r\n      }\r\n      return new EmbeddedTransport();\r\n      \r\n    case 'server-external':\r\n    case 'client':\r\n    default:\r\n      if (options.servers.length === 0) {\r\n        throw new Error('No servers configured and no embedded server available');\r\n      }\r\n      return new HttpTransport(options);\r\n  }\r\n}\r\n\r\n/**\r\n * Reality Client - Main entry point for the Reality system\r\n */\r\nexport class RealityClient {\r\n  private options: ResolvedRealityOptions;\r\n  private transport: RealityTransport;\r\n  private syncEngine: SyncEngine;\r\n  private visibility: VisibilityState;\r\n  private cleanupFns: (() => void)[] = [];\r\n  private defaultFetcher?: (key: string, meta: RealityNodeMeta) => Promise<unknown>;\r\n\r\n  constructor(options: RealityOptions) {\r\n    // Validate and resolve options\r\n    const parsed = RealityOptionsSchema.safeParse(options);\r\n    if (!parsed.success) {\r\n      throw new Error(`Invalid Reality options: ${parsed.error.message}`);\r\n    }\r\n    \r\n    this.options = {\r\n      ...parsed.data,\r\n      clientId: parsed.data.clientId ?? generateUUID(),\r\n    };\r\n\r\n    // Initialize transport based on execution mode\r\n    this.transport = createTransport(this.options);\r\n\r\n    // Initialize sync engine\r\n    this.syncEngine = new SyncEngine({\r\n      clientId: this.options.clientId!,\r\n      mode: this.options.mode,\r\n      transport: this.transport,\r\n      debug: this.options.debug,\r\n      defaultFetcher: this.defaultFetcher,\r\n    });\r\n\r\n    // Initialize visibility state\r\n    this.visibility = {\r\n      isVisible: true,\r\n      isFocused: true,\r\n      lastVisibleAt: now(),\r\n      lastFocusAt: now(),\r\n    };\r\n\r\n    // Set up event listeners for browser/RN environments\r\n    this.setupEventListeners();\r\n  }\r\n\r\n  /**\r\n   * Get the current transport type\r\n   */\r\n  getTransportType(): 'http' | 'embedded' | 'custom' {\r\n    return this.transport.getType();\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a Reality node\r\n   * \r\n   * @param key - The key identifying the reality node\r\n   * @param options - Configuration options for this subscription\r\n   * @returns Unsubscribe function\r\n   */\r\n  subscribe<T>(\r\n    key: string,\r\n    callback: (state: RealityNodeState<T>) => void,\r\n    options: RealityKeyOptions<T> = {}\r\n  ): () => void {\r\n    return this.syncEngine.subscribe(key, callback, options);\r\n  }\r\n\r\n  /**\r\n   * Get current state of a Reality node\r\n   */\r\n  getState<T>(key: string): RealityNodeState<T> | null {\r\n    return this.syncEngine.getState(key);\r\n  }\r\n\r\n  /**\r\n   * Create a realtime subscription helper\r\n   * \r\n   * @param key - The key identifying the reality node\r\n   * @param options - Configuration options\r\n   * @returns Object with subscribe method and state accessor\r\n   */\r\n  realtime<T>(key: string, options: RealityKeyOptions<T> = {}) {\r\n    return {\r\n      subscribe: (callback: (state: RealityNodeState<T>) => void) => {\r\n        return this.subscribe(key, callback, options);\r\n      },\r\n      getState: () => this.getState<T>(key),\r\n      sync: (hint: SyncHint = 'interaction') => this.syncKeys([key], hint),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sync specific keys with the server\r\n   */\r\n  async syncKeys(keys: string[], hint: SyncHint = 'interaction'): Promise<void> {\r\n    return this.syncEngine.syncKeys(keys, hint);\r\n  }\r\n\r\n  /**\r\n   * Sync all subscribed keys\r\n   */\r\n  async syncAll(hint: SyncHint = 'interaction'): Promise<void> {\r\n    return this.syncEngine.syncAll(hint);\r\n  }\r\n\r\n  /**\r\n   * Perform a mutation with optimistic update\r\n   */\r\n  async mutate<T, TInput = unknown>(\r\n    key: string,\r\n    input: TInput,\r\n    mutationFn: (input: TInput) => Promise<T>,\r\n    options: MutationOptions<T, TInput> = {}\r\n  ): Promise<T> {\r\n    let rollback: (() => void) | null = null;\r\n\r\n    // Apply optimistic update if provided\r\n    if (options.optimisticUpdate) {\r\n      rollback = this.syncEngine.applyOptimisticUpdate<T>(\r\n        key,\r\n        (current) => options.optimisticUpdate!(current, input)\r\n      );\r\n    }\r\n\r\n    try {\r\n      // Perform the actual mutation\r\n      const result = await mutationFn(input);\r\n      \r\n      // Clear optimistic state\r\n      this.syncEngine.clearOptimistic(key);\r\n      \r\n      // Sync to get authoritative state\r\n      await this.syncKeys([key], 'mutation');\r\n      \r\n      // Invalidate related keys if specified\r\n      if (options.invalidateKeys && options.invalidateKeys.length > 0) {\r\n        await this.syncKeys(options.invalidateKeys, 'mutation');\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      // Rollback optimistic update on error\r\n      if (rollback && options.rollbackOnError !== false) {\r\n        rollback();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate keys (mark as stale and trigger sync)\r\n   */\r\n  async invalidate(keys: string[]): Promise<void> {\r\n    return this.syncKeys(keys, 'mutation');\r\n  }\r\n\r\n  /**\r\n   * Add event listener\r\n   */\r\n  on<T = unknown>(event: RealityEventType, handler: RealityEventHandler<T>): () => void {\r\n    return this.syncEngine.on(event, handler);\r\n  }\r\n\r\n  /**\r\n   * Set default fetcher for payloads\r\n   */\r\n  setDefaultFetcher(fetcher: (key: string, meta: RealityNodeMeta) => Promise<unknown>): void {\r\n    this.defaultFetcher = fetcher;\r\n  }\r\n\r\n  /**\r\n   * Get client ID\r\n   */\r\n  getClientId(): string {\r\n    return this.options.clientId!;\r\n  }\r\n\r\n  /**\r\n   * Get current mode\r\n   */\r\n  getMode() {\r\n    return this.options.mode;\r\n  }\r\n\r\n  /**\r\n   * Get server status (HTTP transport only)\r\n   */\r\n  getServerStatus() {\r\n    return this.transport.getServerStatus?.() ?? new Map();\r\n  }\r\n\r\n  /**\r\n   * Get sync statistics\r\n   */\r\n  getStats() {\r\n    return this.syncEngine.getStats();\r\n  }\r\n\r\n  /**\r\n   * Check if client is visible (browser/RN)\r\n   */\r\n  isVisible(): boolean {\r\n    return this.visibility.isVisible;\r\n  }\r\n\r\n  /**\r\n   * Check if client is focused (browser/RN)\r\n   */\r\n  isFocused(): boolean {\r\n    return this.visibility.isFocused;\r\n  }\r\n\r\n  /**\r\n   * Set up visibility and focus event listeners\r\n   */\r\n  private setupEventListeners(): void {\r\n    // Browser environment\r\n    if (typeof document !== 'undefined') {\r\n      const handleVisibilityChange = () => {\r\n        const isVisible = document.visibilityState === 'visible';\r\n        if (isVisible && !this.visibility.isVisible) {\r\n          // Became visible - trigger sync\r\n          this.visibility.lastVisibleAt = now();\r\n          this.syncAll('focus');\r\n        }\r\n        this.visibility.isVisible = isVisible;\r\n      };\r\n\r\n      const handleFocus = () => {\r\n        if (!this.visibility.isFocused) {\r\n          this.visibility.lastFocusAt = now();\r\n          this.syncAll('focus');\r\n        }\r\n        this.visibility.isFocused = true;\r\n      };\r\n\r\n      const handleBlur = () => {\r\n        this.visibility.isFocused = false;\r\n      };\r\n\r\n      document.addEventListener('visibilitychange', handleVisibilityChange);\r\n      window.addEventListener('focus', handleFocus);\r\n      window.addEventListener('blur', handleBlur);\r\n\r\n      this.cleanupFns.push(() => {\r\n        document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n        window.removeEventListener('focus', handleFocus);\r\n        window.removeEventListener('blur', handleBlur);\r\n      });\r\n    }\r\n\r\n    // React Native environment (AppState)\r\n    if (typeof global !== 'undefined' && (global as Record<string, unknown>).AppState) {\r\n      const AppState = (global as Record<string, unknown>).AppState as {\r\n        addEventListener: (event: string, handler: (state: string) => void) => { remove: () => void };\r\n      };\r\n      \r\n      const subscription = AppState.addEventListener('change', (state: string) => {\r\n        const isActive = state === 'active';\r\n        if (isActive && !this.visibility.isVisible) {\r\n          this.visibility.lastVisibleAt = now();\r\n          this.syncAll('focus');\r\n        }\r\n        this.visibility.isVisible = isActive;\r\n        this.visibility.isFocused = isActive;\r\n      });\r\n\r\n      this.cleanupFns.push(() => subscription.remove());\r\n    }\r\n\r\n    // Online/offline handling\r\n    if (typeof window !== 'undefined' && 'navigator' in window) {\r\n      const handleOnline = () => {\r\n        this.transport.clearAllBlacklists?.();\r\n        this.syncAll('reconnect');\r\n      };\r\n\r\n      window.addEventListener('online', handleOnline);\r\n      this.cleanupFns.push(() => window.removeEventListener('online', handleOnline));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy the client and clean up resources\r\n   */\r\n  destroy(): void {\r\n    for (const cleanup of this.cleanupFns) {\r\n      cleanup();\r\n    }\r\n    this.cleanupFns = [];\r\n    this.syncEngine.destroy();\r\n  }\r\n}\r\n\r\n/**\r\n * Create a Reality client instance\r\n */\r\nexport function createRealityClient(options: RealityOptions): RealityClient {\r\n  return new RealityClient(options);\r\n}\r\n","/**\r\n * @rootlodge/reality - React Context\r\n * \r\n * React context provider for Reality client.\r\n */\r\n\r\nimport React, { createContext, useContext, useRef, useEffect } from 'react';\r\nimport type { RealityOptions } from '../types';\r\nimport { RealityClient, createRealityClient } from '../client/reality-client';\r\n\r\n/**\r\n * React context for Reality client\r\n */\r\nconst RealityContext = createContext<RealityClient | null>(null);\r\n\r\n/**\r\n * Props for RealityProvider\r\n */\r\nexport interface RealityProviderProps {\r\n  children: React.ReactNode;\r\n  /** Reality client options */\r\n  options: RealityOptions;\r\n  /** Pre-created client instance (alternative to options) */\r\n  client?: RealityClient;\r\n}\r\n\r\n/**\r\n * Reality Provider component\r\n * \r\n * Provides Reality client to all child components.\r\n * \r\n * @example\r\n * ```tsx\r\n * <RealityProvider options={{ servers: ['https://api.example.com'] }}>\r\n *   <App />\r\n * </RealityProvider>\r\n * ```\r\n */\r\nexport function RealityProvider({ children, options, client: providedClient }: RealityProviderProps) {\r\n  const clientRef = useRef<RealityClient | null>(providedClient ?? null);\r\n\r\n  // Create client if not provided\r\n  if (!clientRef.current) {\r\n    clientRef.current = createRealityClient(options);\r\n  }\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (!providedClient && clientRef.current) {\r\n        clientRef.current.destroy();\r\n      }\r\n    };\r\n  }, [providedClient]);\r\n\r\n  return (\r\n    <RealityContext.Provider value={clientRef.current}>\r\n      {children}\r\n    </RealityContext.Provider>\r\n  );\r\n}\r\n\r\n/**\r\n * Hook to access the Reality client\r\n * \r\n * @throws Error if used outside of RealityProvider\r\n */\r\nexport function useRealityClient(): RealityClient {\r\n  const client = useContext(RealityContext);\r\n  \r\n  if (!client) {\r\n    throw new Error(\r\n      'useRealityClient must be used within a RealityProvider. ' +\r\n      'Wrap your app with <RealityProvider options={...}>.'\r\n    );\r\n  }\r\n\r\n  return client;\r\n}\r\n\r\n/**\r\n * Hook to check if Reality context is available\r\n */\r\nexport function useHasRealityContext(): boolean {\r\n  return useContext(RealityContext) !== null;\r\n}\r\n","/**\r\n * @rootlodge/reality - useReality Hook\r\n * \r\n * Main React hook for subscribing to Reality nodes.\r\n */\r\n\r\nimport { useState, useEffect, useCallback, useRef } from 'react';\r\nimport type {\r\n  RealityNodeState,\r\n  RealityKeyOptions,\r\n  SyncHint,\r\n} from '../types';\r\nimport { useRealityClient } from './context';\r\n\r\n/**\r\n * Return type for useReality hook\r\n */\r\nexport interface UseRealityReturn<T> {\r\n  /** Current data (includes optimistic updates) */\r\n  data: T | undefined;\r\n  /** Error if any occurred */\r\n  error: Error | null;\r\n  /** True while initial data is loading */\r\n  isLoading: boolean;\r\n  /** True while syncing with server */\r\n  isSyncing: boolean;\r\n  /** True if data is stale */\r\n  isStale: boolean;\r\n  /** Node metadata */\r\n  meta: RealityNodeState<T>['meta'];\r\n  /** Timestamp of last successful sync */\r\n  lastSyncAt: number | null;\r\n  /** Manually trigger a sync */\r\n  sync: (hint?: SyncHint) => Promise<void>;\r\n  /** Invalidate and refetch */\r\n  invalidate: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Hook for subscribing to a Reality node\r\n * \r\n * @param key - The key identifying the reality node\r\n * @param options - Configuration options\r\n * @returns Reality state and controls\r\n * \r\n * @example\r\n * ```tsx\r\n * function ChatRoom({ roomId }: { roomId: string }) {\r\n *   const { data: messages, isLoading, sync } = useReality<Message[]>(\r\n *     `chat:room:${roomId}`,\r\n *     { fallback: [] }\r\n *   );\r\n * \r\n *   if (isLoading) return <Loading />;\r\n * \r\n *   return (\r\n *     <div>\r\n *       {messages.map(msg => <Message key={msg.id} {...msg} />)}\r\n *       <button onClick={() => sync()}>Refresh</button>\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function useReality<T = unknown>(\r\n  key: string,\r\n  options: RealityKeyOptions<T> = {}\r\n): UseRealityReturn<T> {\r\n  const client = useRealityClient();\r\n  \r\n  // Use ref to track options changes without causing re-subscriptions\r\n  const optionsRef = useRef(options);\r\n  optionsRef.current = options;\r\n\r\n  // State for the reality node\r\n  const [state, setState] = useState<RealityNodeState<T>>(() => {\r\n    const existing = client.getState<T>(key);\r\n    return existing ?? {\r\n      key,\r\n      data: options.fallback,\r\n      meta: null,\r\n      status: 'idle',\r\n      error: null,\r\n      isLoading: true,\r\n      isSyncing: false,\r\n      isStale: true,\r\n      lastSyncAt: null,\r\n    };\r\n  });\r\n\r\n  // Subscribe to the reality node\r\n  useEffect(() => {\r\n    const unsubscribe = client.subscribe<T>(key, setState, optionsRef.current);\r\n    \r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [client, key]);\r\n\r\n  // Sync function\r\n  const sync = useCallback(\r\n    async (hint: SyncHint = 'interaction') => {\r\n      await client.syncKeys([key], hint);\r\n    },\r\n    [client, key]\r\n  );\r\n\r\n  // Invalidate function\r\n  const invalidate = useCallback(async () => {\r\n    await client.invalidate([key]);\r\n  }, [client, key]);\r\n\r\n  return {\r\n    data: state.data,\r\n    error: state.error,\r\n    isLoading: state.isLoading,\r\n    isSyncing: state.isSyncing,\r\n    isStale: state.isStale,\r\n    meta: state.meta,\r\n    lastSyncAt: state.lastSyncAt,\r\n    sync,\r\n    invalidate,\r\n  };\r\n}\r\n\r\n/**\r\n * Hook for multiple Reality nodes\r\n * \r\n * @param keys - Array of keys to subscribe to\r\n * @param options - Shared configuration options\r\n * @returns Map of key to Reality state\r\n * \r\n * @example\r\n * ```tsx\r\n * function Dashboard() {\r\n *   const states = useRealityMultiple([\r\n *     'stats:users',\r\n *     'stats:revenue',\r\n *     'stats:orders'\r\n *   ]);\r\n * \r\n *   return (\r\n *     <div>\r\n *       {Array.from(states.entries()).map(([key, state]) => (\r\n *         <StatCard key={key} data={state.data} />\r\n *       ))}\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function useRealityMultiple<T = unknown>(\r\n  keys: string[],\r\n  options: RealityKeyOptions<T> = {}\r\n): Map<string, UseRealityReturn<T>> {\r\n  const client = useRealityClient();\r\n  const optionsRef = useRef(options);\r\n  optionsRef.current = options;\r\n\r\n  // State map for all keys\r\n  const [states, setStates] = useState<Map<string, RealityNodeState<T>>>(() => {\r\n    const initial = new Map<string, RealityNodeState<T>>();\r\n    for (const key of keys) {\r\n      const existing = client.getState<T>(key);\r\n      initial.set(key, existing ?? {\r\n        key,\r\n        data: options.fallback,\r\n        meta: null,\r\n        status: 'idle',\r\n        error: null,\r\n        isLoading: true,\r\n        isSyncing: false,\r\n        isStale: true,\r\n        lastSyncAt: null,\r\n      });\r\n    }\r\n    return initial;\r\n  });\r\n\r\n  // Subscribe to all keys\r\n  useEffect(() => {\r\n    const unsubscribes: (() => void)[] = [];\r\n\r\n    for (const key of keys) {\r\n      const unsubscribe = client.subscribe<T>(key, (state) => {\r\n        setStates((prev) => {\r\n          const next = new Map(prev);\r\n          next.set(key, state);\r\n          return next;\r\n        });\r\n      }, optionsRef.current);\r\n      \r\n      unsubscribes.push(unsubscribe);\r\n    }\r\n\r\n    return () => {\r\n      for (const unsubscribe of unsubscribes) {\r\n        unsubscribe();\r\n      }\r\n    };\r\n  }, [client, keys.join(',')]);\r\n\r\n  // Build return map with controls\r\n  const result = new Map<string, UseRealityReturn<T>>();\r\n  \r\n  for (const [key, state] of states) {\r\n    result.set(key, {\r\n      data: state.data,\r\n      error: state.error,\r\n      isLoading: state.isLoading,\r\n      isSyncing: state.isSyncing,\r\n      isStale: state.isStale,\r\n      meta: state.meta,\r\n      lastSyncAt: state.lastSyncAt,\r\n      sync: async (hint: SyncHint = 'interaction') => {\r\n        await client.syncKeys([key], hint);\r\n      },\r\n      invalidate: async () => {\r\n        await client.invalidate([key]);\r\n      },\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * @rootlodge/reality - useMutation Hook\r\n * \r\n * React hook for performing mutations with optimistic updates.\r\n */\r\n\r\nimport { useState, useCallback, useRef } from 'react';\r\nimport type { MutationOptions, MutationResult } from '../types';\r\nimport { useRealityClient } from './context';\r\n\r\n/**\r\n * Return type for useMutation hook\r\n */\r\nexport interface UseMutationReturn<T, TInput> {\r\n  /** Execute the mutation */\r\n  mutate: (input: TInput) => Promise<T>;\r\n  /** Mutation state */\r\n  data: T | undefined;\r\n  error: Error | null;\r\n  isLoading: boolean;\r\n  /** Reset mutation state */\r\n  reset: () => void;\r\n}\r\n\r\n/**\r\n * Hook for performing mutations with optimistic updates\r\n * \r\n * @param key - The key to update\r\n * @param mutationFn - Function that performs the actual mutation\r\n * @param options - Mutation options including optimistic update\r\n * @returns Mutation function and state\r\n * \r\n * @example\r\n * ```tsx\r\n * function SendMessage({ roomId }: { roomId: string }) {\r\n *   const { mutate, isLoading, error } = useMutation<Message, string>(\r\n *     `chat:room:${roomId}`,\r\n *     async (text) => {\r\n *       const response = await fetch('/api/messages', {\r\n *         method: 'POST',\r\n *         body: JSON.stringify({ roomId, text }),\r\n *       });\r\n *       return response.json();\r\n *     },\r\n *     {\r\n *       optimisticUpdate: (messages, text) => [\r\n *         ...(messages ?? []),\r\n *         { id: 'temp', text, pending: true }\r\n *       ],\r\n *       rollbackOnError: true,\r\n *     }\r\n *   );\r\n * \r\n *   const handleSubmit = async (text: string) => {\r\n *     try {\r\n *       await mutate(text);\r\n *     } catch (err) {\r\n *       console.error('Failed to send message');\r\n *     }\r\n *   };\r\n * \r\n *   return <MessageInput onSubmit={handleSubmit} disabled={isLoading} />;\r\n * }\r\n * ```\r\n */\r\nexport function useMutation<T, TInput = void>(\r\n  key: string,\r\n  mutationFn: (input: TInput) => Promise<T>,\r\n  options: MutationOptions<T, TInput> = {}\r\n): UseMutationReturn<T, TInput> {\r\n  const client = useRealityClient();\r\n  const optionsRef = useRef(options);\r\n  optionsRef.current = options;\r\n\r\n  const [state, setState] = useState<MutationResult<T>>({\r\n    data: undefined,\r\n    error: null,\r\n    isLoading: false,\r\n  });\r\n\r\n  const mutate = useCallback(\r\n    async (input: TInput): Promise<T> => {\r\n      setState({ data: undefined, error: null, isLoading: true });\r\n\r\n      try {\r\n        const result = await client.mutate(key, input, mutationFn, optionsRef.current);\r\n        setState({ data: result, error: null, isLoading: false });\r\n        return result;\r\n      } catch (error) {\r\n        const err = error instanceof Error ? error : new Error(String(error));\r\n        setState({ data: undefined, error: err, isLoading: false });\r\n        throw err;\r\n      }\r\n    },\r\n    [client, key, mutationFn]\r\n  );\r\n\r\n  const reset = useCallback(() => {\r\n    setState({ data: undefined, error: null, isLoading: false });\r\n  }, []);\r\n\r\n  return {\r\n    mutate,\r\n    data: state.data,\r\n    error: state.error,\r\n    isLoading: state.isLoading,\r\n    reset,\r\n  };\r\n}\r\n\r\n/**\r\n * Hook for performing mutations that invalidate multiple keys\r\n * \r\n * @param mutationFn - Function that performs the actual mutation\r\n * @param invalidateKeys - Keys to invalidate after successful mutation\r\n * @returns Mutation function and state\r\n * \r\n * @example\r\n * ```tsx\r\n * function DeleteAllMessages({ roomId }: { roomId: string }) {\r\n *   const { mutate, isLoading } = useMutationWithInvalidation(\r\n *     async () => {\r\n *       await fetch(`/api/rooms/${roomId}/messages`, { method: 'DELETE' });\r\n *     },\r\n *     [`chat:room:${roomId}`, `chat:room:${roomId}:count`]\r\n *   );\r\n * \r\n *   return (\r\n *     <button onClick={() => mutate()} disabled={isLoading}>\r\n *       Clear All Messages\r\n *     </button>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function useMutationWithInvalidation<T, TInput = void>(\r\n  mutationFn: (input: TInput) => Promise<T>,\r\n  invalidateKeys: string[]\r\n): UseMutationReturn<T, TInput> {\r\n  const client = useRealityClient();\r\n\r\n  const [state, setState] = useState<MutationResult<T>>({\r\n    data: undefined,\r\n    error: null,\r\n    isLoading: false,\r\n  });\r\n\r\n  const mutate = useCallback(\r\n    async (input: TInput): Promise<T> => {\r\n      setState({ data: undefined, error: null, isLoading: true });\r\n\r\n      try {\r\n        const result = await mutationFn(input);\r\n        \r\n        // Invalidate all specified keys\r\n        await client.invalidate(invalidateKeys);\r\n        \r\n        setState({ data: result, error: null, isLoading: false });\r\n        return result;\r\n      } catch (error) {\r\n        const err = error instanceof Error ? error : new Error(String(error));\r\n        setState({ data: undefined, error: err, isLoading: false });\r\n        throw err;\r\n      }\r\n    },\r\n    [client, mutationFn, invalidateKeys.join(',')]\r\n  );\r\n\r\n  const reset = useCallback(() => {\r\n    setState({ data: undefined, error: null, isLoading: false });\r\n  }, []);\r\n\r\n  return {\r\n    mutate,\r\n    data: state.data,\r\n    error: state.error,\r\n    isLoading: state.isLoading,\r\n    reset,\r\n  };\r\n}\r\n","/**\r\n * @rootlodge/reality - useSync Hook\r\n * \r\n * React hook for manual sync control.\r\n */\r\n\r\nimport { useCallback } from 'react';\r\nimport type { SyncHint } from '../types';\r\nimport { useRealityClient } from './context';\r\n\r\n/**\r\n * Return type for useSync hook\r\n */\r\nexport interface UseSyncReturn {\r\n  /** Sync specific keys */\r\n  syncKeys: (keys: string[], hint?: SyncHint) => Promise<void>;\r\n  /** Sync all subscribed keys */\r\n  syncAll: (hint?: SyncHint) => Promise<void>;\r\n  /** Invalidate and sync specific keys */\r\n  invalidate: (keys: string[]) => Promise<void>;\r\n  /** Get sync statistics */\r\n  getStats: () => {\r\n    subscribedKeys: number;\r\n    lastSyncTime: number;\r\n    isSyncing: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Hook for manual sync control\r\n * \r\n * Useful when you need fine-grained control over sync timing,\r\n * or when triggering syncs from non-component code.\r\n * \r\n * @example\r\n * ```tsx\r\n * function RefreshButton() {\r\n *   const { syncAll, getStats } = useSync();\r\n *   const stats = getStats();\r\n * \r\n *   return (\r\n *     <button\r\n *       onClick={() => syncAll('interaction')}\r\n *       disabled={stats.isSyncing}\r\n *     >\r\n *       {stats.isSyncing ? 'Syncing...' : 'Refresh'}\r\n *     </button>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function useSync(): UseSyncReturn {\r\n  const client = useRealityClient();\r\n\r\n  const syncKeys = useCallback(\r\n    async (keys: string[], hint: SyncHint = 'interaction') => {\r\n      await client.syncKeys(keys, hint);\r\n    },\r\n    [client]\r\n  );\r\n\r\n  const syncAll = useCallback(\r\n    async (hint: SyncHint = 'interaction') => {\r\n      await client.syncAll(hint);\r\n    },\r\n    [client]\r\n  );\r\n\r\n  const invalidate = useCallback(\r\n    async (keys: string[]) => {\r\n      await client.invalidate(keys);\r\n    },\r\n    [client]\r\n  );\r\n\r\n  const getStats = useCallback(() => client.getStats(), [client]);\r\n\r\n  return {\r\n    syncKeys,\r\n    syncAll,\r\n    invalidate,\r\n    getStats,\r\n  };\r\n}\r\n\r\n/**\r\n * Hook for triggering sync on user interaction\r\n * \r\n * Returns a callback that triggers sync when called.\r\n * Useful for forms, buttons, and other interactive elements.\r\n * \r\n * @param keys - Keys to sync on interaction\r\n * @returns Interaction handler that triggers sync\r\n * \r\n * @example\r\n * ```tsx\r\n * function ChatInput({ roomId }: { roomId: string }) {\r\n *   const onInteraction = useSyncOnInteraction([`chat:room:${roomId}`]);\r\n * \r\n *   return (\r\n *     <input\r\n *       type=\"text\"\r\n *       onFocus={onInteraction}\r\n *       placeholder=\"Type a message...\"\r\n *     />\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function useSyncOnInteraction(keys: string[]): () => void {\r\n  const { syncKeys } = useSync();\r\n  \r\n  return useCallback(() => {\r\n    syncKeys(keys, 'interaction');\r\n  }, [syncKeys, keys.join(',')]);\r\n}\r\n\r\n/**\r\n * Hook for triggering sync when component mounts\r\n * \r\n * @param keys - Keys to sync on mount\r\n * \r\n * @example\r\n * ```tsx\r\n * function Dashboard() {\r\n *   useSyncOnMount(['stats:users', 'stats:revenue']);\r\n * \r\n *   return <DashboardContent />;\r\n * }\r\n * ```\r\n */\r\nexport function useSyncOnMount(keys: string[]): void {\r\n  const { syncKeys } = useSync();\r\n\r\n  // Use layoutEffect to sync before paint\r\n  if (typeof window !== 'undefined') {\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    const { useLayoutEffect } = require('react');\r\n    useLayoutEffect(() => {\r\n      syncKeys(keys, 'mount');\r\n    }, [keys.join(',')]);\r\n  }\r\n}\r\n"]}