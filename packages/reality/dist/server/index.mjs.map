{"version":3,"sources":["../../src/server/createServer.ts","../../src/core/store.ts","../../src/core/filter.ts","../../src/server/http.ts","../../src/server/embedded.ts"],"sourcesContent":["import { createServer, IncomingMessage, ServerResponse } from 'http';\r\nimport { EventStore } from '../core/store';\r\nimport { BloomRealityFilter } from '../core/filter';\r\nimport { handleEventsRequest, handleFilterRequest } from './http';\r\n\r\nexport interface RealityServerOptions {\r\n  port?: number;\r\n  namespace?: string;\r\n  peers?: string[]; // peers to gossip with (outbound) - TODO implement outbound gossip\r\n  storage?: 'memory';\r\n  priority?: 'high' | 'low';\r\n}\r\n\r\nexport function createRealityServer(options: RealityServerOptions) {\r\n  const store = new EventStore();\r\n  const filter = new BloomRealityFilter();\r\n  const namespace = options.namespace || 'default';\r\n\r\n  const server = createServer(async (req: IncomingMessage, res: ServerResponse) => {\r\n    // CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n\r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(204);\r\n      res.end();\r\n      return;\r\n    }\r\n\r\n    if (req.method !== 'POST') {\r\n      res.writeHead(405);\r\n      res.end('Method Not Allowed');\r\n      return;\r\n    }\r\n\r\n    const url = new URL(req.url || '', `http://${req.headers.host}`);\r\n    \r\n    // Simple body parser\r\n    const body = await new Promise<any>((resolve) => {\r\n      let data = '';\r\n      req.on('data', chunk => data += chunk);\r\n      req.on('end', () => {\r\n        try {\r\n          resolve(JSON.parse(data));\r\n        } catch {\r\n          resolve({});\r\n        }\r\n      });\r\n    });\r\n\r\n    try {\r\n      if (url.pathname === '/__reality/filter') {\r\n        const result = await handleFilterRequest({ store, filter, namespace }, body);\r\n        res.writeHead(200, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify(result));\r\n        return;\r\n      }\r\n\r\n      if (url.pathname === '/__reality/events') {\r\n        const result = await handleEventsRequest({ store, filter, namespace }, body);\r\n        res.writeHead(200, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify(result));\r\n        return;\r\n      }\r\n\r\n      res.writeHead(404);\r\n      res.end('Not Found');\r\n    } catch (error) {\r\n      console.error(error);\r\n      res.writeHead(500);\r\n      res.end('Internal Error');\r\n    }\r\n  });\r\n\r\n  const port = options.port || 8787;\r\n  \r\n  return {\r\n    start: () => {\r\n      server.listen(port, () => {\r\n        console.log(`Reality Server 2.0 running on port ${port}`);\r\n        console.log(`Namespace: ${namespace}`);\r\n      });\r\n    },\r\n    stop: () => server.close()\r\n  };\r\n}\r\n","import { RealityEvent } from './event';\r\n\r\nexport interface StoreOptions {\r\n  maxEvents?: number;\r\n  ttl?: number; // Time to live in ms\r\n}\r\n\r\nexport class EventStore {\r\n  private events: RealityEvent[] = [];\r\n  private knownIds: Set<string> = new Set();\r\n  private maxEvents: number;\r\n  private ttl: number;\r\n\r\n  constructor(options: StoreOptions = {}) {\r\n    this.maxEvents = options.maxEvents ?? 10000;\r\n    this.ttl = options.ttl ?? 24 * 60 * 60 * 1000; // 24 hours default\r\n  }\r\n\r\n  /**\r\n   * Add an event to the store.\r\n   * Returns true if event was new, false if duplicate.\r\n   */\r\n  add(event: RealityEvent): boolean {\r\n    if (this.knownIds.has(event.id)) {\r\n      return false;\r\n    }\r\n\r\n    // Insert sorted by timestamp (simple append usually fits if clocks roughly sync)\r\n    // For now, strict append is fine, we can sort on retrieval if needed\r\n    this.events.push(event);\r\n    this.knownIds.add(event.id);\r\n\r\n    // Prune if needed\r\n    if (this.events.length > this.maxEvents) {\r\n      this.gc();\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if we have an event\r\n   */\r\n  has(id: string): boolean {\r\n    return this.knownIds.has(id);\r\n  }\r\n\r\n  /**\r\n   * Get all events\r\n   */\r\n  getAll(): RealityEvent[] {\r\n    return this.events;\r\n  }\r\n\r\n  /**\r\n   * Get events not present in the provided check function (Filter)\r\n   */\r\n  getMissing(hasIt: (id: string) => boolean): RealityEvent[] {\r\n    // Return events that the OTHER party does NOT have\r\n    const missing: RealityEvent[] = [];\r\n    for (const event of this.events) {\r\n      if (!hasIt(event.id)) {\r\n        missing.push(event);\r\n      }\r\n    }\r\n    return missing;\r\n  }\r\n\r\n  /**\r\n   * Garbage Collection\r\n   * Remove old events or exceed limit\r\n   */\r\n  private gc() {\r\n    const now = Date.now();\r\n    \r\n    // 1. TTL Pruning\r\n    // 2. Size Pruning\r\n    \r\n    // Efficient approach: Filter in place\r\n    // But Array.filter creates new array. splice is better for huge arrays at start.\r\n    \r\n    // Find split point for TTL\r\n    // assuming rough time order\r\n    \r\n    // Simple implementation: Strict Limit Enforcement\r\n    if (this.events.length > this.maxEvents) {\r\n      const excess = this.events.length - this.maxEvents;\r\n      const removed = this.events.splice(0, excess);\r\n      for (const ev of removed) {\r\n        this.knownIds.delete(ev.id);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear store\r\n   */\r\n  clear() {\r\n    this.events = [];\r\n    this.knownIds.clear();\r\n  }\r\n}\r\n","import pkg from 'bloom-filters';\r\nimport type { BloomFilter as BloomFilterType } from 'bloom-filters';\r\nconst { BloomFilter } = pkg;\r\nimport { RealityFilter } from './event';\r\n\r\n/**\r\n * Filter implementation using Bloom Filters.\r\n * Probabilistic set:\r\n * - False positives possible (might say \"I have this event\" when I don't)\r\n * - False negatives IMPOSSIBLE (never says \"I don't have this\" if I do)\r\n * \r\n * This is safe for sync because if I falsely claim to have an event, \r\n * I just miss receiving it this round. Next round with a fresh/different filter \r\n * (or just random chance) likely fixes it. Or explicit \"fill gaps\" mechanism.\r\n * \r\n * Actually, for Reality 2.0, false positives in \"Have\" filter = Missing Data permanently if not careful.\r\n * \r\n * BUT: The gossip protocol sends \"Here is my filter (what I have)\".\r\n * Peer checks: \"Do I have anything NOT in this filter?\"\r\n * If Peer has Event E, and Filter says \"Yes I have E\" (False Positive), peer won't send E.\r\n * \r\n * To mitigate:\r\n * 1. Low error rate configuration.\r\n * 2. Periodic full-sync or \"I'm missing X\" explicit requests if gaps detected.\r\n * 3. Or use Invertible Bloom Lookup Tables (IBLT) for exact reconciliation (advanced).\r\n * \r\n * For Reality 2.0 MVP, we use standard Bloom Filter with conservative sizing.\r\n */\r\nexport class BloomRealityFilter implements RealityFilter {\r\n  private filter: BloomFilterType;\r\n\r\n  constructor(size = 1000, errorRate = 0.01) {\r\n    // Estimate: m = ceil((n * log(p)) / log(1 / (pow(2, log(2)))));\r\n    // k = round((m / n) * log(2));\r\n    this.filter = BloomFilter.create(size, errorRate);\r\n  }\r\n\r\n  add(id: string): void {\r\n    this.filter.add(id);\r\n  }\r\n\r\n  has(id: string): boolean {\r\n    return this.filter.has(id);\r\n  }\r\n\r\n  serialize(): string {\r\n    const json = this.filter.saveAsJSON();\r\n    // Compress or encode if needed, for now JSON string is fine\r\n    return JSON.stringify(json);\r\n  }\r\n\r\n  static from(serialized: string): BloomRealityFilter {\r\n    const instance = new BloomRealityFilter();\r\n    const json = JSON.parse(serialized);\r\n    instance.filter = BloomFilter.fromJSON(json);\r\n    return instance;\r\n  }\r\n\r\n  merge(other: RealityFilter): void {\r\n    // Bloom filters can be merged with bitwise OR if same size/seeds\r\n    // simplified: we don't merge filters in MVP, we just replace or add items\r\n    throw new Error('Merge not implemented for simple BloomFilter');\r\n  }\r\n}\r\n","import { EventStore } from '../core/store';\r\nimport { BloomRealityFilter } from '../core/filter';\r\nimport { RealityEvent } from '../core/event';\r\nimport { nanoid } from 'nanoid';\r\n\r\nexport interface ServerContext {\r\n  store: EventStore;\r\n  filter: BloomRealityFilter; // Current server state filter\r\n  namespace: string;\r\n}\r\n\r\n/**\r\n * Handle POST /__reality/filter\r\n * Receive peer's filter, return events they are missing.\r\n */\r\nexport async function handleFilterRequest(\r\n  ctx: ServerContext,\r\n  body: { filter: string; origin: string }\r\n): Promise<{ events: RealityEvent[]; serverFilter: string }> {\r\n  // 1. Reconstruct peer filter\r\n  const peerFilter = BloomRealityFilter.from(body.filter);\r\n\r\n  // 2. Find events we have that they miss\r\n  // We iterate our store and check if peerFilter.has(id)\r\n  const missingEvents = ctx.store.getMissing((id) => peerFilter.has(id));\r\n\r\n  // 3. Return events + our current filter (so they can send us what we miss)\r\n  return {\r\n    events: missingEvents,\r\n    serverFilter: ctx.filter.serialize(),\r\n  };\r\n}\r\n\r\n/**\r\n * Handle POST /__reality/events\r\n * Receive new events from peer.\r\n */\r\nexport async function handleEventsRequest(\r\n  ctx: ServerContext,\r\n  body: { events: RealityEvent[]; origin: string }\r\n): Promise<{ added: number }> {\r\n  let added = 0;\r\n  \r\n  for (const event of body.events) {\r\n    if (ctx.store.add(event)) {\r\n      ctx.filter.add(event.id);\r\n      added++;\r\n    }\r\n  }\r\n\r\n  return { added };\r\n}\r\n","import { EventStore } from '../core/store';\r\nimport { BloomRealityFilter } from '../core/filter';\r\nimport { handleEventsRequest, handleFilterRequest } from './http';\r\n\r\nexport interface EmbeddedServerOptions {\r\n  namespace?: string;\r\n  hmrSafe?: boolean;\r\n}\r\n\r\n// Global singleton for HMR safety if needed\r\ndeclare global {\r\n  var __REALITY_STORE__: EventStore | undefined;\r\n  var __REALITY_FILTER__: BloomRealityFilter | undefined;\r\n}\r\n\r\nexport function createEmbeddedRealityServer(options: EmbeddedServerOptions) {\r\n  const namespace = options.namespace || 'default';\r\n  \r\n  // HMR Safety: Reuse store if exists\r\n  let store: EventStore;\r\n  let filter: BloomRealityFilter;\r\n\r\n  if (options.hmrSafe && globalThis.__REALITY_STORE__) {\r\n    // console.log('[Reality] Reusing existing store (HMR)');\r\n    store = globalThis.__REALITY_STORE__;\r\n    filter = globalThis.__REALITY_FILTER__!;\r\n  } else {\r\n    store = new EventStore();\r\n    filter = new BloomRealityFilter();\r\n    \r\n    if (options.hmrSafe) {\r\n      globalThis.__REALITY_STORE__ = store;\r\n      globalThis.__REALITY_FILTER__ = filter;\r\n    }\r\n  }\r\n\r\n  // Next.js Route Handler / Fetch Adapter\r\n  const handleRequest = async (request: Request): Promise<Response> => {\r\n    try {\r\n      const url = new URL(request.url);\r\n      const body = await request.json();\r\n\r\n      if (url.pathname.endsWith('/filter')) {\r\n        const result = await handleFilterRequest({ store, filter, namespace }, body);\r\n        return Response.json(result);\r\n      }\r\n\r\n      if (url.pathname.endsWith('/events')) {\r\n        const result = await handleEventsRequest({ store, filter, namespace }, body);\r\n        return Response.json(result);\r\n      }\r\n\r\n      return new Response('Not Found', { status: 404 });\r\n    } catch (e) {\r\n      console.error(e);\r\n      return new Response('Internal Error', { status: 500 });\r\n    }\r\n  };\r\n\r\n  return {\r\n    handleRequest,\r\n    store, // exposed for internal usage if needed\r\n  };\r\n}\r\n"],"mappings":"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","names":[]}